{"version":3,"file":"static/js/716.0dcf8329.chunk.js","mappings":"8vEAEA,MA6BA,EA7BuBA,IAAuC,IAAtC,WAACC,EAAU,SAAEC,KAAaC,GAAMH,EAEpD,MAAMI,EAAgBD,EAAMC,cAAgBD,EAAMC,cAAgB,OAElE,OAEIC,EAAAA,EAAAA,MAAA,OAAKC,MAAO,CAACC,SAAU,YAAYC,SAAA,EAC/BC,EAAAA,EAAAA,KAAA,YAAWN,EAAKK,UACZC,EAAAA,EAAAA,KAAA,UAAQC,IAAKP,EAAMO,IAAKC,KAAK,iBAEhCV,GACGQ,EAAAA,EAAAA,KAAA,OAAKG,UAAU,cAAcN,MAAO,CAChCC,SAAU,WACVM,OAAQ,EACRC,KAAM,EACNC,gBAAiB,yBACjBC,MAAO,OACPd,SAAUA,GAAYA,EACtBe,UAAW,SACXC,QAAS,WACTd,cAAeA,GACjBI,SACGP,IAEL,OACF,GC2BR,cAAEkB,GAAkBC,EAAAA,GA09C1B,EAx9CaC,KACT,MAAMC,EAAUH,IAEhB,OAEId,EAAAA,EAAAA,MAACkB,EAAAA,EAAW,CAACC,MAAOC,EAAAA,KAAKD,MAAOE,MAAOD,EAAAA,KAAKE,OAAQC,UAAW,uCAAwCC,YAAa,wCAAwCrB,SAAA,EACxJC,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,WAAWlB,UAAU,gBAAeJ,SAAC,cAG5CC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACF,cAAe,OAAQa,UAAW,UAAUT,UACrDC,EAAAA,EAAAA,KAAA,SAAOH,MAAO,CAACyB,UAAW,QAASf,MAAO,QAAUgB,UAAQ,EAACC,MAAI,EAACC,OAAK,EAAA1B,UACnEC,EAAAA,EAAAA,KAAA,UAAQC,IAAKyB,EAAWxB,KAAK,mBAGrCF,EAAAA,EAAAA,KAAA,KAAAD,SAAG,kPAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,+VAKHC,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAC+B,EAAAA,EAAQ,CAACC,UAAQ,EAACC,cAAe,IAAMC,OAAO,OAAOjC,MAAO,CAACkC,OAAQ,SAAUpC,cAAe,OAAQY,MAAO,OAAQyB,SAAU,SAASjC,SAAA,EACrIC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKiC,EAAO1C,WAAY,mHACxCQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKkC,EAAY3C,WAAY,4IAC7CQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKmC,EAAiB5C,WAAY,4IAClDQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKoC,EAAe7C,WAAY,sIAChDQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKqC,EAAe9C,WAAY,8IAEpDQ,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,sJAGHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,kKAGHC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAACuC,EAAAA,EAAO,CAAC1C,MAAO,CAAC2C,eAAgB,MAAOC,eAAgB,UAAWC,QAAS,OAC5E1C,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,UAAUlB,UAAU,gBAAeJ,SAAC,aAG3CH,EAAAA,EAAAA,MAAC+B,EAAAA,EAAQ,CAACC,UAAQ,EAACC,cAAe,IAAMC,OAAO,OAAOjC,MAAO,CAACkC,OAAQ,SAAUpC,cAAe,OAAQY,MAAO,QAAQR,SAAA,EAClHC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAK0C,EAAKnD,WAAY,SACtCQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAK2C,EAAQpD,WAAY,YACzCQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAK4C,EAAOrD,WAAY,aACjC,4DAC6CQ,EAAAA,EAAAA,KAAA,KAAG8C,KAAM,wCAAyCC,OAAO,SAAQhD,SAAC,SAAS,sFACnIC,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,UACLA,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACU,MAAO,OAAQyB,SAAU,QAASD,OAAQ,SAAUiB,YAAa,OAAOjD,UACjFC,EAAAA,EAAAA,KAAA,UAAQO,MAAM,OAAO0C,OAAO,OAAOC,YAAY,IAAIjD,IAAI,+EAA+EkD,iBAAe,OAEzJnD,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAACuC,EAAAA,EAAO,CAAC1C,MAAO,CAAC2C,eAAgB,MAAOC,eAAgB,UAAWC,QAAS,OAC5E1C,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,aAAalB,UAAU,gBAAeJ,SAAC,gBAG9CC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,eAAelB,UAAU,gBAAeJ,SAAC,kBAGhDH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,iRAE0GC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,iBAAyB,kTAI5IC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,wOAGHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,qjBAwB9BC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,0LAGHC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKyD,EAAUlE,WAAY,+EAC3CQ,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,UACLA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,MAAMlB,UAAU,gBAAeJ,SAAC,sCAGvCC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,wRAIHH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,oNAEgCC,EAAAA,EAAAA,KAAA,KAAG8C,KAAK,gDAA+C/C,SAAC,+EAA+E,kTAI1KC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,4EAU9BC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,iMAIHC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACU,MAAO,OAAQyB,SAAU,QAASD,OAAQ,SAAUiB,YAAa,OAAOjD,UACjFC,EAAAA,EAAAA,KAAA,UAAQO,MAAM,OAAO0C,OAAO,OAAOC,YAAY,IAAIjD,IAAI,+EAA+EkD,iBAAe,OAEzJnD,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,+EAC4EC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,UAAS,yBAAqBC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,2CAAmD,QAEzKC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,mBAAmBlB,UAAU,gBAAeJ,SAAC,mCAGpDC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,iOAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,8EAGHH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,0HACuHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,QAAO,+BAA2BC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,WAAU,6FAC5FC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,6EAA4E,QAE/JH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,mGAEkCC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,aAAY,4DAAwDC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,aAAY,qEAAiEC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,kCAAkC,4CAEjOC,EAAAA,EAAAA,KAAA,SAGAA,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,8SAgB9BC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,qQAIHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,yQAoB9BC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,UAAUlB,UAAU,gBAAeJ,SAAC,oBAG3CC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,+RAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,2TAKHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,oHAGHC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,mWAKHC,EAAAA,EAAAA,KAAC2D,EAAc,CACXnE,WAAY,yHACZS,IAAK2D,EACL/D,MAAO,CAACyB,UAAW,QAASf,MAAO,QACnCgB,UAAQ,EAACC,MAAI,EAACC,OAAK,KAEvBzB,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,UACLA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,6CAGHC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAK4D,EAAarE,WAAY,uDAC9CQ,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,8NAIHH,EAAAA,EAAAA,MAAC+B,EAAAA,EAAQ,CAACC,UAAQ,EAACC,cAAe,IAAMC,OAAO,OAAOjC,MAAO,CAACkC,OAAQ,SAAUpC,cAAe,OAAQY,MAAO,QAAQR,SAAA,EAClHC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAK6D,EAActE,WAAY,qDAC/CQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAK8D,EAAcvE,WAAY,wDAC/CQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAK+D,EAAcxE,WAAY,kHAC/CQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKgE,EAAiBzE,WAAY,gCAEtDQ,EAAAA,EAAAA,KAAA,KAAAD,SAAG,qKAGHC,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAA,KAAAG,SAAA,EACIC,EAAAA,EAAAA,KAAA,KAAAD,UAAGC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,iCACNC,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,SAAK,+HAGdA,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,mHAW9BC,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAA,KAAAG,SAAA,EACIC,EAAAA,EAAAA,KAAA,KAAAD,UAAGC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,wDACNC,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,SAAK,uPAIdJ,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,qOAEwDC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,WAAU,qJAGxEC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,qWAgB9BC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,qGAGHC,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAA,KAAAG,SAAA,EACIC,EAAAA,EAAAA,KAAA,KAAAD,UAAGC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,+BACNC,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,SAAK,uKAEUA,EAAAA,EAAAA,KAACkE,EAAAA,GAAQ,CAACC,QAAM,EAACC,GAAG,cAAarE,SAAC,sBAA4B,2EAEtFC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,sUAe9BC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,8GAGHC,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAA,KAAAG,SAAA,EACIC,EAAAA,EAAAA,KAAA,KAAAD,UAAGC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,+BACNC,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,SAAK,2MAIdA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,YAAYlB,UAAU,gBAAeJ,SAAC,kCAG7CC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,2PAIHC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACU,MAAO,OAAQyB,SAAU,QAASD,OAAQ,SAAUiB,YAAa,OAAOjD,UACjFC,EAAAA,EAAAA,KAAA,UAAQO,MAAM,OAAO0C,OAAO,OAAOC,YAAY,IAAIjD,IAAI,+EAA+EkD,iBAAe,OAEzJnD,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,2KAGHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,kWAKHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,uQAe9BC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,gJAGHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,2VAKHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,qEAGHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,sUAkB9BC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,mSAIHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,mRAiB9BC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,eAAelB,UAAU,gBAAeJ,SAAC,6BAGhDC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,kLAGHC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKoE,EAAe7E,WAAY,kCAChDQ,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,2FAGHC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACU,MAAO,OAAQyB,SAAU,QAASD,OAAQ,SAAUiB,YAAa,OAAOjD,UACjFC,EAAAA,EAAAA,KAAA,UAAQO,MAAM,OAAO0C,OAAO,OAAOC,YAAY,IAAIjD,IAAI,+EAA+EkD,iBAAe,OAEzJnD,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,8LAEuCC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,iBAAgB,8DAA0DC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,+BAA8B,cAExJC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,wGAGHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,2IAa9BC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,kJAGHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,8hBAKHH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,4CACyCC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,yBAAwB,SAAKC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,4FAA4F,yCAE3KC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,8JAGHC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,aAAalB,UAAU,gBAAeJ,SAAC,0CAG9CC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,8HAGHH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,iLAC8KC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,cAAsB,+HAG7MH,EAAAA,EAAAA,MAAA,OAAKC,MAAO,CAACyE,YAAa,MAAOC,aAAc,OAAOxE,SAAA,EAClDH,EAAAA,EAAAA,MAAC4E,EAAAA,EAAG,CAACrE,UAAU,qBAAqBN,MAAO,CAAC4E,QAAS,QAAQ1E,SAAA,EACzDH,EAAAA,EAAAA,MAAC8E,EAAAA,EAAG,CAACvE,UAAU,qBAAoBJ,SAAA,EAACC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,QAAO,oBAC9CH,EAAAA,EAAAA,MAAC8E,EAAAA,EAAG,CAACvE,UAAU,qBAAqBwE,KAAK,MAAK5E,SAAA,CAAC,cACjCC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,oBAA4B,8EAGpDC,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAC4E,EAAAA,EAAG,CAACrE,UAAU,qBAAqBN,MAAO,CAAC4E,QAAS,QAAQ1E,SAAA,EACzDH,EAAAA,EAAAA,MAAC8E,EAAAA,EAAG,CAACvE,UAAU,qBAAoBJ,SAAA,EAACC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,QAAO,oBAC9CC,EAAAA,EAAAA,KAAC0E,EAAAA,EAAG,CAACvE,UAAU,qBAAqBwE,KAAK,MAAK5E,SAAC,mEAInDC,EAAAA,EAAAA,KAAA,aAEJA,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,qDAGHH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,8DAC2DC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,oBAA6B,kRAGjGH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,+GAC4GC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,QAAO,kFAC9FC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,QAAgB,kLAGjDH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,iDAC8CC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,mBAAmB,2QAGvEH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,+CAC4CC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,8BAA6B,gLAG/EH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,6IAEUC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,8BAAsC,SAAKC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,8BAAsC,yCAE1GC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,+EAGHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,gIAGHC,EAAAA,EAAAA,KAAA,KAAAD,UACAC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,wUAgB9BH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,8DAC2DC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,qBAAqB,sHAEtFC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,6YAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,kQAGHC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,mLAGHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,8SAe9BC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,gMAGHC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,gIAGHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,uiBAwB9BC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAK2E,EAAiBpF,WAAY,sDAClDQ,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,UACLA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,oDAGHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,kfAyB9BC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAK4E,EAAoBrF,WAAY,yCACrDQ,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,UACLA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,uPAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,mFAGHH,EAAAA,EAAAA,MAAC+B,EAAAA,EAAQ,CAACC,UAAQ,EAACC,cAAe,IAAMC,OAAO,OAAOjC,MAAO,CAACkC,OAAQ,SAAUpC,cAAe,OAAQY,MAAO,QAAQR,SAAA,EAClHC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAK6E,EAAoBtF,WAAY,0EACrDQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAK8E,EAAkBvF,WAAY,2FACnDQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAK+E,EAAkBxF,WAAY,8GAEvDQ,EAAAA,EAAAA,KAAA,KAAAD,SAAG,qIAGHH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,uBACoBC,EAAAA,EAAAA,KAAA,KAAG8C,KAAK,iDAAiDC,OAAO,SAAQhD,SAAC,iDAAgD,6LACnBC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,WAAU,kGAG1IC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,QAAQlB,UAAU,gBAAeJ,SAAC,6BAGzCC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,6IAGHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,uKAGHH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,iDAC8CC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,qBAAqB,MAACC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,0BAA0B,UAAKC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,YAAW,QAE1HC,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAA,KAAAG,SAAA,EACIC,EAAAA,EAAAA,KAAA,KAAAD,UAAGC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,2BACNC,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,SAAK,4OAIdA,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,mWAqB9BC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,2ZAKHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,yOAIHC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,2TAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,iKAGHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,00BA8B9BC,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAA,KAAAG,SAAA,EACIC,EAAAA,EAAAA,KAAA,KAAAD,UAAGC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,gCACNC,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,SAAK,uhBAKdA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,qKAGHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,+CAGHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,0PAiB9BC,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAA,KAAAG,SAAA,EACIC,EAAAA,EAAAA,KAAA,KAAAD,UAAGC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,kBACNC,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,SAAK,udAKdA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,uMAGHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,sUAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,oJAGHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,2JAe9BC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,UAAUlB,UAAU,gBAAeJ,SAAC,8CAG3CC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,sNAGHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,uMAGHC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,qHAGHC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACJ,SAAUoB,EAAQoE,GAAK,UAAY,GAAIX,YAAa,MAAOC,aAAc,MAAO/D,UAAW,UAAUT,UAC9GC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,8KAEVC,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,+EAC4EC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,QAAgB,6DAErGH,EAAAA,EAAAA,MAAA,OAAKC,MAAO,CAACJ,SAAUoB,EAAQoE,GAAK,UAAY,IAAKlF,SAAA,EACrDC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACyE,YAAa,MAAOC,aAAc,MAAO/D,UAAW,UAAUT,UACvEC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,kJAEVC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACyE,YAAa,MAAOC,aAAc,MAAO/D,UAAW,UAAUT,UACvEC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,kJAEVC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACyE,YAAa,MAAOC,aAAc,MAAO/D,UAAW,UAAUT,UACvEC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,qJAGVC,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,wIACqIC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,6DAAqE,0CAGnNH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,oEACiEC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,WAAmB,oGAAgGC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,QAAgB,6BAEnNC,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,qHACkHC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,QAAgB,oBAE3IC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,mDAGHC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACyE,YAAa,MAAOC,aAAc,MAAO/D,UAAW,UAAUT,UACvEC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,qRAEVC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,+KAGHC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACJ,SAAUoB,EAAQoE,GAAK,UAAY,GAAIlD,OAAQ,SAAUxB,MAAO,cAAe+D,YAAa,MAAOC,aAAc,MAAO/D,UAAW,QAAQT,UACpJC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,wiBAUVC,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,6BAC0BC,EAAAA,EAAAA,KAAA,KAAG8C,KAAK,6CAA6CC,OAAO,SAAQhD,SAAC,mCAAkC,2DAEpIC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,mGAGHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,oSAe9BC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,0CAGHC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKiF,EAAa1F,WAAY,+EAC9CQ,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,0IAGHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,uVAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,4RAIHC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,2GAGHC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,UAAUlB,UAAU,gBAAeJ,SAAC,uBAG3CH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,mMAEsEC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,+CAA8C,yJAG1HC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,wMAGHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,8RAIHC,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,UACLA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,mQAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,8EAGHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,okBA4B9BC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKkF,EAAa3F,WAAY,4CAC9CQ,EAAAA,EAAAA,KAAA,UACAJ,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,8VAGOC,EAAAA,EAAAA,KAAA,KAAG8C,KAAK,4CAA4CC,OAAO,SAAQhD,SAAC,gBAAe,QAE7FC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,8YAKHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,oiBAKHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,4DAGHC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACkC,OAAQ,SAAUxB,MAAO,cAAe+D,YAAa,MAAOC,aAAc,MAAO/D,UAAW,QAAQT,UAC7GC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,2HAEVC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,4DAGHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,omBA+B9BC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKmF,EAAa5F,WAAY,2BAC9CQ,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,4dAKHC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,yMAGHC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACU,MAAO,OAAQyB,SAAU,QAASD,OAAQ,SAAUiB,YAAa,OAAOjD,UACjFC,EAAAA,EAAAA,KAAA,UAAQO,MAAM,OAAO0C,OAAO,OAAOC,YAAY,IAAIjD,IAAI,+EAA+EkD,iBAAe,OAEzJnD,EAAAA,EAAAA,KAAA,UAAKA,EAAAA,EAAAA,KAAA,UACLA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,KAAKlB,UAAU,gBAAeJ,SAAC,uBAGtCC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,8QAIHH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,+RAE2FC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,qBAAqB,uCAAkCC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,uBAAuB,8DAElLH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,iDAC8CC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,mEAAkE,kKAGtHH,EAAAA,EAAAA,MAAC+B,EAAAA,EAAQ,CAACC,UAAQ,EAACC,cAAe,IAAMC,OAAO,OAAOjC,MAAO,CAACkC,OAAQ,SAAUpC,cAAe,OAAQY,MAAO,QAAQR,SAAA,EAClHC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKoF,EAAM7F,WAAY,iDACvCQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKqF,EAAgB9F,WAAY,gCAErDQ,EAAAA,EAAAA,KAAA,KAAAD,SAAG,gLAGHH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,0DACuDC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,wBAAuB,kCAA8BC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,QAAO,oPAC4CC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,aAAY,4CAEvLC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,mTAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,gPAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,+MAGHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,41BAgC9BC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,+QAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,6KAGHH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,6VAGsCC,EAAAA,EAAAA,KAACkE,EAAAA,GAAQ,CAACC,QAAM,EAACC,GAAG,QAAOrE,SAAC,iBAAuB,8GAE5FC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,oEAGHH,EAAAA,EAAAA,MAAC+B,EAAAA,EAAQ,CAACC,UAAQ,EAACC,cAAe,IAAMC,OAAO,OAAOjC,MAAO,CAACkC,OAAQ,SAAUpC,cAAe,OAAQY,MAAO,QAAQR,SAAA,EAClHC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKqF,EAAgB9F,WAAY,8CACjDQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKsF,EAAc/F,WAAY,iDAEnDQ,EAAAA,EAAAA,KAAA,KAAAD,SAAG,gRAIHC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,YAAYlB,UAAU,gBAAeJ,SAAC,8BAG7CC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,2WAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,wdAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,8RAIHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,gGAY9BC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,0LAGHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,wFAGHC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeN,MAAO,CAACU,MAAO,QAAQR,UACjDC,EAAAA,EAAAA,KAACqD,EAAAA,EAAiB,CACdC,SAAS,MACTC,iBAAiB,EACjB1D,MAAO2D,EAAAA,EACPC,mBAAoB,EAAE1D,SAAA,q8BAoC9BC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,sLAGHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,qHAGHC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,oBAAoBlB,UAAU,gBAAeJ,SAAC,8BAGrDC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,0PAIHC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACyE,YAAa,MAAOC,aAAc,MAAO/D,UAAW,UAAUT,UACvEC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,yDAEVC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACyE,YAAa,MAAOC,aAAc,MAAO/D,UAAW,UAAUT,UACvEC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,wEAEVC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,qGAGHC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACyE,YAAa,MAAOC,aAAc,MAAO/D,UAAW,UAAUT,UACvEC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,0FAEVC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,oTAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,6KAGHC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACyE,YAAa,MAAOC,aAAc,MAAO/D,UAAW,UAAUT,UACvEC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,6GAEVC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACyE,YAAa,MAAOC,aAAc,MAAO/D,UAAW,UAAUT,UACvEC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,uIAEVC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,4QAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,iTAIHC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACyE,YAAa,MAAOC,aAAc,MAAO/D,UAAW,UAAUT,UACvEC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,mKAEVC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACyE,YAAa,MAAOC,aAAc,MAAO/D,UAAW,UAAUT,UACvEC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,0MAEVC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,2CAGHH,EAAAA,EAAAA,MAAC+B,EAAAA,EAAQ,CAACC,UAAQ,EAACC,cAAe,IAAMC,OAAO,OAAOjC,MAAO,CAACkC,OAAQ,SAAUpC,cAAe,OAAQY,MAAO,QAAQR,SAAA,EAClHC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKuF,EAAehG,WAAY,6CAChDQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKwF,EAAmBjG,WAAY,4CACpDQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAKyF,EAAqBlG,WAAY,0DAE1DQ,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,cAAclB,UAAU,gBAAeJ,SAAC,kBAG/CC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,2GAGHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,ybAKHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,6OAIHH,EAAAA,EAAAA,MAAA,KAAAG,SAAA,CAAG,oFACiFC,EAAAA,EAAAA,KAACkE,EAAAA,GAAQ,CAACC,QAAM,EAACC,GAAG,SAAQrE,SAAC,UAAiB,UAAKC,EAAAA,EAAAA,KAACkE,EAAAA,GAAQ,CAACC,QAAM,EAACC,GAAG,WAAUrE,SAAC,6BAAmC,wHACnFC,EAAAA,EAAAA,KAAA,KAAG8C,KAAK,yDAAyDC,OAAO,SAAS4C,IAAI,aAAY5F,SAAC,sFAAqF,QAE7SC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,kMAGHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,oKAGHC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACyE,YAAa,MAAOC,aAAc,MAAO/D,UAAW,UAAUT,UACvEC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,4JAEVC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,qQAIHC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,6GAGHC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACyE,YAAa,MAAOC,aAAc,MAAO/D,UAAW,UAAUT,UACvEC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,wJAEVC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,4NAIHC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACyE,YAAa,MAAOC,aAAc,MAAO/D,UAAW,UAAUT,UACvEC,EAAAA,EAAAA,KAACoD,EAAAA,EAAK,CAAArD,SAAA,gLAEVC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,KAAAD,SAAG,mFAGHH,EAAAA,EAAAA,MAAC+B,EAAAA,EAAQ,CAACC,UAAQ,EAACC,cAAe,IAAMC,OAAO,OAAOjC,MAAO,CAACkC,OAAQ,SAAUpC,cAAe,OAAQY,MAAO,QAAQR,SAAA,EAClHC,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAK2F,EAAcpG,WAAY,sCAC/CQ,EAAAA,EAAAA,KAACiC,EAAAA,EAAc,CAAChC,IAAK4F,EAAoBrG,WAAY,uDAEzDQ,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,cAAclB,UAAU,gBAAeJ,SAAC,6CAG/CC,EAAAA,EAAAA,KAAA,KAAAD,SAAG,qEAGHC,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,MAAMlB,UAAU,gBAAeJ,SAAC,2CAGvCC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,cAAclB,UAAU,gBAAeJ,SAAC,gCAG/CC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,MAAMlB,UAAU,gBAAeJ,SAAC,mBAGvCC,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,QAAQlB,UAAU,gBAAeJ,SAAC,uBAGzCC,EAAAA,EAAAA,KAAA,UACAA,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,MAAMlB,UAAU,gBAAeJ,SAAC,yBAIvCC,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,QAAQlB,UAAU,gBAAeJ,SAAC,kCAGzCC,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,MAAMlB,UAAU,gBAAeJ,SAAC,gBAGvCC,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,OAAOlB,UAAU,gBAAeJ,SAAC,2BAGxCC,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,aAAalB,UAAU,gBAAeJ,SAAC,wBAG9CC,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,QAAQlB,UAAU,gBAAeJ,SAAC,4BAGzCC,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,UAAUlB,UAAU,gBAAeJ,SAAC,8BAG3CC,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,YAAYlB,UAAU,gBAAeJ,SAAC,sBAGnC,C,sECzgDtB,MA0BA,EA1BuBR,IAAuC,IAAtC,WAACC,EAAU,SAAEC,KAAaC,GAAMH,EAEpD,MAAMI,EAAgBD,EAAMC,cAAgBD,EAAMC,cAAgB,OAElE,OACIC,EAAAA,EAAAA,MAAA,OAAKC,MAAO,CAACC,SAAU,YAAYC,SAAA,EAC/BC,EAAAA,EAAAA,KAAC8F,EAAAA,EAAK,IAAKpG,IACVF,GACGQ,EAAAA,EAAAA,KAAA,OAAKG,UAAU,cAAcN,MAAO,CAChCC,SAAU,WACVM,OAAQ,EACRC,KAAM,EACNC,gBAAiB,yBACjBC,MAAO,OACPd,SAAUA,GAAYA,EACtBe,UAAW,SACXC,QAAS,WACTd,cAAeA,GACjBI,SACGP,IAEL,OACF,C,0IClBd,MAyDA,EAzDqBD,IAA2D,IAA1D,MAACwB,EAAK,UAAEI,EAAS,aAAE4E,EAAY,YAAE3E,EAAW,MAAEH,GAAM1B,EACtE,MAAMyG,GAAMC,EAAAA,EAAAA,MAAcC,SAM1B,OAJAC,EAAAA,EAAAA,YAAU,KACNC,OAAOC,SAAS,EAAG,EAAE,GACpB,KAGDzG,EAAAA,EAAAA,MAAA0G,EAAAA,SAAA,CAAAvG,SAAA,EACAC,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CACR0G,UAAW,QACXC,gBAAgB,OAADC,OAASxF,EAAK,KAC7ByF,mBAAoB,SACpBC,eAAgB,QAChBC,iBAAkB,YAClB3D,OAAQ,QACR4D,QAAS,MAEbjH,EAAAA,EAAAA,MAAA,OAAKO,UAAU,uBAAuBN,MAAO,CAACC,SAAU,WAAYS,MAAO,OAAQuG,IAAK,QAASzG,KAAM,MAAO0G,UAAW,uBAAuBhH,SAAA,EAC5IH,EAAAA,EAAAA,MAAA,UAAQO,UAAU,cAAaJ,SAAA,EAC3BC,EAAAA,EAAAA,KAAA,MAAIqB,GAAG,QAAQxB,MAAO,CAAC4E,QAAS,gBAAgB1E,SAAEgB,KAClDnB,EAAAA,EAAAA,MAAA,QAAMC,MAAO,CAACY,QAAS,QAASgE,QAAS,gBAAgB1E,SAAA,MACvCiH,GAAb7F,GACGnB,EAAAA,EAAAA,KAACiH,EAAAA,EAAO,CAAClG,MAAM,iBAAiBmG,UAAU,SAAQnH,UAC9CC,EAAAA,EAAAA,KAAA,KAAG8C,KAAM3B,EAAW4B,OAAO,SAAQhD,UAC/BC,EAAAA,EAAAA,KAACmH,EAAAA,EAAc,CAAChH,UAAU,mBAGlC,UAEa6G,GAAhBjB,GACG/F,EAAAA,EAAAA,KAACiH,EAAAA,EAAO,CAAClG,MAAM,eAAemG,UAAU,SAAQnH,UAC5CC,EAAAA,EAAAA,KAACoH,EAAAA,GAAI,CAAChD,GAAI4B,EAAMD,EAAahG,UACzBC,EAAAA,EAAAA,KAACqH,EAAAA,EAAY,CAAClH,UAAU,mBAGhC,UAEY6G,GAAf5F,GACGpB,EAAAA,EAAAA,KAACiH,EAAAA,EAAO,CAAClG,MAAM,eAAemG,UAAU,SAAQnH,UAC5CC,EAAAA,EAAAA,KAAA,KAAG8C,KAAM1B,EAAa2B,OAAO,SAAQhD,UACjCC,EAAAA,EAAAA,KAACqH,EAAAA,EAAY,CAAClH,UAAU,mBAGhC,SAGRH,EAAAA,EAAAA,KAACuC,EAAAA,EAAO,CAAC1C,MAAO,CAAC2C,eAAgB,MAAOC,eAAgB,UAAWC,QAAS,UAEhF1C,EAAAA,EAAAA,KAAA,OAAKH,MAAO,CAACoD,OAAQ,cAItB,C,iHCvDX,MAiBMqE,EAAqBC,IAC1B,IAAIC,EAAmBD,EAAgBE,QAAOC,IAC7C,IAAIC,EAAID,EAAEE,SACV,MAAgB,UAATF,EAAErG,KAAyB,OAANsG,GAAoB,OAANA,GAAoB,OAANA,EAAW,IAGpE,IAAIE,GAAM,EACV,IAAIC,EAAaN,EAAiBO,KAAIL,IACrCG,IACQ,CAAEG,IAAI,YAADvB,OAAcoB,GAAM/E,KAAK,IAAD2D,OAAMiB,EAAErG,IAAMN,MAAO2G,EAAEO,UAAWC,MAAOC,SAAST,EAAEE,SAASQ,OAAO,QAEtGC,EAAS,GACZC,EAAU,GACVC,EAAS,CAACF,GAaX,OAXAP,EAAWU,SAAQC,IAClB,IAAIC,EAAQJ,EAAQK,WAAUT,GAASA,GAASO,EAAEP,SACnC,IAAXQ,EACHA,EAAQJ,EAAQM,KAAKH,EAAEP,OAAS,EAEhCI,EAAQO,OAASH,EAAQ,EAE1BH,EAAOG,GAAOE,KAAKE,OAAOC,OAAO,CAAC,EAAGN,EAAG,CAAE1I,SAAUwI,EAAOG,EAAQ,GAAK,KAAM,IAIxEL,CAAM,EAyDd,EAzCwB9I,IAAgB,IAAf,MAAEwB,GAAOxB,EACjC,MAAM,eAAEyJ,GA5DeC,MACvB,MAAOD,EAAgBE,IAAqBC,EAAAA,EAAAA,UAAS,IAarD,OAXAhD,EAAAA,EAAAA,YAAU,KACT,MAAMoB,EAAkB6B,MAAMC,KAC7BC,SAASC,iBAAiB,eAIrBC,EAAoBlC,EAAkBC,GAE5C2B,EAAkBM,EAAkB,GAClC,IAEI,CAAER,iBAAgB,EA8CEC,IACrB,UAAEQ,GAfYC,MACpB,MAAOD,EAAWE,IAAgBR,EAAAA,EAAAA,UAAS,GAS3C,OAPAhD,EAAAA,EAAAA,YAAU,KACT,MAAMyD,EAASN,SAASO,eAAe,eACvCC,QAAQC,IAAIH,GAEZD,EAAaC,EAAOI,aAAa,GAC/B,IAEI,CAAEP,YAAW,EAKEC,IAEfO,EAAcC,IAAmBf,EAAAA,EAAAA,UAAS,QASjD,OAPAhD,EAAAA,EAAAA,YAAU,KACT,MAAMgE,EAAgBb,SAASO,eAAe,kBAC1CM,GACHD,EAAgB,uBAADzD,OAAwB0D,EAAcH,aAAY,OAClE,GACE,KAGFpK,EAAAA,EAAAA,MAAA0G,EAAAA,SAAA,CAAAvG,SAAA,EACCC,EAAAA,EAAAA,KAACoK,EAAAA,EAAU,CAAC/I,GAAG,iBAAiBxB,MAAO,CAACF,cAAe,OAAQG,SAAU,UACxEuK,MAAO,CACN,CACCtJ,OAAOf,EAAAA,EAAAA,KAAA,KAAG8C,KAAK,QAAO/C,SAAC,eAExB,CACCgB,OAAOf,EAAAA,EAAAA,KAAA,KAAG8C,KAAK,YAAW/C,SAAC,cAE5B,CACCgB,MAAM,GAAD0F,OAAK1F,QAIbf,EAAAA,EAAAA,KAACsK,EAAAA,EAAM,CACNzK,MAAO,CAAC0K,UAAWN,EAAcO,SAAU,QAC3CC,aAAchB,EACdiB,QAASA,CAAChD,EAAGC,KAEZD,EAAEiD,gBAAgB,EAEnBN,MAAOrB,MAEN,E,qCCjGL,MAAM,cAAEtI,GAAkBC,EAAAA,GAuC1B,EArCoBpB,IAA6E,IAA5E,MAACwB,EAAK,MAAEE,EAAK,YAAEG,EAAW,aAAE2E,EAAY,UAAE5E,EAAS,OAAEyJ,EAAM,SAAE7K,GAASR,EACvF,MAAMsB,EAAUH,IAEhB,OAEIV,EAAAA,EAAAA,KAAAsG,EAAAA,SAAA,CAAAvG,UACAH,EAAAA,EAAAA,MAACiL,IAAM,CAAA9K,SAAA,EACHC,EAAAA,EAAAA,KAAC8K,EAAAA,EAAY,CACT/J,MAAOA,EACPE,MAAOA,EACP8E,aAAcA,EACd3E,YAAaA,EACbD,UAAWA,KACfvB,EAAAA,EAAAA,MAAC4E,EAAAA,EAAG,CAACuG,OAAQ,EAAEhL,SAAA,EACfC,EAAAA,EAAAA,KAAC0E,EAAAA,EAAG,CAACsG,GAAI,EAAGC,GAAI,EAAElL,UAClBC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,sBAAqBJ,UAChCC,EAAAA,EAAAA,KAACkL,EAAe,CAACnK,MAAOA,SAG5BnB,EAAAA,EAAAA,MAAC8E,EAAAA,EAAG,CAACsG,GAAI,GAAIC,GAAI,GAAGlL,SAAA,EACpBC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,0BAA0BN,MAAO,CAACsL,YAAatK,EAAQoK,GAAI,SAAW,MAAOG,WAAYvK,EAAQoK,GAAI,EAAI,OAAOlL,SAC1HA,KAELC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,yBAAyBN,MAAO,CAC3C4E,QAAS,OAAQ4G,eAAgB,SACjC9E,UAAW,MAAO+E,aAAc,MAChCH,YAAatK,EAAQoK,GAAI,SAAW,MAAOG,WAAYvK,EAAQoK,GAAI,EAAI,OACrElL,SACD6K,EAAS,CAACA,UAAU,4DAK1B,C,6DCVAW,EAAW,WAQlB,OAPAA,EAAWzC,OAAOC,QAAU,SAAkByC,GAC1C,IAAK,IAAIC,EAAGC,EAAI,EAAGC,EAAIC,UAAU/C,OAAQ6C,EAAIC,EAAGD,IAE5C,IAAK,IAAIG,KADTJ,EAAIG,UAAUF,GACO5C,OAAOgD,UAAUC,eAAeC,KAAKP,EAAGI,KAAIL,EAAEK,GAAKJ,EAAEI,IAE9E,OAAOL,CACf,EACWD,EAASU,MAAMC,KAAMN,UAChC,EClCA,IAAIO,EAAe,GACfC,EAAW,KACXC,EAAe,KACfC,EAAiB,KAErB,SAASC,IACPJ,EAAe,GACE,OAAbC,GAAmBA,EAASI,aACX,OAAjBH,IACFjG,OAAOqG,aAAaJ,GACpBA,EAAe,KAEnB,CAEA,SAASK,EAAqBC,GAG5B,MAFiB,CAAC,SAAU,QAAS,SAAU,YAGnCC,SAASD,EAAQE,WAAaF,EAAQG,aAAa,aAF9C,CAAC,IAAK,QAGXF,SAASD,EAAQE,UAAYF,EAAQG,aAAa,OAEhE,CAEA,SAASC,IACP,IAAIJ,EAAU,KACd,GAAqB,MAAjBR,EAKFQ,EAAUrD,SAAS0D,SACd,CAGL,IAAM3L,EAAK8K,EAAac,QAAQ,IAAK,IAErB,QADhBN,EAAUrD,SAASO,eAAexI,KACO,SAAjB8K,IAEtBQ,EAAUrD,SAAS0D,K,CAIvB,GAAgB,OAAZL,EAAkB,CACpBL,EAAeK,GAIf,IAAIO,EAAmBP,EAAQQ,aAAa,YAc5C,OAbyB,OAArBD,GAA8BR,EAAqBC,IACrDA,EAAQS,aAAa,YAAa,GAEpCT,EAAQU,MAAM,CAAEC,eAAe,IACN,OAArBJ,GAA8BR,EAAqBC,KAIrDA,EAAQY,OACRZ,EAAQa,gBAAgB,aAG1BjB,KACO,C,CAET,OAAO,CACT,C,SAsBgBkB,EAAgBC,GAC9B,OAAOC,EAAAA,YAAiB,SAACjO,EAAOkO,GAC9B,IAAIC,EAAW,GACS,kBAAbnO,EAAM0E,IAAmB1E,EAAM0E,GAAGwI,SAAS,KACpDiB,EAAW,IAAInO,EAAM0E,GAAG0J,MAAM,KAAK1F,MAAM,GAAG2F,KAAK,KAE7B,kBAAbrO,EAAM0E,IACY,kBAAlB1E,EAAM0E,GAAG4J,OAEhBH,EAAWnO,EAAM0E,GAAG4J,MAGtB,IAAMC,EAAgB,CAAC,EACnBP,IAAOQ,EAAAA,KACTD,EAAcE,SAAW,SAACC,EAAOC,GAC/B,OAAAD,GAASA,EAAME,SAAWD,EAASL,OAASH,C,OAyBDU,ED1F5C,SAAgB9C,EAAG/D,GACtB,IAAI8D,EAAI,CAAC,EACT,IAAK,IAAIK,KAAKJ,EAAO3C,OAAOgD,UAAUC,eAAeC,KAAKP,EAAGI,IAAMnE,EAAE8G,QAAQ3C,GAAK,IAC9EL,EAAEK,GAAKJ,EAAEI,IACb,GAAS,MAALJ,GAAqD,oBAAjC3C,OAAO2F,sBACtB,KAAI/C,EAAI,EAAb,IAAgBG,EAAI/C,OAAO2F,sBAAsBhD,GAAIC,EAAIG,EAAEhD,OAAQ6C,IAC3DhE,EAAE8G,QAAQ3C,EAAEH,IAAM,GAAK5C,OAAOgD,UAAU4C,qBAAqB1C,KAAKP,EAAGI,EAAEH,MACvEF,EAAEK,EAAEH,IAAMD,EAAEI,EAAEH,IAF4B,CAItD,OAAOF,CACX,CCgFgEmD,CAAKjP,EAA3D,2CACN,OACEiO,EAAAA,cAACD,EAAEnC,EAAA,GAAK0C,EAAmBM,EAAa,CAAE7D,QAxB5C,SAAqBhD,GAtCzB,IAAwBkH,EAuClBrC,IACAJ,EAAezM,EAAMmP,UAAY,IAAInP,EAAMmP,UAAchB,EACrDnO,EAAMgL,SAAShL,EAAMgL,QAAQhD,GAEd,KAAjByE,GAGCzE,EAAEoH,kBACU,IAAbpH,EAAEqH,QACArP,EAAMqD,QAA2B,UAAjBrD,EAAMqD,QACtB2E,EAAEsH,SAAWtH,EAAEuH,QAAUvH,EAAEwH,SAAWxH,EAAEyH,WAE1C7C,EACE5M,EAAM0P,QACL,SAACC,GACA,OAAA3P,EAAMyE,OACFkL,EAAGC,eAAe,CAAEC,SAAU,WAC9BF,EAAGC,gB,EAxDKV,EAyDDlP,EAAMkP,QAvD3BxI,OAAOoJ,YAAW,YACS,IAArBzC,MACe,OAAbX,IACFA,EAAW,IAAIqD,iBAAiB1C,IAElCX,EAASsD,QAAQpG,SAAU,CACzBqG,YAAY,EACZC,WAAW,EACXC,SAAS,IAGXxD,EAAejG,OAAOoJ,YAAW,WAC/BjD,G,GACCqC,GAAW,K,GAEf,G,EA6CiEhB,IAAKA,IAClElO,EAAMK,S,GAIf,C,IAEamE,EAAWuJ,EAAgBrG,EAAAA,IAEbqG,EAAgBS,EAAAA,G","sources":["projects/annotatedVideo.jsx","projects/Shimenawa/home.jsx","projects/annotatedImage.jsx","projects/homeTemplate.jsx","projects/tableofcontents.jsx","projects/projectPage.jsx","../node_modules/react-router-hash-link/node_modules/tslib/tslib.es6.js","../node_modules/react-router-hash-link/src/HashLink.jsx"],"sourcesContent":["import React from 'react'\r\n\r\nconst AnnotatedVideo = ({annotation, fontSize, ...props}) => {\r\n\r\n    const paddingBottom = props.paddingBottom ? props.paddingBottom : \"20px\"\r\n\r\n    return (\r\n        \r\n        <div style={{position: \"relative\"}}>\r\n            <video {...props}>\r\n                <source src={props.src} type='video/webm' />\r\n            </video>\r\n            {annotation ? (\r\n                <div className=\"styled-text\" style={{\r\n                    position: \"absolute\", \r\n                    bottom: 0, \r\n                    left: 0, \r\n                    backgroundColor: 'rgba(21, 25, 31, 0.65)',\r\n                    width: \"100%\", \r\n                    fontSize: fontSize && fontSize,\r\n                    textAlign: 'center',\r\n                    padding: \"10px 5px\",\r\n                    paddingBottom: paddingBottom\r\n                }}>\r\n                    {annotation}\r\n                </div>\r\n            ) : null}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default AnnotatedVideo;","import React from 'react';\r\nimport { HashLink } from 'react-router-hash-link';\r\nimport { Row, Col, Divider, Image, Carousel, Grid } from 'antd';\r\n\r\nimport shimenawa from '../../content/projects/Shimenawa/Shimenawa_Night_1080p.mp4'\r\nimport day from '../../content/projects/Shimenawa/day_thumb.png'\r\nimport sunset from '../../content/projects/Shimenawa/sunset_thumb.png'\r\nimport night from '../../content/projects/Shimenawa/night_thumb.png'\r\n\r\nimport meiji from '../../content/projects/Shimenawa/reference_photos/meiji.JPG'\r\nimport sakurayama from '../../content/projects/Shimenawa/reference_photos/sakurayama.JPG'\r\nimport unknownTakayama from '../../content/projects/Shimenawa/reference_photos/unknown_takayama.JPG'\r\nimport fushimiInari1 from '../../content/projects/Shimenawa/reference_photos/fushimi_inari_1.JPG'\r\nimport fushimiInari2 from '../../content/projects/Shimenawa/reference_photos/fushimi_inari_2.JPG'\r\n\r\nimport depthMap from '../../content/projects/Shimenawa/depth_map.png'\r\nimport domainWarp from '../../content/projects/Shimenawa/domain_warp.webm'\r\nimport ropeSdfWarp from '../../content/projects/Shimenawa/rope_sdf_warping.png'\r\nimport ropeSdf0Coil from '../../content/projects/Shimenawa/rope_sdf_no_coil.png'\r\nimport ropeSdf1Coil from '../../content/projects/Shimenawa/rope_sdf_one_coil.png'\r\nimport ropeSdf2Coil from '../../content/projects/Shimenawa/rope_sdf_two_coil.png'\r\nimport ropeSdfComplete from '../../content/projects/Shimenawa/rope_sdf_complete.png'\r\nimport ropeOvershoot from '../../content/projects/Shimenawa/overshooting.png'\r\nimport ropeNormals from '../../content/projects/Shimenawa/normals.png'\r\n\r\nimport sphereDomainRep from '../../content/projects/Shimenawa/sphere_domain_rep.png'\r\nimport sphereDomainRepRad from '../../content/projects/Shimenawa/sphere_domain_rep_rad.png'\r\nimport domainRepShimenawa from '../../content/projects/Shimenawa/domain_rep_shimenawa.png'\r\nimport domainRepBridges from '../../content/projects/Shimenawa/domain_rep_bridges.png'\r\nimport domainRepPillars from '../../content/projects/Shimenawa/domain_rep_pillars.png'\r\n\r\nimport hardShadows from '../../content/projects/Shimenawa/hard_shadows.png'\r\nimport softShadows from '../../content/projects/Shimenawa/soft_shadows.png'\r\nimport noAO from '../../content/projects/Shimenawa/no-ao.png'\r\nimport noAOlambertian from '../../content/projects/Shimenawa/no-ao-lambertian.png'\r\nimport aoLambertian from '../../content/projects/Shimenawa/ao-lambertian.png'\r\n\r\nimport shadowColMult from '../../content/projects/Shimenawa/shadow_col_mult.png'\r\nimport shadowColConstMix from '../../content/projects/Shimenawa/shadow_col_const_mix.png'\r\nimport shadowColAmbientMix from '../../content/projects/Shimenawa/shadow_col_ambient_mix.png'\r\nimport shadowRamped from '../../content/projects/Shimenawa/shadow_col_ramped.png'\r\nimport shadowRampedBright from '../../content/projects/Shimenawa/shadow_col_ramped_extra_bright.png'\r\n\r\nimport 'katex/dist/katex.min.css'\r\nimport Latex from 'react-latex-next';\r\n\r\nimport SyntaxHighlighter from 'react-syntax-highlighter';\r\nimport { dracula } from 'react-syntax-highlighter/dist/esm/styles/hljs';\r\n\r\nimport {Meta} from '.';\r\nimport ProjectPage from '../projectPage';\r\nimport AnnotatedImage from '../annotatedImage';\r\nimport AnnotatedVideo from '../annotatedVideo';\r\n\r\nconst { useBreakpoint } = Grid;\r\n\r\nconst Home = () => {\r\n    const screens = useBreakpoint();\r\n\r\n    return (\r\n    \r\n        <ProjectPage title={Meta.title} thumb={Meta.teaser} githubURL={\"https://github.com/Skittss/Shimenawa\"} projectLink={\"https://www.shadertoy.com/view/clVyzW\"}>\r\n            <h1 id=\"overview\" className=\"raleway-title\">\r\n                Overview\r\n            </h1>\r\n            <div style={{paddingBottom: \"20px\", textAlign: \"center\"}}>\r\n                <video style={{objectFit: \"cover\", width: \"100%\"}}  autoPlay loop muted>\r\n                    <source src={shimenawa} type='video/mp4' />\r\n                </video>\r\n            </div>\r\n            <p>\r\n            'Shimenawa' is a non-photorealistically-rendered scene utilising ray marching to render complex implicit geometry and volumetrics.\r\n            This means that everything you are looking at above is defined mathematically, and completely procedural!\r\n            </p>\r\n            <p>\r\n            Shimenawa ( 注&#8288;連&#8288;縄 ) - lit. \"enclosing rope\", is the main subject of the scene. The inspiration came to me following a recent\r\n            trip to Japan where I was enamoured with the elegant aesthetic of cultural sites (神&#8288;社 - Shinto shrines), in which this rope - used as a talisman to ward against evil -\r\n            is abundant. \r\n            </p>\r\n            <br/>\r\n            <Carousel autoplay autoplaySpeed={5000} effect=\"fade\" style={{margin: \"0 auto\", paddingBottom: \"20px\", width: \"100%\", maxWidth: \"500px\"}}>\r\n                <AnnotatedImage src={meiji} annotation={\"Shimenawa at Meiji Shrine, Tokyo (\\u00a0明\\u2060治\\u2060神\\u2060宫、東\\u2060京\\u00a0)\"}/>\r\n                <AnnotatedImage src={sakurayama} annotation={\"Shimenawa at Sakurayama Hachimingu Shrine, Takayama (\\u00a0櫻\\u2060山八\\u2060幡\\u2060宮、高\\u2060山\\u00a0)\"}/>\r\n                <AnnotatedImage src={unknownTakayama} annotation={\"Shimenawa and Colourful braided rope at an unknown shrine in Takayama (\\u00a0不明の神社、高\\u2060山\\u00a0)\"} />\r\n                <AnnotatedImage src={fushimiInari1} annotation={\"Shimenawa at Fushimi Inari, Kyoto (\\u00a0伏\\u2060見\\u2060稲\\u2060荷大\\u2060社、京\\u2060都\\u00a0)\"} />\r\n                <AnnotatedImage src={fushimiInari2} annotation={\"More shimenawa at Fushimi Inari, Kyoto (\\u00a0伏\\u2060見\\u2060稲\\u2060荷大\\u2060社、京\\u2060都\\u00a0)\"} />\r\n            </Carousel>\r\n            <br/>\r\n            <p>\r\n            The design of Shimenawa ropes varies by geographical region, and so I used the above photos I took as reference when designing it for the scene.\r\n            </p>\r\n            <p>\r\n            The surrounding environment draws inspiration from Genshin Impact's main menu and 'slumbering court' locale for their wonderful stylised environment design.\r\n            </p>\r\n            <br />\r\n            <Divider style={{borderTopWidth: \"1px\", borderTopColor: \"#000000\", opacity: 0.5}}/>\r\n            <h1 id=\"renders\" className=\"raleway-title\">\r\n                Renders\r\n            </h1>\r\n            <Carousel autoplay autoplaySpeed={5000} effect=\"fade\" style={{margin: \"0 auto\", paddingBottom: \"20px\", width: \"100%\"}}>\r\n                <AnnotatedImage src={day} annotation={\"Day\"}/>\r\n                <AnnotatedImage src={sunset} annotation={\"Sunset\"}/>\r\n                <AnnotatedImage src={night} annotation={\"Night\"} />\r\n            </Carousel>\r\n            To see the full shader in action, visit it on shadertoy <a href={\"https://www.shadertoy.com/view/clVyzW\"} target='_blank'>here</a>, or through this embed (if your browser can load it, compile time is quite long):\r\n            <br/><br/>\r\n            <div style={{width: \"100%\", maxWidth: \"540px\", margin: \"0 auto\", aspectRatio: \"3/2\"}}>\r\n                <iframe width=\"100%\" height=\"100%\" frameborder=\"0\" src=\"https://www.shadertoy.com/embed/clVyzW?gui=true&t=10&paused=true&muted=false\" allowfullscreen></iframe>\r\n            </div>\r\n            <br />\r\n            <Divider style={{borderTopWidth: \"1px\", borderTopColor: \"#000000\", opacity: 0.5}}/>\r\n            <h1 id=\"techniques\" className=\"raleway-title\">\r\n                Techniques\r\n            </h1>\r\n            <br/>\r\n            <h2 id=\"ray-marching\" className=\"raleway-title\">\r\n                Ray Marching\r\n            </h2>\r\n            <p>\r\n                The algorithm at the core of this shader is sphere tracing, a simple yet versatile method when combined with Signed Distance Functions (SDFs). SDFs will be touched\r\n                on more later, but the idea is to genereate a camera ray, then render implicit geometry (i.e. a function <Latex>{`$f(x,y,z)=0$`}</Latex> at an object's surface) by leaping forward in space repeatedly until \r\n                we are close enough to the surface to say that it has been hit (i.e. below some epsilon bound). This then generates a t-value for the camera ray much like ray-tracing, but we have \r\n                done so in an approximate, non-analytical manner.\r\n            </p>\r\n            <p>\r\n                The amount we leap forward in space should be proportional to the distance to the implicit surface to avoid overshooting. Luckily for us, SDFs are defined exactly as this distance, so naturally the following algorithm follows:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n                    `\r\n#define MAX_STEPS 128\r\n#define EPSILON 0.001\r\nvoid mainImage(out vec4 fragColror, in vec2 fragCoord) {\r\n    vec3 ro = vec3(0.0); // camera origin\r\n    vec2 rd = getCameraRay(fragCoord);\r\n    \r\n    float t = 0.0;\r\n    for (int i=0; i<MAX_STEPS; i++) {\r\n        vec3 p = ro + t * rd; // a point along the ray\r\n        float d = map(p); // dist to surface\r\n        if (d < EPSILON) break;\r\n        t += d;\r\n    }\r\n\r\n    // We now have a t-value which allows us to render a basic image...\r\n    //   such as plot a depth-map, or do painter's algorithm, etc.\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <p>\r\n                We will add complexity to this later, but even with this, we can already begin to render the geometry of our scene (by defining the map() function) with very little rendering code!\r\n            </p>\r\n            <AnnotatedImage src={depthMap} annotation={\"Depth map of scene rendered only with the above rendering code as a basis\"} />\r\n            <br/><br/>\r\n            <h2 id=\"sdf\" className=\"raleway-title\">\r\n                Signed Distance functions (SDFs)\r\n            </h2>\r\n            <p>\r\n                Signed distance functions define the distance to an implicit surface given a point in space. This can be an exact distance, or approximate, and is derived geometrically.\r\n                The function will be zero-valued at the surface, positive when outside the surface, and negative inside.\r\n            </p>\r\n            <p>\r\n                Deriving SDFs can be challenging when they get complex, so generally we stick to using 'primitives' - simple yet powerful SDFs which we can combine together and distort to make\r\n                any manner of shape we desire. <a href=\"http://iquilezles.org/articles/distfunctions/\">Inigo Quilez has an invaluable resource for definitions of many primitives</a>, as well as a more thorough explanation of SDFs in general.\r\n                I thoroughly recommend you take a look. To get a basic idea however, we can very simply define the SDF for a sphere by observing that the closest point to the sphere lies along\r\n                the vector from the point in space to the sphere origin, i.e:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n                    `\r\nfloat sdSphere(in vec3 p, float r) {\r\n    return length(p) - r;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <p>\r\n                The following shader showcases a range of primitives that have reasonably mathematically simple definitions and can be used to construct more complex shapes\r\n                via elementary set operations. \r\n            </p>\r\n            <div style={{width: \"100%\", maxWidth: \"540px\", margin: \"0 auto\", aspectRatio: \"3/2\"}}>\r\n                <iframe width=\"100%\" height=\"100%\" frameborder=\"0\" src=\"https://www.shadertoy.com/embed/Xds3zN?gui=true&t=10&paused=true&muted=false\" allowfullscreen></iframe>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                The most simple operation we can define (and will make much use of) is the <b>union</b> of two SDFs: simply <Latex>{`$U(p)=\\\\text{min}(SDF_1(p), SDF_2(p))$`}</Latex>.\r\n            </p>\r\n            <br/>\r\n            <h3 id=\"domain-transform\" className=\"raleway-title\">\r\n                Simple Domain Transformations\r\n            </h3>\r\n            <p>\r\n                You might have noticed with the sphere SDF code above that we never make a reference to the origin of the sphere. What's up with that? Surely we could only position objects at (0, 0, 0) if \r\n                we defined them all like this?\r\n            </p>\r\n            <p>\r\n                And that is correct! ...At least until we employ domain transformations.\r\n            </p>\r\n            <p>\r\n                Domain transformations change the input space of our function, and not the function itself. For example, we can shift <i>all</i> input points by an offset <i>before</i> we evaluate\r\n                the SDF to position it away from the origin. In turn we should note that we <b>always evaluate an SDF as if it is centered at the origin for simplicity</b>. \r\n            </p>\r\n            <p>\r\n                This has some bearing on what transformation we should apply;\r\n                if we want to shift a SDF in the <b>positive</b> direction of the x axis for example, we should apply a <b>negative</b> x transformation on the input space. This is because our SDF is <b>still evaluated at the origin</b>, albeit in our new coordinate space.\r\n            </p>\r\n            <p>\r\n\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n                    `\r\nfloat map(in vec3 p) {\r\n    vec3 q = p - vec3(2.0, 0.0, 0.0); // q is our new coordinate space\r\n    // Note that we want the new origin to be at p=(2.0, 0.0, 0.0), so we should *subtract*\r\n    // so that is (0.0, 0.0, 0.0) at that point.\r\n\r\n    float d = sdSphere(q, 1.0);\r\n\r\n    return d;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <p>\r\n                The most useful transformation we can apply besides a domain shift is a domain rotation, which we should also quickly define. \r\n                It is achieved the exact same way as a domain shift except with a rotation matrix applied instead of a simple vector subtraction:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n                    `\r\n#define PI 3.1415926\r\n\r\nmat2 rot(in float a) { \r\n    float c = cos(a); float s = sin(a); \r\n    return mat2(c, s, -s, c); \r\n}\r\n\r\nfloat map(in vec3 p) {\r\n    vec3 q = p*rot(PI/2.0); // rotation in radians\r\n    float d = sdSphere(q, 1.0);\r\n\r\n    return d;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <br/>\r\n            <h3 id=\"warping\" className=\"raleway-title\">\r\n                Domain Warping\r\n            </h3>\r\n            <p>\r\n                We may wish to do a more complex transformation than a simple linear transformation of our input space. This is the role domain warping plays.\r\n                Warping falls under the same umbrella as domain transformations, but we are specifically performing non-linear space transformations here.\r\n            </p>\r\n            <p>\r\n                Warping is particularly useful when we want to add extra detail to an SDF without having to do a bunch of extra SDF calculations. Piling on many SDF calls is \r\n                undesirable as it is the most expensive function in a complex scene.\r\n                Instead we perturb the input space in clever ways to mimic a fine level of detail.\r\n            </p>\r\n            <p>\r\n                In this scene, I mainly use domain warping for two things: construction of the rope SDF, and object animation.\r\n            </p>\r\n            <br/>\r\n            <p>\r\n                Animation is fairly straight forward; we can create simple procedural animations by perturbing based on a time factor. Even better - slap the perturbation\r\n                into a periodic function like sin or cosine, and you have a perfect loop with little effort! The animation below is a simple time-based and periodic \r\n                radial peturbation of the y coordinate space.\r\n            </p>\r\n            <AnnotatedVideo \r\n                annotation={\"Exaggerated domain warping applied for animation of the rope (注連縄) and wind on the paper (紙垂)\"}\r\n                src={domainWarp} \r\n                style={{objectFit: \"cover\", width: \"100%\"}}  \r\n                autoPlay loop muted\r\n            />\r\n            <br/><br/>\r\n            <p>\r\n                Next let's look at the rope SDF itself.\r\n            </p>\r\n            <AnnotatedImage src={ropeSdfWarp} annotation={\"Shimenawa SDF (with materials & lighting applied)\"}/>\r\n            <br/>\r\n            <p>\r\n                Though this SDF looks complicated, it is in fact a rather simple construction! The reality is that it is actually just two simple cylindrical capsules rotated and bent\r\n                around a circle. Let's have a look at each step:\r\n            </p>\r\n            <Carousel autoplay autoplaySpeed={5000} effect=\"fade\" style={{margin: \"0 auto\", paddingBottom: \"20px\", width: \"100%\"}}>\r\n                <AnnotatedImage src={ropeSdf0Coil} annotation={\"Start with a simple capsule lying on the x-axis\"}/>\r\n                <AnnotatedImage src={ropeSdf1Coil} annotation={\"Offset rotation dependent on the x-axis coordinate\"}/>\r\n                <AnnotatedImage src={ropeSdf2Coil} annotation={\"Duplicate the coil and mirror in xz plane (vertically, though really just orthogonal to the rotation offset)\"} />\r\n                <AnnotatedImage src={ropeSdfComplete} annotation={\"Loop into a torus shape\"} />\r\n            </Carousel>\r\n            <p>\r\n                Simple enough once it's broken down, right? Though this is conceptually easy to understand, how do we technically and mathematically implement each step above?\r\n            </p>\r\n            <br/>\r\n            <p>\r\n                <b><u>1. x-axis aligned capsule</u></b>\r\n                <br/><br/>\r\n                This is self explanatory once you have the SDF for a capsule, which can be thought of as the SDF of an elongated sphere:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n                    `\r\nfloat sdCapsule(vec3 p, float r, float h) {\r\n    p.x -= clamp(p.x, 0.0, h);\r\n    return length(p) - r;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                <b><u>2. Offset rotation dependent on the x-coordinate</u></b>\r\n                <br/><br/>\r\n                The aim of this step is to set up the repeating braided structure of the rope. If you were to make such a rope in real life, you\r\n                would braid it by twisting coils around one another - so let's take inspiration and do exactly that with maths!\r\n            </p>\r\n            <p>\r\n                'twisting' is simply rotation where we rotate more and more as we go further down the rope. This is where the x-coordinate of the capsule comes in. It corresponds to how\r\n                much rotation we should do at each point. We must also <i>offset</i> the rotation, or else we will rotate the capsule in-place (it is rotationally symmetrical) and percieve no difference.\r\n                Let's start with that:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n                    `\r\nfloat sdRopeCoil(vec3 p, in float braid_r, in float l, in float rot_freq, in float rot_offset)\r\n{\r\n    // Rotate and twist a capsule to make the rope along the x axis\r\n    p.yz *= rot(p.x * PI * rot_freq); // twisting; 45-deg per x\r\n    p.y -= rot_offset; // offset for rotation\r\n    float d = sdVerticalCapsule(p, braid_r, l);\r\n\r\n    return d;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <p>\r\n                Note that we rotate in the yz plane as it is orthogonal to the x-axis which the rope lies upon.\r\n            </p>\r\n            <br/>\r\n            <p>\r\n                <b><u>3. Duplicating the coil</u></b>\r\n                <br/><br/>\r\n                At this stage, the rope lacks a second coil and thus the volume and physicality of an actual rope. There are computationally efficient ways to\r\n                duplicate our SDFs (<HashLink smooth to=\"#repetition\">Domain Repetition</HashLink>), but for now let's keep it simple and just evaluate the SDF twice:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n                    `\r\nfloat sdRope(vec3 p, in float braid_r, in float l, in float rot_freq, in float rot_offset)\r\n{\r\n    float d = 1e10; // initialise distance;\r\n    d = min(d, sdRopeCoil(p, braid_r, l, rot_freq,  rot_offset)); // Top coil\r\n    d = min(d, sdRopeCoil(p, braid_r, l, rot_freq, -rot_offset)); // Bot coil\r\n\r\n    return d;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <p>\r\n                Now we have something that distinctly looks like rope, which we can then loop to get the desired effect.\r\n            </p>\r\n            <br/>\r\n            <p>\r\n                <b><u>4. Looping into a torus</u></b>\r\n                <br/><br/>\r\n                Looping the straight coil into a torus shape can be done in a few ways, but my approach was to use a special kind of domain transformation involving conversion \r\n                between two local coordinate spaces.\r\n            </p>\r\n            <h3 id=\"local-uvs\" className=\"raleway-title\">\r\n                Imposing SDFs with local UVs\r\n            </h3>\r\n            <p>\r\n                By converting between coordinate spaces, we can impose one shape onto another. The following demo shows this technique in 2D with an arrow SDF imposed\r\n                onto that of a circle. This is the same effect that we want to create for the rope, but in 2d.\r\n            </p>\r\n            <div style={{width: \"100%\", maxWidth: \"540px\", margin: \"0 auto\", aspectRatio: \"3/2\"}}>\r\n                <iframe width=\"100%\" height=\"100%\" frameborder=\"0\" src=\"https://www.shadertoy.com/embed/mtGcDz?gui=true&t=10&paused=true&muted=false\" allowfullscreen></iframe>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                For our purposes, transforming the SDF around one base axis is sufficient. This same technique is extensible to any transformation, but let's keep it simple for now.\r\n            </p>\r\n            <p>\r\n                For the rope coils (or in the above demo, the arrow), the base axis is simply\r\n                the axis which the SDF lies along, in this case x. For the circle, we can view the base axis as lying along the circumference of the circle. \r\n                Keeping track of the distance along the circumference will thus give us this axis coordinate (t), so let's make that SDF quickly:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n`\r\nfloat sdCircle(in vec2 p, in float r, out float t) \r\n{\r\n    // angle to closest pt in range [-PI, PI]\r\n    float closest_p_theta = atan(p.y, p.x) + PI;\r\n    t = closest_p_theta / (2.0 * PI); // convert to range [0, 1]\r\n    \r\n    return length(p) - r;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <p>\r\n                Now that we have a mapping between the coordinates of the base axis, let's think about how we convert between the other (orthogonal) axis.\r\n            </p>\r\n            <p>\r\n                For the SDF we are imposing onto the circle, this axis is unchanged. In our 2D example it is simply the y axis. For the circle itself, this axis changes \r\n                radially, and is in fact given by the distance to the circle, which is the result of the SDF! This property also generalises to the local coordinate space of any SDF if you think\r\n                about it.\r\n            </p>\r\n            <p>\r\n                Now we have a basic example for imposing SDFs onto one another:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n`\r\nfloat sdImpose(in vec2 p, in float r)\r\n{\r\n    float rt = 0.0f;\r\n\tfloat d = sdCircle(p, r, rt);\r\n\r\n    // adjust 0 -> 1 t-value to actual circumference of the circle\r\n    vec2 segUV = vec2(rt * 2.0*PI*r, d); // calculate local uv\r\n    d = sdArrow(segUV, ...arrow params); // Arrow lying on x-axis\r\n\r\n    return d;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                Next is applying this to our 3D example. The problem actually remains unchanged as the circle we want to impose the rope onto still lies on a 2D plane. \r\n                Our third axis (y) remains constant between our coordinate spaces, so we only have to make slight modifications for it to work in 3D:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n`\r\nfloat sdRope(vec3 p, in float braid_r, in float l) {\r\n    float rt = 0.0;\r\n    float d = sdCircle(p.xz, r, rt);\r\n    float circum = 2.0*PI*r;\r\n    \r\n    vec3 ring_uvw = vec3(rt * circum, p.y, d);\r\n    d = sdRope(ring_uvw, r, circum, 10.0, 0.02);\r\n\r\n    return d;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <br/>\r\n            <h3 id=\"overshooting\" className=\"raleway-title\">\r\n                Overshooting in Warping\r\n            </h3>\r\n            <p>\r\n                If you implement the code above, you might notice that it doesn't quite look right. Certain parts of the object may appear to clip into nothingness - what's happening here?\r\n            </p>\r\n            <AnnotatedImage src={ropeOvershoot} annotation={\"What's happening to my SDF?!\"}/>\r\n            <br/>\r\n            <p>\r\n                Let's look at what happens to our SDF when we warp the domain to see what's going on:\r\n            </p>\r\n            <div style={{width: \"100%\", maxWidth: \"540px\", margin: \"0 auto\", aspectRatio: \"3/2\"}}>\r\n                <iframe width=\"100%\" height=\"100%\" frameborder=\"0\" src=\"https://www.shadertoy.com/embed/4fSXDV?gui=true&t=10&paused=true&muted=false\" allowfullscreen></iframe>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                We can see that in some cases (the peaks of the sin wave) the warped SDF ends up closer to the sample point than our distance describes. The result \r\n                when we apply this to ray marching is <i>overshooting</i> - we end up missing the surface entirely because we have <b>overestimated the distance</b> to it.\r\n            </p>\r\n            <p>\r\n                The simplest solution to overshooting is to simply multiply the SDF distance by a constant factor:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n`\r\nfloat sdRope(vec3 p, in float braid_r, in float l) {\r\n    ...\r\n\r\n    d *= 0.8; // const for fixing overshooting\r\n    return d;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <p>\r\n                This ensures our distance is conservative so no overshooting can occur. The exact factor you need to use depends on how extreme the warp is.\r\n            </p>\r\n            <p>\r\n                We must be mindful of the effect this has on performance, however. Underestimating the distance to an object will make us perform more raymarching steps\r\n                than normal when we render it. For example, if we approximate the distance as half of what it should be, we will end up reaching the surface in twice the amount of raymarching steps.\r\n                This solves the overshooting problem, but this 2x operation multiplier can slow the program down and be the difference between a useable one, and an unusable one in the context of real-time rendering.\r\n            </p>\r\n            <p>\r\n                Therefore, we should keep this constant <b>as large as possible</b> and <b>apply it on an individual basis to only warped objects which have overshooting problems</b>, not the entire raymarching loop.\r\n            </p>\r\n            <p>\r\n                Additionally, a lot of the time overshooting problems will be unnoticeable or nonexistant if the warp is small, so we should use this fix with prudence.\r\n            </p>\r\n            <br/>\r\n            <h3 id=\"repetition\" className=\"raleway-title\">\r\n                Domain Repetition and Scaling Scenes\r\n            </h3>\r\n            <p>\r\n                We now have a way to modify basic primitives with transformations and warping, and are able to fix them when they break.\r\n            </p>\r\n            <p>\r\n                This is great - we can start to make some more complex scenes with lots of geometry by re-calling our SDF functions at different points in space and performing a union with <Latex>{`$\\\\min()$`}</Latex>. However, when we do this, we will quickly notice that it runs quite poorly.\r\n                The reasons for this are at least twofold:\r\n            </p>\r\n            <div style={{paddingLeft: \"2vw\", paddingRight: \"2vw\"}}>\r\n                <Row className=\"project-style-cont\" style={{display: \"flex\"}}>\r\n                    <Col className=\"project-style-cont\"><b>1. </b> &nbsp;&nbsp;&nbsp;</Col>\r\n                    <Col className=\"project-style-cont\" flex=\"1vw\">\r\n                        Our scene <Latex>{`$\\\\text{map}()$`}</Latex> function becomes overly coupled between lots of unrelated geometry.\r\n                    </Col>\r\n                </Row>\r\n                <br/>\r\n                <Row className=\"project-style-cont\" style={{display: \"flex\"}}>\r\n                    <Col className=\"project-style-cont\"><b>2. </b> &nbsp;&nbsp;&nbsp;</Col>\r\n                    <Col className=\"project-style-cont\" flex=\"1vw\">\r\n                        Lots of repeated calls to the same expensive SDF function.\r\n                    </Col>\r\n                </Row>\r\n                <br/>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                First, let's address 1. What do I mean by this?\r\n            </p>\r\n            <p>\r\n                When we lump all of our scene geometry into one big SDF - <Latex>{`$\\\\text{map}()$`}</Latex>, we are forced into evaluating the SDF for our entire scene even when we are only considering\r\n                calculations for a single object. This is especially notable when we add expensive lighting calculations into the mix (as we will encounter in the next couple of sections). \r\n            </p>\r\n            <p>\r\n                Think about casting shadows on objects for example; we currently would be forced to evaluate the effect of <i>all</i> objects casting a shadow on the object we're actually\r\n                considering at a point <Latex>{`$p$`}</Latex>. While this is an accurate calculation, it is undoubtedly slow - the complexity of lighting our scene will scale polynomially with\r\n                respect to the number of objects in it. \r\n            </p>\r\n            <p>       \r\n                Instead, if we know that certain objects can <i>never interact</i>, or the effect of this being the case is unnoticeable, we should separate them\r\n                into different functions so we have more control over what SDFs we evaluate for certain calculations. This in turn allows us to scale up our scene without hemorrhaging performance.\r\n            </p>\r\n            <p>\r\n                A simple separation we can make is between <b>background and foreground</b>. We can get away with having less detail in a background, so it makes sense to not couple it with calculations for the \r\n                foreground, which tend to be much more expensive. \r\n            </p>\r\n            <p>\r\n                If you look at the code for Shimenawa, I split the SDFs, normal and lighting calculations, and even the raymarching itself into\r\n                separate <Latex>{`$\\\\text{...Foreground}()$`}</Latex> and <Latex>{`$\\\\text{...Background}()$`}</Latex> functions to save on performance.\r\n            </p>\r\n            <br/>\r\n            <p>\r\n                We've now found a better way of dealing with point no. 1, so now on to 2. \r\n            </p>\r\n            <p>\r\n                Currently (as we've seen with our rope example) if we want to duplicate an object, we simply make another call to the SDF:\r\n            </p>\r\n            <p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n                    `\r\nfloat sdRope(vec3 p, in float braid_r, in float l, in float rot_freq, in float rot_offset)\r\n{\r\n    float d = 1e10; // initialise distance;\r\n    d = min(d, sdRopeCoil(p, braid_r, l, rot_freq,  rot_offset)); // Top coil\r\n    d = min(d, sdRopeCoil(p, braid_r, l, rot_freq, -rot_offset)); // Bot coil\r\n\r\n    return d;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            </p>\r\n            <p>\r\n                But isn't this sort of wasteful? The calls to the SDF are <i>exactly the same</i>, so wouldn't it be great if there were some way of condensing this into a single call to increase performance?\r\n            </p>\r\n            <p>\r\n                Enter domain repetition! Domain repetition refers to dividing our infinite spatial domain into repetitions of finite space. We first map a point in infinite space into a finite local space, then evaluate the\r\n                SDF. So long as our SDFs lie within the bounds of the finite spaces, we have gotten away with rendering as many duplications of an object as we want with zero additional SDF overhead.\r\n            </p>\r\n            <p>\r\n                It is worth noting that although we eliminate SDF overhead, we still make the render more expensive, but in an efficient way. We still have to do more material / lighting calculations as we render objects for more pixels than before. No free lunch, eh?\r\n            </p>\r\n            <br/>\r\n            <p>\r\n                This may seem a little hand-wavey at first, so let's first apply this to our example with the rope, noting that our duplicated object is simply a reflection in the xz plane:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n                    `\r\nfloat sdRope(vec3 p, in float braid_r, in float l, in float rot_freq, in float rot_offset)\r\n{\r\n    float d = 1e10; // initialise distance;\r\n    p.y = abs(p.y) - 0.02; // domain repetition: reflection in xz\r\n    d = min(d, sdRopeCoil(p, braid_r, l, rot_freq,  rot_offset));\r\n\r\n    return d;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <p>\r\n                Note that we have to offset the SDF in y in order for it to be duplicated in entirety. We have effectively partitioned our input space into two (reflected) partitions along the XZ plane.\r\n            </p>\r\n            <br/>\r\n            <p>\r\n                We can partition our space for repetition in any arbitrary way we like. For example, by partitioning space with a 2D grid:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n                    `\r\nfloat sdDomainRepGrid(vec3 p)\r\n{\r\n    float d = 1e10; // initialise distance;\r\n\r\n    const vec2 spacing = vec2(145.0); // grid spacing\r\n    vec2 id = round(p.xz / spacing); // index of the current tile p is in\r\n\r\n    vec2 q = p; // local grid space coord\r\n\r\n    // Have a quick think about why the following transform works\r\n    //    (Hint: SDFs are evaluated at the world-space origin)\r\n    q.xz = p.xz - spacing * id; // transform to local grid space\r\n\r\n    d = sdSphere(q, 2.5); // render spheres - only one SDF call!\r\n\r\n    return d;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <AnnotatedImage src={sphereDomainRep} annotation={\"Infinite domain repetition of spheres via a grid\"}/>\r\n            <br/><br/>\r\n            <p>\r\n                Another useful example is a radial repetition:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n                    `\r\n#define TAU 6.28318533\r\nfloat sdDomainRepRad(vec3 p)\r\n{\r\n    float d = 1e10; // initialise distance;\r\n\r\n    vec3 q = p;\r\n    const float rep_angle = TAU / 7.0; // angle of repetition sector (7 sectors)\r\n    float sector round(atan(p.z, p.x) / rep_angle);\r\n    float rot_angle = sector * rep_angle;\r\n    q.xz *= rot(angrot);\r\n\r\n    // Have a quick think about why this offset is necessary\r\n    q.x -= 1.0; // offset the SDF from the origin\r\n\r\n    d = sdSphere(q, 0.05);\r\n\r\n    return d;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <AnnotatedImage src={sphereDomainRepRad} annotation={\"Radial domain repetition of spheres\"}/>\r\n            <br/><br/>\r\n            <p>\r\n                We've really only scratched the surface of what domain repetition is able to do with these two examples, but rest assured it is a powerful tool for making the illusion that a scene is\r\n                complex when it is in fact rather simple and inexpensive.\r\n            </p>\r\n            <p>\r\n                Let's look at a few examples of how I applied domain repetition in Shimenawa:\r\n            </p>\r\n            <Carousel autoplay autoplaySpeed={5000} effect=\"fade\" style={{margin: \"0 auto\", paddingBottom: \"20px\", width: \"100%\"}}>\r\n                <AnnotatedImage src={domainRepShimenawa} annotation={\"Rotational repetition used to duplicate the hanging ropes and paper.\"}/>\r\n                <AnnotatedImage src={domainRepBridges} annotation={\"1D grid repetition used to duplicate bridge segments into a single continuous bridge.\"}/>\r\n                <AnnotatedImage src={domainRepPillars} annotation={\"2D grid repetition and warping used to arrange duplicated pillar segments in a pseudo-random fashion.\"} />\r\n            </Carousel>\r\n            <p>\r\n                As well as these examples, I used domain repetition extensively in modelling to make complex yet inexpensive implicit geometry.\r\n            </p>\r\n            <p>\r\n                I highly recommend <a href=\"https://iquilezles.org/articles/sdfrepetition/\" target=\"_blank\">Inigo Quilez' resources on domain repetition</a> if you are interested in using domain repetition for yourself.\r\n                There are lots of different ways to apply it - for example, think about how you may limit our infinite grid example to a <i>finite</i> grid. All manner of these examples are explained thoroughly in\r\n                the aforementioned article.\r\n            </p>\r\n            <br/>\r\n            <h3 id=\"accel\" className=\"raleway-title\">\r\n                Acceleration Structures\r\n            </h3>\r\n            <p>\r\n                As our scene becomes very complex, it becomes increasingly beneficial to cut down on the work we do in rendering SDFs in certain cases.\r\n            </p>\r\n            <p>\r\n                For particularly expensive SDFs that take up a large proportion of our scene, we can gain a good amount of performance back by employing acceleration techniques.\r\n            </p>\r\n            <p>\r\n                For Shimenawa, I used three such techniques: <b>Bounding Volumes</b>, <b>Level of Detail (LOD)</b>, and <b>Culling</b>.\r\n            </p>\r\n            <br/>\r\n            <p>\r\n                <b><u>1. Bounding Volumes</u></b>\r\n                <br/><br/>\r\n                This reduces the work done to render a complex SDF by only evaluating the whole (expensive) SDF when we are marching close to it. At larger distances, we evaulate a single inexpensive SDF \r\n                for a volume that bounds it. For example:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n                    `\r\nfloat sdExample(vec3 p)\r\n{\r\n    float d = 1e10;\r\n\r\n    // Evaluate bbox if > 1.0 away\r\n    const float bbox_eval_dist = 1.0;\r\n\r\n    // Bounding box\r\n    d = sdBox(p, ...); // params defined per-object to fit\r\n    if (d > bbox_eval_dist) return 1e10;\r\n\r\n    // Only evaluate the expensive SDF if we are close\r\n    return sdExampleExpensive(p);\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <p>\r\n                It is worth noting that with ray marching, we end up doing more marching steps as we are close to objects to converge on the final distance value for a pixel. This means that \r\n                we usually do a fairly high number of evaulations of the expensive SDF anyway as we march close, somewhat negating the improvements from the bounding box. Nevertheless, this is still \r\n                a good improvement for very expensive geometry.\r\n            </p>\r\n            <p>\r\n                It is preferable to use a scaled primitive from an expensive SDF as the bounding box instead of an additional, unrelated SDF. This removes the bounding box overhead entirely, making this optimisiation \r\n                a no-brainer to implement.\r\n            </p>\r\n            <br/>\r\n            <p>\r\n                Importantly, we can also apply a bounding volume to the ray marching loop itself. This is extremely effective at increasing performance as we effectively reduce the resolution of our \r\n                scene into only the areas that have objects, instead of wasting work evaluating SDFs for pixels we know will have no geometry.\r\n            </p>\r\n            <p>\r\n                This is a very simple addition to our main ray marching loop, provided we can analytically intersect the bounding volume (in the following case, a sphere):\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n                    `\r\n#define MAX_STEPS 128\r\n#define EPSILON 0.001\r\n#deinfe BOUNDING_SPHERE_SIZE = 10.0\r\nvoid mainImage(out vec4 fragColror, in vec2 fragCoord) {\r\n    vec3 ro = vec3(0.0); // camera origin\r\n    vec2 rd = getCameraRay(fragCoord);\r\n    \r\n    // In (x), out (y) intersection points of the bounding volume\r\n    vec2 bounding_isect = iSphere(ro, rd, BOUNDING_SPHERE_SIZE);\r\n\r\n    // If there is an intersection, and the volume currently visible\r\n    if (bounding_isect.y > 0.0) {\r\n        // We can even start the ray march at the edge of the bounding volume\r\n        float t = max(bounding_isect.x, EPSILON);\r\n\r\n        for (int i=0; i<MAX_STEPS; i++) {\r\n            vec3 p = ro + t * rd; // a point along the ray\r\n            float d = map(p); // dist to surface\r\n            if (d < EPSILON) break;\r\n            t += d;\r\n        }\r\n    }\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                <b><u>2. Level of Detail (LOD)</u></b>\r\n                <br/><br/>\r\n                For extremely expensive SDFs, we may have a lot of fine detail which becomes almost impossible to discern at far distances. It therefore doesn't make sense for us to be doing\r\n                a lot of work for something that ultimately goes unseen. LOD refers to creating a less-expensive version of the thing we want to render, and rendering it in place of the expensive version\r\n                when it is sufficiently far away from the camera. In the case of SDFs, we can just remove the primitives used for fine detail and redefine it as a separate function.\r\n            </p>\r\n            <p>\r\n                In Shimenawa, I implemented this for the infinite bridges, as the fine details will always become aliased and unnoticeable as the bridge stretches to infinity.\r\n            </p>\r\n            <p>\r\n                In code, it may look something like this:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n                    `\r\n#define LOD_DIST 100.0\r\nfloat sdExample(vec3 p)\r\n{\r\n    // Note this assumes the camera is at the world origin.\r\n    bool use_lod = length(p) > LOD_DIST;\r\n\r\n    float d = use_lod ? sdExampleLOD(p): sdExampleExpensive(p);\r\n\r\n    return d;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                <b><u>3. Culling</u></b>\r\n                <br/><br/>\r\n                We can reduce work in the ray march itself by terminating it early when we know that we are never going to intersect a certain object. This can either be because we have defined it in a certain way \r\n                or that we simply do not care that certain portions are not rendered. This is usually because a) we have defined our SDFs in such a way that we know the cannot exist in certain portions of space. Or b) \r\n                the parts of the object which are culled are not visible anyway. \r\n            </p>\r\n            <p>\r\n                We must be aware that if we forcibly terminate the raymarch, nothing will be rendered behind the object we culled, including objects from different SDFs which may exist somewhere along the ray.\r\n            </p>\r\n            <p>\r\n                In Shimenawa, I used culling mostly for the field of pillars, as it was extremely costly to render. The pillars are culled in the y axis below a certain height they are enveloped in clouds.\r\n                Additionally, the pillars are culled after a certain distance from the origin to make the scene less cluttered and less expensive.\r\n            </p>\r\n            <p>\r\n                Implementing culling is as simple as early-exiting your SDF before it is evaluated depending on a certain factor, for example vertical height:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n                    `\r\n#define Y_CULL 10.0\r\nfloat sdCullExample(vec3 p)\r\n{\r\n    // Cull based on y\r\n    if (p.y > Y_CULL) return 1e10;\r\n\r\n    return expensiveSDF(p);\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <br/>\r\n            <h3 id=\"normals\" className=\"raleway-title\">\r\n                Calculating Normals of Implicit Geometry\r\n            </h3>\r\n            <p>\r\n                There are a couple different ways to approach calculating normals for implicit geometry. The one that I (and many others on shadertoy) use is a variant of central differences which samples from a tetrahedron.\r\n            </p>\r\n            <p>\r\n                The basic idea of central differences is analogous to how we calculate a vertex normal - we look at the surfaces adjacent to the sample point to determine the derrivative (which is the normal). \r\n            </p>\r\n            <br/>\r\n            <p>\r\n                Mathematically, we calculate the partial derivatives in each primary axis to get the derivative of the surface:\r\n            </p>\r\n            <div style={{fontSize: screens.sm ? \"inherit\" : 12, paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"center\"}}>\r\n                <Latex>{`$\\\\displaystyle \\\\nabla f(p) = \\\\bigg\\\\lbrace{\\\\partial f(p)\\\\over \\\\partial x}, {\\\\partial f(p)\\\\over \\\\partial y}, {\\\\partial f(p)\\\\over \\\\partial z}\\\\bigg\\\\rbrace$`}</Latex>\r\n            </div>\r\n            <br />\r\n            <p>\r\n                Each partial derivative is then approximated via central difference, where <Latex>{`$h$`}</Latex> defines our interval size (smaller is more accurate):\r\n            </p>\r\n            <div style={{fontSize: screens.sm ? \"inherit\" : 12 }}>\r\n            <div style={{paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"center\"}}>\r\n                <Latex>{`$\\\\displaystyle {\\\\partial f(p)\\\\over \\\\partial x} \\\\approx \\\\frac{f(p + \\\\lbrace h, 0, 0\\\\rbrace) - f(p - \\\\lbrace h, 0, 0\\\\rbrace)}{2h}$`}</Latex>\r\n            </div>\r\n            <br/>\r\n            <div style={{paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"center\"}}>\r\n                <Latex>{`$\\\\displaystyle {\\\\partial f(p)\\\\over \\\\partial y} \\\\approx \\\\frac{f(p + \\\\lbrace 0, h, 0\\\\rbrace) - f(p - \\\\lbrace 0, h, 0\\\\rbrace)}{2h}$`}</Latex>\r\n            </div>\r\n            <br/>\r\n            <div style={{paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"center\"}}>\r\n                <Latex>{`$\\\\displaystyle {\\\\partial f(p)\\\\over \\\\partial z} \\\\approx \\\\frac{f(p + \\\\lbrace 0, 0, h\\\\rbrace) - f(p - \\\\lbrace 0, 0, h\\\\rbrace)}{2h}$`}</Latex>\r\n            </div>\r\n            </div>\r\n            <br />\r\n            <p>\r\n                Central difference is generally preferred for accuracy over the forward difference which you were probably taught in calculus class <Latex>{`$\\\\big(f(p + \\\\lbrace h, 0, 0\\\\rbrace) - f(p) / h\\\\big)$`}</Latex> as \r\n                it is not directionally biased.\r\n            </p>\r\n            <p>\r\n                It is worth noting though that we end up doing 6 evaluations of <Latex>{`$f(p)$`}</Latex> for central differences, whereas the forward difference needs only 4. This is undesirable when <Latex>{`$f$`}</Latex> is our expensive SDF.\r\n            </p>\r\n            <br/>\r\n            <p>\r\n                By sampling points on a tetrahedron, we can get the best of both worlds: central difference accuracy with only 4 <Latex>{`$f$`}</Latex> evaluations.\r\n            </p>\r\n            <p>\r\n                The vertices of the tetrahedron are given by: \r\n            </p>\r\n            <div style={{paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"center\"}}>\r\n                <Latex>{`$k_0=\\\\begin{Bmatrix}\\\\phantom{-}1 & -1 & -1\\\\end{Bmatrix}\\\\\\\\ k_1=\\\\begin{Bmatrix}-1 & -1 & \\\\phantom{-}1\\\\end{Bmatrix} \\\\\\\\ k_2=\\\\begin{Bmatrix}\\\\phantom{-}1 & -1 & -1\\\\end{Bmatrix} \\\\\\\\ k_3=\\\\begin{Bmatrix}\\\\phantom{-}1 & \\\\phantom{-}1 & \\\\phantom{-}1\\\\end{Bmatrix}$`}</Latex>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                The property that none of these vertices lie directly on a primary axis allows us to sum the function at each vertex to give the derivative via the following derivation:\r\n            </p>\r\n            <div style={{fontSize: screens.sm ? \"inherit\" : 10, margin: \"0 auto\", width: \"fit-content\", paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"left\"}}>\r\n                <Latex>{`$\r\n                    \\\\displaystyle \\\\phantom{\\\\iff}m=\\\\sum_ik_if(p+hk_i)\\\\\\\\\r\n                    \\\\iff m=\\\\sum_ik_i(f(p+hk_i) - f(p))\\\\\\\\\r\n                    \\\\iff m=\\\\sum_ik_i\\\\nabla_{k_i}f(p)\\\\\\\\\r\n                    \\\\iff m=\\\\sum_ik_i(k_i\\\\cdot\\\\nabla f(p))\\\\\\\\\r\n                    \\\\iff m=\\\\nabla f(p)\\\\cdot\\\\bigg\\\\lbrace\\\\sum_i k_{i_x}k_i,\\\\ \\\\sum_i k_{i_y}k_i,\\\\ \\\\sum_i k_{i_z}k_i\\\\bigg\\\\rbrace\\\\\\\\\r\n                    \\\\iff m= 4\\\\ \\\\nabla f(p)\\\\\\\\~\\\\\\\\\r\n                    \\\\ \\\\implies \\\\bar n = {m\\\\over |m|}\r\n                $`}</Latex>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                I highly suggest reading <a href=\"http://iquilezles.org/articles/normalsSDF/\" target=\"_blank\">this article from Inigo Quilez</a> for a more thorough explanation of this derivation.\r\n            </p>\r\n            <br/>\r\n            <p>\r\n                We don't have to understand this whole derivation to put the resulting observation into code:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n`\r\nvec3 calcNormal(vec3 p) {\r\n    const float h = 1e-5;\r\n    const vec2 k = vec2(1, -1);\r\n    return normalize( k.xyy * map(p + k.xyy) + \r\n                      k.yyx * map(p + k.yyx) +\r\n                      k.yxy * map(p + k.yxy) +\r\n                      k.xxx * map(p + k.xxx) );\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <p>\r\n                And just like that, we have normals!\r\n            </p>\r\n            <AnnotatedImage src={ropeNormals} annotation={\"Visualisation of normals generated for an SDF using tetrahedron sampling.\"}/>\r\n            <br/>\r\n            <p>\r\n                Though the above code works perfectly fine mathematically, you may encounter examples which look different yet identical at runtime. \r\n            </p>\r\n            <p>\r\n                The reason for this is due to how certain compilers deal with the above code. Particularly for WebGL, the compiler may decide to inline the map function four times \r\n                in an attempt to boost runtime performance, but in doing so, may dramatically increase the compile time, or may run over the allowed instruction size on the platform itself.\r\n            </p>\r\n            <p>\r\n                Some solutions (particularly on shadertoy) trick the compiler into leaving the function be by changing the normal calculation into a loop. The loop must depend on a value which is unknown at runtime to prevent the loop from\r\n                being unwound and causing a similar problem to before.\r\n            </p>\r\n            <br/>\r\n            <p>\r\n                Now with normals calculated, we have all the geometric information we need to move on to lighting! :)\r\n            </p>\r\n            <br/>\r\n            <h3 id=\"shadows\" className=\"raleway-title\">\r\n                Fast Soft Shadows\r\n            </h3>\r\n            <p>\r\n                The calculations most integral to grounding our scene revolve around the transportation of light. Though our use of light\r\n                does not have to be physically correct, it is usually a important to <i>base our lighting from physical principles</i>. This makes our calculations more well defined and, importantly, lets us \r\n                avoid the \"uncanny valley\" where things 'just don't look quite right'.\r\n            </p>\r\n            <p>\r\n                In this section and the next we will look at methods to build up a simple lightscape. We will focus at this stage on splitting our image into occluded / non-occluded parts through use of shadow.\r\n            </p>\r\n            <p>\r\n                To preface, light transportation is more complicated than a simple occlusion pass, and we will deliberately be leaving out specific light phenomena like bounce lighting (indirect illumination), \r\n                and subsurface scattering here to revisit later mostly in the interest of performance.\r\n            </p>\r\n            <br/><br/>\r\n            <p>\r\n                The most basic approach we will begin with is by casting a shadow similar to how it is done in ray tracing. That is, we cast a ray from an objects surface in the direction of light, evaluating the colour as \r\n                shadow if we intersect any objects on the way. \r\n            </p>\r\n            <p>\r\n                The obvious way to implement this is with a secondary ray marching loop:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n`\r\n#define MAX_SHADOW_STEPS 256\r\nvoid calcShadow(in vec3 ro, in vec3 rd) {\r\n\r\n    // Start with a small t offset to avoid reintersecting the current surface\r\n    float t = 0.01;\r\n\r\n    // No shadow unless an intersection happens during the raymarch\r\n    //   Note: Shadow is a multiplier on colour, so 1.0 = no shadow, 0.0 = full shadow.\r\n    float shadow = 1.0;\r\n\r\n    for (int i=0; i<MAX_SHADOW_STEPS; i++) {\r\n        vec3 p = ro + t * rd;\r\n        float d = map(p);\r\n\r\n        if (d < EPSILON) { shadow = 0.0; break; };\r\n\r\n        t += d;\r\n    }\r\n\r\n    return shadow;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <AnnotatedImage src={hardShadows} annotation={\"Hard shadows via a secondary ray-march\"}/>\r\n            <br/>\r\n            <p>\r\n                This is a good starting point, but is not the look that we're going for. We have reduced shadowing to a binary case, when real shadows almost never look this sharp unless we are\r\n                in very strong (almost always unnatural) lighting conditions. Not to say that this way of shadowing is 'incorrect' - we could definitely use it for a comic style \r\n                or in <a href=\"https://en.wikipedia.org/wiki/Cel_shading\" target=\"_blank\">cel shading</a>.\r\n            </p>\r\n            <br/>\r\n            <p>\r\n                For more realistic shadows, we must observe that shadows have regions of partial occlusion - penumbra - where our shadow multiplier will be somewhere between zero and one.\r\n                This is due to light sources having a physical size, not just being some abstract and infintessimally small point. From a given perspective, a proportion of the light source may\r\n                be occluded, so we should model this also.\r\n            </p>\r\n            <p>\r\n                SDFs become very beneficial in doing so. What would normally take ray-tracing many individual samples to compute, we can approximate by observing that at any point along our light ray if we are close to hitting an object,\r\n                then we are likely in the penumbra. We can also surmise that the amount of occlusion is inversely proportional to the distance to the nearest intersection, which is exactly what the SDF describes. \r\n                Lastly we can assume that the distance along the light ray is proportional to the occlusion due to the effects of parallax.\r\n            </p>\r\n            <p>\r\n                From this, we can come up with the following equation:\r\n            </p>\r\n            <div style={{margin: \"0 auto\", width: \"fit-content\", paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"left\"}}>\r\n                <Latex>{`$\\\\displaystyle \\\\phantom{\\\\iff} \\\\text{occ}\\\\propto {t \\\\over d}\\\\\\\\~\\\\\\\\ \\\\iff\\\\text{occ}= k \\\\cdot {t \\\\over d}$`}</Latex>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                Then modify our existing shadow calculation to use it:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n`\r\n#define MAX_SHADOW_STEPS 256\r\nvoid calcShadow(in vec3 ro, in vec3 rd, float k) {\r\n\r\n    float t = 0.01;\r\n\r\n    // Again, default case is no shadow\r\n    //  Note: shadow = 1 - occ so it can be used as a multiplier\r\n    float shadow = 1.0;\r\n\r\n    for (int i=0; i<MAX_SHADOW_STEPS; i++) {\r\n        vec3 p = ro + t * rd;\r\n        float d = map(p);\r\n        \r\n        // early exit for full shadow\r\n        if (d < EPSILON) return 0.0;\r\n\r\n        // Note: flip occ calculation as shadow is inv. proportional to occ.\r\n        shadow = min(shadow, k * d / t)\r\n\r\n        t += d;\r\n    }\r\n\r\n    return shadow;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <AnnotatedImage src={softShadows} annotation={\"Soft shadows, k = 2.0\"}/>\r\n            <br/>\r\n            <p>\r\n                For Shimenawa, I chose to make the foreground shadows softer than those in the background to mimic the light scattering properties you may see from a rope material. While the sunlight remains the same for the entire \r\n                scene, a rope would internally scatter the light somewhat due to gaps and subsurface scattering, leading to an overall more diffuse look. Instead of modelling this complex scattering, just increasing the shadow softness is enough to\r\n                get the point across.\r\n            </p>\r\n            <br/>\r\n            <p>\r\n                In cases, there is minor artifacting with the approach above. If this becomes an issue, I would recommend looking at the following fix (it is worth noting that this fix is more expensive though).\r\n            </p>\r\n            <div style={{width: \"100%\", maxWidth: \"540px\", margin: \"0 auto\", aspectRatio: \"3/2\"}}>\r\n                <iframe width=\"100%\" height=\"100%\" frameborder=\"0\" src=\"https://www.shadertoy.com/embed/lsKcDD?gui=true&t=10&paused=true&muted=false\" allowfullscreen></iframe>\r\n            </div>\r\n            <br/><br/>\r\n            <h3 id=\"ao\" className=\"raleway-title\">\r\n                Ambient Occlusion\r\n            </h3>\r\n            <p>\r\n                We've generated a simple lightscape with shadow casting, but you may have noticed that our result still looks a bit flat. For example with the rope, wouldn't we expect \r\n                the crevices between the two braids to be dark? As it stands, these areas are fully illuminated. \r\n            </p>\r\n            <p>\r\n                The first reason for this is our very basic use of materials. Currently, our material is a single colour, or \"albedo\", for all parts not in shadow. Typically, we will model the amount of light \r\n                which would reach a surface at a certain point within the material itself. This is called <b>diffuse lighting</b>, and we typically implement it as <i>lambertian diffuse</i>, the details of which will follow in the next section. \r\n            </p>\r\n            <p>\r\n                We should also note that diffuse lighting is <b>not the same as the shadow casting we did in the previous step</b>. We do not model inter-object lighting, only intra-object lighting (i.e. self-shadowing).\r\n                However, implementing this will lead to some visual improvement:\r\n            </p>\r\n            <Carousel autoplay autoplaySpeed={5000} effect=\"fade\" style={{margin: \"0 auto\", paddingBottom: \"20px\", width: \"100%\"}}>\r\n                <AnnotatedImage src={noAO} annotation={\"Without lambertian diffuse (for comparison)\"}/>\r\n                <AnnotatedImage src={noAOlambertian} annotation={\"With lambertian diffuse\"}/>\r\n            </Carousel>\r\n            <p>\r\n                Lambertian diffuse is one part of the equation for getting more accurate lighting, but the aforementioned problem with crevices being fully illuminated is still unsolved.\r\n            </p>\r\n            <p>\r\n                This is because the rest of the problem is actually a <i>global illumination</i> issue. We should think about <i>why</i> a crevice would be less illuminated - because ambient light is less likely \r\n                to bounce into the crevice then back into our camera. Importantly, this is not necessarily direct light from our light source, so we must find another way to model <i>indirect</i> lighting outside of our shadow pass.\r\n            </p>\r\n            <p>\r\n                This is the role of ambient occlusion (AO). We model how likely it is that light would arrive at a point on the model's surface, and use that to determine our final colour alongside our shadow multiplier.\r\n                It follows that if light is less likely to arrive at a point, the final colour should be darker.\r\n            </p>\r\n            <p>\r\n                AO approximates the probability of light reaching a point by sampling for nearby geometry that may occlude the point. With this description, it should be more obvious why the technique is called \"ambient occlusion\" \r\n                in the first place.\r\n            </p>\r\n            <p>\r\n                More specifically, we uniformly sample points in a hemisphere about the surface normal. This is an approach you will be familiar with if you've done ray tracing before. Let's have a look at it in code:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n`\r\n#define AO_SAMPLES 64.0\r\n#define AO_MAX_SAMPLE_DIST 0.01\r\n#define AO_DISTANCE_FALLOFF 6.0\r\nvoid calcAO(in vec3 p, in vec3 normal) {\r\n\r\n    float ao = 0.0;\r\n\r\n    for (int i=0; i<int(AO_SAMPLES); i++) {\r\n        \r\n        vec3 sample_vector = sampleHemisphere(float(i), AO_SAMPLES);\r\n\r\n        // Sample at random distances as we are really sampling a volume of space\r\n        float h = hash(float(i));\r\n        sample_vector *= AO_MAX_SAMPLE_DIST * h;\r\n        \r\n        vec3 q = p + 0.01 * normal; // Point just above the surface to avoid self-sampling.\r\n        \r\n        // Any points at a distance > 1.0 are not close enough to contribute to the occlusion\r\n        ao += clamp(map(q + sample_vector), 0.0, 1.0);\r\n    }\r\n    ao /= AO_SAMPLES;\r\n\r\n    // Control the linear falloff of the AO\r\n    return clamp(ao * AO_DISTANCE_FALLOFF, 0.0, 1.0);\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <p>\r\n                The basic loop is very simple; we sample from the hemisphere, and accumulate the distance to the closest object, taking the average at the end. Our AO\r\n                is a multiplier like with our shadow calculation, so full occlusion and no occlusion are 0.0 and 1.0 respectively.\r\n            </p>\r\n            <p>\r\n                I haven't included the sampleHemisphere() function here - see if you can work through it yourself. It involves some reasonably simple maths with spherical coordinates.\r\n            </p>\r\n            <p>\r\n                Finally, note the inclusion of a hashing function at line 13. With AO, we are really sampling the entire volume of space about our point for occlusion, not just a \r\n                shell. This is important as we are using SDFs, which only give the distance from a given point, not along a ray like we may have in ray tracing. \r\n                Thus, we include a hashing function (<HashLink smooth to=\"#hash\">details here</HashLink>) to generate a [0, 1] value for each sample which we can use to ensure we sample at varying distances.\r\n            </p>\r\n            <p>\r\n                With AO included, we get a much better lighting approximation:\r\n            </p>\r\n            <Carousel autoplay autoplaySpeed={5000} effect=\"fade\" style={{margin: \"0 auto\", paddingBottom: \"20px\", width: \"100%\"}}>\r\n                <AnnotatedImage src={noAOlambertian} annotation={\"Lambertian diffuse only (for comparison)\"}/>\r\n                <AnnotatedImage src={aoLambertian} annotation={\"Ambient Occlusion and lambertian diffuse\"}/>\r\n            </Carousel>\r\n            <p>\r\n                With just shadow casting and AO, we have a relatively simple yet already powerful lighting system. This suffices most of our lighting needs, the rest of which we can tackle individually for each material as we see fit,\r\n                like with our lambertian diffuse example above.\r\n            </p>\r\n            <br/>\r\n            <h2 id=\"materials\" className=\"raleway-title\">\r\n                Stylised Material System\r\n            </h2>\r\n            <p>\r\n                Though materials have been used up until this point, I havent gone into the details of how they are implemented. Shimenawa uses a basic yet heavily stylised material system. The only material property \r\n                that I chose to define is material albedo (base colour) - the rest of the material properties are handled on a case-by-case basis when calculating lighting.\r\n            </p>\r\n            <p>\r\n                We can define a material per SDF evaluation by returning (or passing in and setting an out/pointer argument) alongside our distance value. By doing this, we can define per-instance materials so that duplicates of the same object may\r\n                be rendered with different colours and lighting effects. Take for example the paper hanging from the rope ( 紙垂 ) where per instance materials are used to change the colour of individual paper strips from red to white above. \r\n            </p>\r\n            <p>\r\n                Managing materials at a high level in this way requires a system to map a numerical value we return from the SDF to a certain material; an enum is a good choice for this. GLSL does not have an enum wrapper, but we can achieve the same\r\n                effect by defining our enum values as macros:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n`\r\n#define MAT_0 1.0\r\n#define MAT_1 2.0\r\n#define MAT_2 3.0\r\n//...\r\n#define MAT_DEBUG 1e10`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <p>\r\n                It is a good idea to include a default/debug material for convenience and debugging purposes in case your material index becomes messed up as you implement more rendering features.\r\n            </p>\r\n            <p>\r\n                We can now start evaluating object colour in our render loop with branching logic:\r\n            </p>\r\n            <div className=\"code-snippet\" style={{width: \"100%\"}}>\r\n                <SyntaxHighlighter \r\n                    language=\"cpp\" \r\n                    showLineNumbers={true}\r\n                    style={dracula}\r\n                    startingLineNumber={0}\r\n                >\r\n                    {\r\n`\r\n// We could directly compare material values with equality, but using\r\n//  a helper macro like the following is more versataile.\r\n#define CMP_MAT_LT(a, b) a < (b + 0.5)\r\n\r\nvec3 render(in vec3 ro, in vec3 rd, in float t, in float m) \r\n{\r\n    // Calculate properties and lighting effects that all materials use\r\n    vec3 normal = calcNormal(pos);\r\n    float shadow = calcShadow(ro, rd);\r\n    float ambient_occlusion = calcAO(p, normal);\r\n\r\n    vec3 col = vec3(0.0);\r\n    \r\n    // Select material based on cascading comparisons of m to material values\r\n    if (CMP_MAT_LT(m, MAT_0)) {\r\n        // ...Calculate colour and lighting properties of MAT_0\r\n    }\r\n    else if (CMP_MAT_LT(m, MAT_1)) {\r\n        // ...Calculate colour and lighting properties of MAT_1\r\n    } \r\n    else if (CMP_MAT_LT(m, MAT_2)) {\r\n        // ...Calculate colour and lighting properties of MAT_2\r\n    }\r\n    else {\r\n        // ...Debug / Default material\r\n    }\r\n\r\n    return col;\r\n}`\r\n                    }\r\n                </SyntaxHighlighter>\r\n            </div>\r\n            <p>\r\n                Due to materials generally generally being quite localised and thus usually in the same shader group, the hit on performance from branching like this is fairly inconsequential.\r\n            </p>\r\n            <p>\r\n                With the high-level material system set up, we can move onto applying stylised effects to individual materials.\r\n            </p>\r\n            <br/>\r\n            <h3 id=\"stylised-lighting\" className=\"raleway-title\">\r\n                Simple Stylised Lighting\r\n            </h3>\r\n            <p>\r\n                The first basic step in applying lighting to a material is to mix the material's albedo with the occlusion values we calculated earlier. We can start by combining the occlusion values multiplicatively\r\n                and applying then to the material's albedo.\r\n            </p>\r\n            <div style={{paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"center\"}}>\r\n                <Latex>{`$\\\\text{occ} = \\\\text{shadow} \\\\times \\\\text{ao}$`}</Latex>\r\n            </div>\r\n            <br/>\r\n            <div style={{paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"center\"}}>\r\n                <Latex>{`$(\\\\text{i})\\\\ \\\\text{col} = \\\\text{occ} \\\\times \\\\text{albedo}$`}</Latex>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                Improving this slightly, we can mix in a shadow colour to our albedo based on the value of occ.\r\n            </p>\r\n            <div style={{paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"center\"}}>\r\n                <Latex>{`$\\\\text{col} = \\\\text{mix}(\\\\text{shadow\\\\_col},\\\\ \\\\text{albedo},\\\\ \\\\text{occ})$`}</Latex>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                We could choose all manner of values for the shadow colour, but drawing from and modifying physical principles is usually a good start when we want to stlyise. Let's consider a few to build\r\n                up a stylised lighting model - if you are aware of the phong lighting model, our starting point will be similar.\r\n            </p>\r\n            <p>\r\n                When light is occluded in reality, a proportion of the total light energy will be reflected back into view, so we can start by modelling the shadow colour in this way:\r\n            </p>\r\n            <div style={{paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"center\"}}>\r\n                <Latex>{`$\\\\text{shadow\\\\_col} = \\\\text{mat\\\\_ occ} \\\\times \\\\text{albedo}\\\\ | \\\\ \\\\text{mat\\\\_occ}\\\\in [0,1]$`}</Latex>\r\n            </div>\r\n            <br/>\r\n            <div style={{paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"center\"}}>\r\n                <Latex>{`$\\\\implies\\\\text{(ii)}\\\\ \\\\text{col} = \\\\text{mix}(\\\\text{mat\\\\_ occ} \\\\times \\\\text{albedo},\\\\ \\\\text{albedo},\\\\ \\\\text{occ})$`}</Latex>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                It is a good idea to separate this occlusion value into a separate variable 'mat_occ' so that we have more artistic control over per material lighting.\r\n                A shadow colour defined in this way effectively incorporates a constant strength ambient light into the scene.\r\n            </p>\r\n            <p>\r\n                We can take this even further and actually incorporate an ambient light colour into the shadow colour, akin to global illumination. This should be a colour from the scene's environment\r\n                to ground the lighting in reality. When rendering outdoor scenes, some variant of the sky colour is a good choice:\r\n            </p>\r\n            <div style={{paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"center\"}}>\r\n                <Latex>{`$\\\\text{shadow\\\\_col} = \\\\text{mix}(\\\\text{mat\\\\_occ} \\\\times \\\\text{albedo},\\\\ \\\\text{mat\\\\_ambient},\\\\ \\\\text{ambient})\\\\ | \\\\ \\\\text{ambient}\\\\in [0,1]$`}</Latex>\r\n            </div>\r\n            <br/>\r\n            <div style={{paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"center\"}}>\r\n                <Latex>{`$\\\\implies\\\\text{(iii)}\\\\ \\\\text{col} = \\\\text{mix}\\\\bigg(\\\\text{mix}(\\\\text{mat\\\\_occ} \\\\times \\\\text{albedo},\\\\ \\\\text{mat\\\\_ambient},\\\\ \\\\text{ambient}),\\\\ \\\\text{albedo}, \\\\text{occ}\\\\bigg)$`}</Latex>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                We can see how these methods compare:\r\n            </p>\r\n            <Carousel autoplay autoplaySpeed={5000} effect=\"fade\" style={{margin: \"0 auto\", paddingBottom: \"20px\", width: \"100%\"}}>\r\n                <AnnotatedImage src={shadowColMult} annotation={\"Shadow applied via (i) - multiplicative\"}/>\r\n                <AnnotatedImage src={shadowColConstMix} annotation={\"Shadow applied via (ii) - constant mix\"}/>\r\n                <AnnotatedImage src={shadowColAmbientMix} annotation={\"Shadow applied via (iii) - constant & ambient mix\"}/>\r\n            </Carousel>\r\n            <br/>\r\n            <h3 id=\"shadow-ramp\" className=\"raleway-title\">\r\n                Colour Ramps\r\n            </h3>\r\n            <p>\r\n                A particular effect that I wanted to incorporate on the rope in Shimenawa was sub-surface scattering. \r\n            </p>\r\n            <p>\r\n                Sub-surface scattering describes the transport of light within a translucent or porous object.\r\n                It is the same effect that you get when you can see your skin glow when you shine a torch on it for example, or why marble sculptures tend to look 'soft' or have a subtle glow. \r\n                The same effect would be present on the rope when the sun shines at it - leading to a distinct glow around the edges of the rope where rope fibers would be sparse.\r\n            </p>\r\n            <p>\r\n                Though there is an upcoming section about applying this to a simpler case: the hanging paper, computing this effect for the rope accurately would be too expensive, or cheaply would be\r\n                too inaccurate to resemble the desired feature.\r\n            </p>\r\n            <p>\r\n                An alternative solution I came up with is to use a combination of colour ramps, <HashLink smooth to=\"#bloom\">bloom</HashLink>, and <HashLink smooth to=\"#outline\">stylised object outlines</HashLink>.\r\n                The usage of colour ramps was inspired by the lighting in Genshin Imapct, as well as their Unite Seoul 2018 talk: <a href=\"https://youtu.be/egHSE0dpWRw?si=_hTHBpRsOviCzsmK&t=776\" target=\"_blank\" rel=\"noreferrer\">From mobile to high-end PC: Achieving high quality anime style rendering on Unity</a>.\r\n            </p>\r\n            <p>\r\n                Colour ramps define a multi-colour gradient over a value range, I use this both to boost contrast of lighting, as well as to add a artificial sub-surface scattering component when desired.\r\n            </p>\r\n            <p>\r\n                The artificial subsurface scattering component is calculated by mixing a highly saturated 'terminator line' colour into a material's shadow colour as follows:\r\n            </p>\r\n            <div style={{paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"center\"}}>\r\n                <Latex>{`$\\\\text{ramped\\\\_shadow\\\\_col} = \\\\text{mix}\\\\bigg(\\\\text{shadow\\\\_col},\\\\ \\\\text{terminator\\\\_col},\\\\ \\\\min(1.0,\\\\ 4.0 \\\\times \\\\text{occ})\\\\bigg)$`}</Latex>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                The coefficient 4.0 of 'occ' is discretionary and serves to make the colour ramp shallower or steeper, depending on the desired effect. Typically, terminator lines in sub-surface scattering are fairly sharp,\r\n                so I chose to use a relatively steep ramp here.\r\n            </p>\r\n            <p>\r\n                We can then boost the lighting contrast by similarly applying a ramp to the albedo-shadow mix function:\r\n            </p>\r\n            <div style={{paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"center\"}}>\r\n                <Latex>{`$\\\\text{(iv)}\\\\ \\\\text{col} = \\\\text{mix}\\\\bigg(\\\\text{ramped\\\\_shadow\\\\_col},\\\\ \\\\text{albedo},\\\\ \\\\min(1.0,\\\\ 2.0 \\\\times \\\\text{occ})\\\\bigg)$`}</Latex>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                Applying this contrast ramp has a side effect of making the shadows particularly dark, so as a result I decided to modify the occlusion combination to brighten dark spots and\r\n                make ambient occlusion more emphasised:\r\n            </p>\r\n            <div style={{paddingLeft: \"3em\", paddingRight: \"3em\", textAlign: \"center\"}}>\r\n                <Latex>{`$\\\\text{(v)}\\\\ \\\\displaystyle\\\\text{occ} = \\\\frac{\\\\text{shadow} + \\\\text{extra\\\\_shadow\\\\_brightness}}{1.0 + \\\\text{extra\\\\_shadow\\\\_brightness}} \\\\times \\\\text{ao}^2$`}</Latex>\r\n            </div>\r\n            <br/>\r\n            <p>\r\n                The effect is subtle, but has noticeable effects from certain viewing angles.\r\n            </p>\r\n            <Carousel autoplay autoplaySpeed={5000} effect=\"fade\" style={{margin: \"0 auto\", paddingBottom: \"20px\", width: \"100%\"}}>\r\n                <AnnotatedImage src={shadowRamped} annotation={\"Shadow applied via (iv) - ramped\"}/>\r\n                <AnnotatedImage src={shadowRampedBright} annotation={\"Shadow applied via (v) - ramped and brightened\"}/>\r\n            </Carousel>\r\n            <br/>\r\n            <h3 id=\"reflections\" className=\"raleway-title\">\r\n                Grazing angles and Metallic Reflections\r\n            </h3>\r\n            <p>\r\n                The following sections are in progress, please come back later!\r\n            </p>\r\n            <h3 id=\"sss\" className=\"raleway-title\">\r\n                Quick and Easy Sub-surface Scattering\r\n            </h3>\r\n            <br/>\r\n            <h2 id=\"volumetrics\" className=\"raleway-title\">\r\n                Volumetric Cloud Rendering\r\n            </h2>\r\n            <br/>\r\n            <h2 id=\"hdr\" className=\"raleway-title\">\r\n                HDR Rendering\r\n            </h2>\r\n            <h3 id=\"bloom\" className=\"raleway-title\">\r\n                Buffer-pass Bloom\r\n            </h3>\r\n            <br/>\r\n            <h2 id=\"ldr\" className=\"raleway-title\">\r\n                LDR Post-processing\r\n            </h2>\r\n\r\n            <h2 id=\"bonus\" className=\"raleway-title\">\r\n                Bonus: Some Extra Techniques\r\n            </h2>\r\n            <h3 id=\"fog\" className=\"raleway-title\">\r\n                Better Fog\r\n            </h3>\r\n            <h3 id=\"hash\" className=\"raleway-title\">\r\n                \"Good Enough\" Hashing\r\n            </h3>\r\n            <h3 id=\"atmosphere\" className=\"raleway-title\">\r\n                Simple Atmospheres\r\n            </h3>\r\n            <h3 id=\"stars\" className=\"raleway-title\">\r\n                Procedural Star Fields \r\n            </h3>\r\n            <h3 id=\"outline\" className=\"raleway-title\">\r\n                Stylised Object Outlines\r\n            </h3>\r\n            <h3 id=\"dithering\" className=\"raleway-title\">\r\n                Cheap Dithering\r\n            </h3>\r\n        </ProjectPage>\r\n    );\r\n}\r\n\r\nexport default Home;\r\n","import React from 'react'\r\nimport {Image} from 'antd'\r\n\r\nconst AnnotatedImage = ({annotation, fontSize, ...props}) => {\r\n\r\n    const paddingBottom = props.paddingBottom ? props.paddingBottom : \"20px\"\r\n\r\n    return (\r\n        <div style={{position: \"relative\"}}>\r\n            <Image {...props} />\r\n            {annotation ? (\r\n                <div className=\"styled-text\" style={{\r\n                    position: \"absolute\", \r\n                    bottom: 0, \r\n                    left: 0, \r\n                    backgroundColor: 'rgba(21, 25, 31, 0.65)',\r\n                    width: \"100%\", \r\n                    fontSize: fontSize && fontSize,\r\n                    textAlign: 'center',\r\n                    padding: \"10px 5px\",\r\n                    paddingBottom: paddingBottom\r\n                }}>\r\n                    {annotation}\r\n                </div>\r\n            ) : null}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default AnnotatedImage;","import React, { useState, useEffect } from 'react';\r\nimport { Link, useLocation } from 'react-router-dom';\r\nimport { Divider, Tooltip, Image } from 'antd';\r\nimport { GithubOutlined, SendOutlined } from '@ant-design/icons';\r\n\r\nimport \"../css/projectpage.scss\";\r\n\r\nconst HomeTemplate = ({title, githubURL, projectRoute, projectLink, thumb}) => {\r\n    const loc = useLocation().pathname;\r\n\r\n    useEffect(() => {\r\n        window.scrollTo(0, 0)\r\n      }, [])\r\n\r\n    return (\r\n        <>\r\n        <div style={{\r\n            marginTop: \"-3rem\",\r\n            backgroundImage: `url(${thumb})`,\r\n            backgroundPosition: 'center',\r\n            backgroundSize: 'cover',\r\n            backgroundRepeat: 'no-repeat',\r\n            height: '100vh',\r\n            zIndex: -1,\r\n        }} />\r\n        <div className=\"project-home-wrapper\" style={{position: \"absolute\", width: \"100%\", top: \"101vh\", left: \"0px\", transform: \"translate(0, -100%)\"}}>\r\n            <header className=\"home-header\">\r\n                <h1 id=\"title\" style={{display: 'inline-block'}}>{title}</h1>\r\n                <span style={{padding: \"0 1em\", display: 'inline-block'}}>\r\n                    {githubURL != undefined ? (\r\n                        <Tooltip title=\"View on Github\" placement=\"bottom\">\r\n                            <a href={githubURL} target=\"_blank\">\r\n                                <GithubOutlined className=\"title-icon\"/>\r\n                            </a>\r\n                        </Tooltip>\r\n                    ) : null}\r\n\r\n                    {projectRoute != undefined  ? (\r\n                        <Tooltip title=\"View project\" placement=\"bottom\">\r\n                            <Link to={loc + projectRoute}>\r\n                                <SendOutlined className=\"title-icon\"/>\r\n                            </Link>\r\n                        </Tooltip>\r\n                    ) : null}\r\n\r\n                    {projectLink != undefined  ? (\r\n                        <Tooltip title=\"View project\" placement=\"bottom\">\r\n                            <a href={projectLink} target=\"_blank\">\r\n                                <SendOutlined className=\"title-icon\"/>\r\n                            </a>\r\n                        </Tooltip>\r\n                    ) : null}\r\n\r\n                </span>\r\n                <Divider style={{borderTopWidth: \"1px\", borderTopColor: \"#000000\", opacity: 0.5}}/>\r\n            </header>\r\n            <div style={{height: \"8em\"}}>\r\n\r\n            </div>\r\n        </div>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default HomeTemplate;","\r\nimport { Breadcrumb, Anchor } from 'antd';\r\nimport { HashLink } from 'react-router-hash-link';\r\nimport React, { useState, useEffect, useRef } from 'react';\r\n\r\nconst useHeadingsData = () => {\r\n\tconst [nestedHeadings, setNestedHeadings] = useState([]);\r\n\r\n\tuseEffect(() => {\r\n\t\tconst headingElements = Array.from(\r\n\t\t\tdocument.querySelectorAll(\"h1, h2, h3\")\r\n\t\t);\r\n\r\n\t\t// Created a list of headings, with H3s nested\r\n\t\tconst newNestedHeadings = getNestedHeadings(headingElements);\r\n\r\n\t\tsetNestedHeadings(newNestedHeadings);\r\n\t}, []);\r\n\r\n\treturn { nestedHeadings };\r\n};\r\n\r\nconst getNestedHeadings = (headingElements) => {\r\n\tvar headingAttention = headingElements.filter(e => {\r\n\t\tlet l = e.nodeName;\r\n\t\treturn e.id !== \"title\" && (l === \"H1\" || l === \"H2\" || l === \"H3\");\r\n\t})\r\n\r\n\tlet ki = -1;\r\n\tvar headingLst = headingAttention.map(e => {\r\n\t\tki++;\r\n\t\treturn ({ key: `contents_${ki}`, href: `#${e.id}`, title: e.innerHTML, level: parseInt(e.nodeName.slice(-1)) })\r\n\t})\r\n\tvar result = [],\r\n\t\tindices = [],\r\n\t\tlevels = [result]\r\n\r\n\theadingLst.forEach(o => {\r\n\t\tvar index = indices.findIndex(level => level >= o.level);\r\n\t\tif (index === -1) {\r\n\t\t\tindex = indices.push(o.level) - 1;\r\n\t\t} else {\r\n\t\t\tindices.length = index + 1;\r\n\t\t}\r\n\t\tlevels[index].push(Object.assign({}, o, { children: levels[index + 1] = [] }));\r\n\t});\r\n\r\n\r\n\treturn result;\r\n};\r\n\r\nconst useNavHeight = () => {\r\n\tconst [navHeight, setNavHeight] = useState(0);\r\n\r\n\tuseEffect(() => {\r\n\t\tconst navbar = document.getElementById(\"main-navbar\");\r\n\t\tconsole.log(navbar)\r\n\r\n\t\tsetNavHeight(navbar.offsetHeight);\r\n\t}, []);\r\n\r\n\treturn { navHeight };\r\n}\r\n\r\nconst TableOfContents = ({ title }) => {\r\n\tconst { nestedHeadings } = useHeadingsData();\r\n\tconst { navHeight } = useNavHeight();\r\n\r\n\tconst [anchorHeight, setAnchorHeight] = useState(\"85vh\");\r\n\r\n\tuseEffect(() => {\r\n\t\tconst breadcrumbRef = document.getElementById(\"toc-breadcrumb\");\r\n\t\tif (breadcrumbRef) {\r\n\t\t\tsetAnchorHeight(`calc(100vh - 6rem - ${breadcrumbRef.offsetHeight}px)`)\r\n\t\t}\r\n\t}, [])\r\n\r\n\treturn (\r\n\t\t<>\r\n\t\t\t<Breadcrumb id=\"toc-breadcrumb\" style={{paddingBottom: \"14px\", position: \"sticky\"}}\r\n\t\t\t\titems={[\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttitle: <a href=\"#home\">Portfolio</a>,\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttitle: <a href=\"#projects\">Projects</a>,\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttitle: `${title}`\r\n\t\t\t\t\t}\r\n\t\t\t\t]}\r\n\t\t\t/>\r\n\t\t\t<Anchor\r\n\t\t\t\tstyle={{maxHeight: anchorHeight, overflow: \"auto\"}}\r\n\t\t\t\ttargetOffset={navHeight}\r\n\t\t\t\tonClick={(e, l) => {\r\n\t\t\t\t\t// I have no idea why this works in hash router link... but sure\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t}}\r\n\t\t\t\titems={nestedHeadings}\r\n\t\t\t/>\r\n\t\t</>\r\n\t);\r\n};\r\n\r\nexport default TableOfContents","import FadeIn from 'react-fade-in';\r\nimport HomeTemplate from './homeTemplate';\r\nimport TableOfContents from './tableofcontents';\r\nimport { Row, Col, Grid } from 'antd';\r\nconst { useBreakpoint } = Grid\r\n\r\nconst ProjectPage = ({title, thumb, projectLink, projectRoute, githubURL, footer, children}) => {\r\n    const screens = useBreakpoint();\r\n\r\n    return (\r\n    \r\n        <>\r\n        <FadeIn>\r\n            <HomeTemplate \r\n                title={title} \r\n                thumb={thumb} \r\n                projectRoute={projectRoute} \r\n                projectLink={projectLink} \r\n                githubURL={githubURL} />\r\n            <Row gutter={0}>\r\n            <Col xs={0} lg={5}>\r\n            <div className='project-toc-wrapper'>\r\n                <TableOfContents title={title}/> \r\n            </div>\r\n            </Col>\r\n            <Col xs={24} lg={19}>\r\n            <div className=\"project-content-wrapper\" style={{marginRight: screens.lg? \"17.5vw\" : \"6vw\", marginLeft: screens.lg? 0 : \"6vw\"}}>\r\n                {children}\r\n            </div>\r\n            <div className='project-footer-wrapper' style={{\r\n                display: \"flex\", justifyContent: \"center\", \r\n                marginTop: \"8vh\", marginBottom: \"5vh\",\r\n                marginRight: screens.lg? \"17.5vw\" : \"6vw\", marginLeft: screens.lg? 0 : \"6vw\"\r\n                }}>\r\n                {footer ? {footer} : \"❋ That's all! Thanks for reading. ❋\"}\r\n            </div>\r\n            </Col>\r\n            </Row>\r\n        </FadeIn>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default ProjectPage;","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { Link, NavLink } from 'react-router-dom';\n\nlet hashFragment = '';\nlet observer = null;\nlet asyncTimerId = null;\nlet scrollFunction = null;\n\nfunction reset() {\n  hashFragment = '';\n  if (observer !== null) observer.disconnect();\n  if (asyncTimerId !== null) {\n    window.clearTimeout(asyncTimerId);\n    asyncTimerId = null;\n  }\n}\n\nfunction isInteractiveElement(element) {\n  const formTags = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA'];\n  const linkTags = ['A', 'AREA'];\n  return (\n    (formTags.includes(element.tagName) && !element.hasAttribute('disabled')) ||\n    (linkTags.includes(element.tagName) && element.hasAttribute('href'))\n  );\n}\n\nfunction getElAndScroll() {\n  let element = null;\n  if (hashFragment === '#') {\n    // use document.body instead of document.documentElement because of a bug in smoothscroll-polyfill in safari\n    // see https://github.com/iamdustan/smoothscroll/issues/138\n    // while smoothscroll-polyfill is not included, it is the recommended way to implement smoothscroll\n    // in browsers that don't natively support el.scrollIntoView({ behavior: 'smooth' })\n    element = document.body;\n  } else {\n    // check for element with matching id before assume '#top' is the top of the document\n    // see https://html.spec.whatwg.org/multipage/browsing-the-web.html#target-element\n    const id = hashFragment.replace('#', '');\n    element = document.getElementById(id);\n    if (element === null && hashFragment === '#top') {\n      // see above comment for why document.body instead of document.documentElement\n      element = document.body;\n    }\n  }\n\n  if (element !== null) {\n    scrollFunction(element);\n\n    // update focus to where the page is scrolled to\n    // unfortunately this doesn't work in safari (desktop and iOS) when blur() is called\n    let originalTabIndex = element.getAttribute('tabindex');\n    if (originalTabIndex === null && !isInteractiveElement(element)) {\n      element.setAttribute('tabindex', -1);\n    }\n    element.focus({ preventScroll: true });\n    if (originalTabIndex === null && !isInteractiveElement(element)) {\n      // for some reason calling blur() in safari resets the focus region to where it was previously,\n      // if blur() is not called it works in safari, but then are stuck with default focus styles\n      // on an element that otherwise might never had focus styles applied, so not an option\n      element.blur();\n      element.removeAttribute('tabindex');\n    }\n\n    reset();\n    return true;\n  }\n  return false;\n}\n\nfunction hashLinkScroll(timeout) {\n  // Push onto callback queue so it runs after the DOM is updated\n  window.setTimeout(() => {\n    if (getElAndScroll() === false) {\n      if (observer === null) {\n        observer = new MutationObserver(getElAndScroll);\n      }\n      observer.observe(document, {\n        attributes: true,\n        childList: true,\n        subtree: true,\n      });\n      // if the element doesn't show up in specified timeout or 10 seconds, stop checking\n      asyncTimerId = window.setTimeout(() => {\n        reset();\n      }, timeout || 10000);\n    }\n  }, 0);\n}\n\nexport function genericHashLink(As) {\n  return React.forwardRef((props, ref) => {\n    let linkHash = '';\n    if (typeof props.to === 'string' && props.to.includes('#')) {\n      linkHash = `#${props.to.split('#').slice(1).join('#')}`;\n    } else if (\n      typeof props.to === 'object' &&\n      typeof props.to.hash === 'string'\n    ) {\n      linkHash = props.to.hash;\n    }\n\n    const passDownProps = {};\n    if (As === NavLink) {\n      passDownProps.isActive = (match, location) =>\n        match && match.isExact && location.hash === linkHash;\n    }\n\n    function handleClick(e) {\n      reset();\n      hashFragment = props.elementId ? `#${props.elementId}` : linkHash;\n      if (props.onClick) props.onClick(e);\n      if (\n        hashFragment !== '' &&\n        // ignore non-vanilla click events, same as react-router\n        // below logic adapted from react-router: https://github.com/ReactTraining/react-router/blob/fc91700e08df8147bd2bb1be19a299cbb14dbcaa/packages/react-router-dom/modules/Link.js#L43-L48\n        !e.defaultPrevented && // onClick prevented default\n        e.button === 0 && // ignore everything but left clicks\n        (!props.target || props.target === '_self') && // let browser handle \"target=_blank\" etc\n        !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) // ignore clicks with modifier keys\n      ) {\n        scrollFunction =\n          props.scroll ||\n          ((el) =>\n            props.smooth\n              ? el.scrollIntoView({ behavior: 'smooth' })\n              : el.scrollIntoView());\n        hashLinkScroll(props.timeout);\n      }\n    }\n    const { scroll, smooth, timeout, elementId, ...filteredProps } = props;\n    return (\n      <As {...passDownProps} {...filteredProps} onClick={handleClick} ref={ref}>\n        {props.children}\n      </As>\n    );\n  });\n}\n\nexport const HashLink = genericHashLink(Link);\n\nexport const NavHashLink = genericHashLink(NavLink);\n\nif (process.env.NODE_ENV !== 'production') {\n  HashLink.displayName = 'HashLink';\n  NavHashLink.displayName = 'NavHashLink';\n\n  const propTypes = {\n    onClick: PropTypes.func,\n    children: PropTypes.node,\n    scroll: PropTypes.func,\n    timeout: PropTypes.number,\n    elementId: PropTypes.string,\n    to: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  };\n\n  HashLink.propTypes = propTypes;\n  NavHashLink.propTypes = propTypes;\n}\n"],"names":["_ref","annotation","fontSize","props","paddingBottom","_jsxs","style","position","children","_jsx","src","type","className","bottom","left","backgroundColor","width","textAlign","padding","useBreakpoint","Grid","Home","screens","ProjectPage","title","Meta","thumb","teaser","githubURL","projectLink","id","objectFit","autoPlay","loop","muted","shimenawa","Carousel","autoplay","autoplaySpeed","effect","margin","maxWidth","AnnotatedImage","meiji","sakurayama","unknownTakayama","fushimiInari1","fushimiInari2","Divider","borderTopWidth","borderTopColor","opacity","day","sunset","night","href","target","aspectRatio","height","frameborder","allowfullscreen","Latex","SyntaxHighlighter","language","showLineNumbers","dracula","startingLineNumber","depthMap","AnnotatedVideo","domainWarp","ropeSdfWarp","ropeSdf0Coil","ropeSdf1Coil","ropeSdf2Coil","ropeSdfComplete","HashLink","smooth","to","ropeOvershoot","paddingLeft","paddingRight","Row","display","Col","flex","sphereDomainRep","sphereDomainRepRad","domainRepShimenawa","domainRepBridges","domainRepPillars","sm","ropeNormals","hardShadows","softShadows","noAO","noAOlambertian","aoLambertian","shadowColMult","shadowColConstMix","shadowColAmbientMix","rel","shadowRamped","shadowRampedBright","Image","projectRoute","loc","useLocation","pathname","useEffect","window","scrollTo","_Fragment","marginTop","backgroundImage","concat","backgroundPosition","backgroundSize","backgroundRepeat","zIndex","top","transform","undefined","Tooltip","placement","GithubOutlined","Link","SendOutlined","getNestedHeadings","headingElements","headingAttention","filter","e","l","nodeName","ki","headingLst","map","key","innerHTML","level","parseInt","slice","result","indices","levels","forEach","o","index","findIndex","push","length","Object","assign","nestedHeadings","useHeadingsData","setNestedHeadings","useState","Array","from","document","querySelectorAll","newNestedHeadings","navHeight","useNavHeight","setNavHeight","navbar","getElementById","console","log","offsetHeight","anchorHeight","setAnchorHeight","breadcrumbRef","Breadcrumb","items","Anchor","maxHeight","overflow","targetOffset","onClick","preventDefault","footer","FadeIn","HomeTemplate","gutter","xs","lg","TableOfContents","marginRight","marginLeft","justifyContent","marginBottom","__assign","t","s","i","n","arguments","p","prototype","hasOwnProperty","call","apply","this","hashFragment","observer","asyncTimerId","scrollFunction","reset","disconnect","clearTimeout","isInteractiveElement","element","includes","tagName","hasAttribute","getElAndScroll","body","replace","originalTabIndex","getAttribute","setAttribute","focus","preventScroll","blur","removeAttribute","genericHashLink","As","React","ref","linkHash","split","join","hash","passDownProps","NavLink","isActive","match","location","isExact","filteredProps","indexOf","getOwnPropertySymbols","propertyIsEnumerable","__rest","timeout","elementId","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","scroll","el","scrollIntoView","behavior","setTimeout","MutationObserver","observe","attributes","childList","subtree"],"sourceRoot":""}