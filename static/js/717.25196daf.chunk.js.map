{"version":3,"file":"static/js/717.25196daf.chunk.js","mappings":"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","sources":["projects/Webgl-Canny/src/imageUploader.jsx","projects/Webgl-Canny/src/threeImagePlane.jsx","projects/Webgl-Canny/src/shaders/shaders.jsx","projects/Webgl-Canny/src/shaders/grayscalePass.js","projects/Webgl-Canny/src/shaders/horizontalBlurPass.js","projects/Webgl-Canny/src/shaders/verticalBlurPass.js","projects/Webgl-Canny/src/shaders/gpuComputePass.js","projects/Webgl-Canny/src/shaders/copyStrongPass.js","projects/Webgl-Canny/src/shaders/sobelPass.js","projects/Webgl-Canny/src/shaders/hysteresisPass.js","projects/Webgl-Canny/src/shaders/getComputationRenderers.jsx","projects/Webgl-Canny/src/gaussianKernel.jsx","projects/Webgl-Canny/src/steps.jsx","projects/Webgl-Canny/src/main.jsx"],"sourcesContent":["import React, { useState } from 'react'\r\nimport { message, Upload } from 'antd'\r\nimport { InboxOutlined, LoadingOutlined } from '@ant-design/icons';\r\nconst { Dragger } = Upload;\r\n\r\nconst UploadIcon = ({loading}) => {\r\n    return (\r\n        loading ? <LoadingOutlined spin /> : <InboxOutlined />\r\n    )\r\n}\r\n\r\nconst ImageUploader = ({onLoadCallback, style}) => {\r\n\r\n    const [loadingImage, setLoadingImage] = useState(false);\r\n\r\n    // Load image from the uploaded file.\r\n    // Antd usually expects an API call for uploading files, so this works the same way as an API call.\r\n    const loadImageLocally = async ({ file, onSuccess }) => {\r\n\r\n        new Promise(resolve => {\r\n\r\n            setTimeout(() => {\r\n\r\n                let src = URL.createObjectURL(file);\r\n                let img = new Image();\r\n                img.onload = () => {\r\n                    resolve({src: src, dim: {width: img.width, height: img.height}})\r\n                }\r\n                img.src = src;\r\n\r\n            }, 30);\r\n        }).then(data => onSuccess(data));\r\n    }\r\n\r\n    // Handle status of uploading file from antd component.\r\n    const handleChange = info => {\r\n        if (info.file.status === \"uploading\") {\r\n            setLoadingImage(true);\r\n        } else if (info.file.status === \"done\") {\r\n            setLoadingImage(false);\r\n            onLoadCallback(info.file.response);\r\n        } else {\r\n            setLoadingImage(false);\r\n            console.log(info.file.status);\r\n        }\r\n    }\r\n\r\n    const validateUpload = file => {\r\n        // TODO: I *think* more than these file formats can be handled as well, but they should be tested individually to check.\r\n        const validFormat = (\r\n            file.type === \"image/png\" || file.type ===\"image/jpeg\"\r\n        );\r\n        if (!validFormat) {\r\n            message.error(\"Only PNG/JPEG files are supported.\")\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    return (\r\n        <Dragger style={style}\r\n            name=\"source-image\"\r\n            multiple={false}\r\n            listType=\"picture-card\"\r\n            className=\"src-img-uploader\"\r\n            showUploadList={false}\r\n            customRequest={loadImageLocally}\r\n            beforeUpload={validateUpload}\r\n            onChange={handleChange}\r\n        >\r\n            <p className=\"ant-upload-drag-icon\">\r\n                <UploadIcon loading={loadingImage} />\r\n            </p>\r\n            <p className=\"ant-upload-text\">\r\n                {\"Click or drag an image to this area to begin\"}\r\n            </p>\r\n            <p className=\"ant-upload-hint\">\r\n                (large images may take a long time to process)\r\n            </p>\r\n        </Dragger>\r\n    );\r\n}\r\n\r\nexport default ImageUploader;","import React from 'react';\r\nimport { TextureLoader, LinearFilter } from 'three';\r\nimport { useLoader, useThree } from '@react-three/fiber';\r\n\r\n// Custom Three.js component - Image projected onto plane which fills the entirety of the viewport.\r\n\r\n// Calculates necessary width/height to be projected fully (factor = 1) onto threejs camera.\r\nconst useAspect = (width, height, factor = 1) => {\r\n    const { viewport: v, aspect } = useThree();\r\n    const adaptedHeight = height * (aspect > width / height ? v.width / width : v.height / height);\r\n    const adaptedWidth = width * (aspect > width / height ? v.width / width : v.height / height);\r\n    return [adaptedWidth * factor, adaptedHeight * factor, 1];\r\n}\r\n\r\nconst ThreeImagePlane = ({img, dim}) => {\r\n\r\n    const image = useLoader(TextureLoader, img);\r\n    // Use a linear filter to avoid sharp edges in the preview from the camera.\r\n    image.minFilter = LinearFilter;\r\n\r\n\r\n    const [width, height] = useAspect(dim.width, dim.height);\r\n\r\n    return (\r\n        <mesh scale={[width, height, 1]}>\r\n            <planeGeometry attach=\"geometry\"/>\r\n            <meshBasicMaterial attach=\"material\" map={image} depthTest={false} toneMapped={false}/>\r\n        </mesh>\r\n    )\r\n}\r\n\r\nexport default ThreeImagePlane;","import { Vector3, Vector2 } from 'three';\r\n\r\n// Fragment and vertex shaders for postprocessing passes.\r\n\r\nconst GrayscaleShader = {\r\n\r\n\tuniforms: {\r\n\t\t'tDiffuse': { value: null },\r\n        'weights': { value: new Vector3() }\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\t\tvarying vec2 vUv;\r\n\t\tvoid main() {\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\t\tuniform float opacity;\r\n\t\tuniform sampler2D tDiffuse;\r\n        uniform vec3 weights;\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\t\t\tvec4 texel = pow(texture2D( tDiffuse, vUv ), vec4(1.0 / 2.2));\r\n            float w_a = weights.x * texel.x + weights.y * texel.y + weights.z * texel.z;\r\n\t\t\tgl_FragColor = vec4(w_a, w_a, w_a, 1.0);\r\n            //gl_FragColor = vec4(texel.rgba);\r\n\t\t}`\r\n\r\n};\r\n\r\nconst hGaussianBlur = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'kernelSize': { value: 0 },\r\n        'kernel': { value: new Array(128) },\r\n        'hRes': { value: 0.0 }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n        uniform float hRes;\r\n        uniform int kernelSize;\r\n        uniform float kernel[128];\r\n        uniform sampler2D tDiffuse;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n            \r\n            if (hRes > 0.0) {\r\n                vec4 color = texture2D(tDiffuse, vUv) * kernel[0];\r\n    \r\n                for (int i=1; i < 128; i++) {\r\n                    if (i == kernelSize) break;\r\n                    color += texture2D(tDiffuse, vUv + vec2(float(i)/hRes, 0.0)) * kernel[i];\r\n                    color += texture2D(tDiffuse, vUv - vec2(float(i)/hRes, 0.0)) * kernel[i];\r\n                }\r\n    \r\n                gl_FragColor = color;\r\n            }\r\n        }`\r\n};\r\n\r\nconst vGaussianBlur = { \r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'kernelSize': { value: 0 },\r\n        'kernel': { value: new Array(128) },\r\n        'vRes': { value: 0.0 }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`            \r\n        uniform float vRes;\r\n        uniform int kernelSize;\r\n        uniform float kernel[128];\r\n        uniform sampler2D tDiffuse;\r\n        \r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            if (vRes > 0.0) {\r\n                vec4 color = texture2D(tDiffuse, vUv) * kernel[0];\r\n    \r\n                for (int i=1; i < 128; i++) {\r\n                    if (i == kernelSize) break;\r\n                    color += texture2D(tDiffuse, vUv + vec2(0.0, float(i)/vRes)) * kernel[i];\r\n                    color += texture2D(tDiffuse, vUv - vec2(0.0, float(i)/vRes)) * kernel[i];\r\n                }\r\n    \r\n                gl_FragColor = color;\r\n            }\r\n        }`\r\n\r\n};\r\n\r\nconst sobelShader = {\r\n    \r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'dim': { value: new Vector2() },\r\n        'GX': { value: new Array(9) },\r\n        'GY': { value: new Array(9) }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform vec2 dim;\r\n        uniform float GX[9];\r\n        uniform float GY[9];\r\n        uniform sampler2D tDiffuse;\r\n\r\n        void main() {\r\n            \r\n            vec4 gx = vec4(0.0);\r\n            vec4 gy = vec4(0.0);\r\n            vec4 v;\r\n\r\n            for (int j=0; j<3; j++) {\r\n                for (int i=0; i<3; i++) {\r\n                    v = texture2D(tDiffuse, vec2(gl_FragCoord.x/dim.x, gl_FragCoord.y/dim.y) + vec2( float(i-1)/dim.x, float(j-1)/dim.y ) );\r\n                    gx += GX[j * 3 + i] * v;\r\n                    gy += GY[j * 3 + i] * v;\r\n                }\r\n            }\r\n\r\n            vec4 mag = sqrt(gx * gx + gy * gy);\r\n            float arg = atan(gy.x, gx.x);\r\n\r\n\r\n            gl_FragColor = vec4(mag.x, mag.y, mag.z, 1.0);\r\n        }`\r\n}\r\n\r\nconst gradientMagnitudeFragShader = `\r\n    precision highp float;\r\n\r\n    uniform vec2 dim;\r\n    uniform float GX[9];\r\n    uniform float GY[9];\r\n    uniform sampler2D tDiffuse;\r\n\r\n    void main() {\r\n        \r\n        vec4 gx = vec4(0.0);\r\n        vec4 gy = vec4(0.0);\r\n        vec4 v;\r\n\r\n        for (int j=0; j<3; j++) {\r\n            for (int i=0; i<3; i++) {\r\n                v = texture2D(tDiffuse, vec2(gl_FragCoord.x/dim.x, gl_FragCoord.y/dim.y) + vec2( float(i-1)/dim.x, float(j-1)/dim.y ) );\r\n                gx += GX[j * 3 + i] * v;\r\n                gy += GY[j * 3 + i] * v;\r\n            }\r\n        }\r\n\r\n        vec4 mag = sqrt(gx * gx + gy * gy);\r\n        gl_FragColor = vec4(mag.x, mag.y, mag.z, 1.0);\r\n    }`\r\n\r\nconst gradientArgumentFragShader = `\r\n    precision highp float;\r\n\r\n    uniform vec2 dim;\r\n    uniform float GX[9];\r\n    uniform float GY[9];\r\n    uniform sampler2D tDiffuse;\r\n\r\n    void main() {\r\n        \r\n        vec4 gx = vec4(0.0);\r\n        vec4 gy = vec4(0.0);\r\n        vec4 v;\r\n\r\n        for (int j=0; j<3; j++) {\r\n            for (int i=0; i<3; i++) {\r\n                v = texture2D(tDiffuse, vec2(gl_FragCoord.x/dim.x, gl_FragCoord.y/dim.y) + vec2( float(i-1)/dim.x, float(j-1)/dim.y ) );\r\n                gx += GX[j * 3 + i] * v;\r\n                gy += GY[j * 3 + i] * v;\r\n            }\r\n        }\r\n\r\n        vec4 mag = sqrt(gx * gx + gy * gy);\r\n        float arg = atan(gy.x, gx.x);\r\n\r\n        gl_FragColor = vec4(arg, arg, arg, arg);\r\n    }`\r\n\r\nconst normalizeShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'max': { value : 1.0 }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDiffuse;\r\n        uniform float max;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            float v = texture2D(tDiffuse, vUv).x;\r\n            float norm = v / max;\r\n\r\n            gl_FragColor = vec4(norm, norm, norm, 1.0);\r\n\r\n        }`\r\n\r\n}\r\n\r\nconst nmsFragShader = `\r\n\r\n    uniform sampler2D tMags;\r\n    uniform sampler2D tArgs;\r\n    uniform vec2 dim;\r\n\r\n    void main() {\r\n        \r\n        vec2 current = vec2(gl_FragCoord.x/dim.x, gl_FragCoord.y/dim.y);\r\n\r\n        float m = texture2D(tMags, current).x;\r\n        float a = texture2D(tArgs, current).x;\r\n\r\n        float hComp = cos(a);\r\n        float vComp = sin(a);\r\n        float xTranslate = sign(hComp);\r\n        float yTranslate = sign(vComp);\r\n\r\n        vec2 translate = vec2(xTranslate/dim.x, yTranslate/dim.y);\r\n        vec2 a1 = current + translate;\r\n        vec2 a2 = current - translate;\r\n        float ag1 = texture2D(tMags, a1).x;\r\n        float ag2 = texture2D(tMags, a2).x;\r\n\r\n        vec2 b1, b2;\r\n        float bg1, bg2;\r\n\r\n        float g1, g2;\r\n\r\n        if (abs(hComp) > abs(vComp)) {\r\n            translate = vec2(xTranslate/dim.x, 0.0);\r\n            b1 = current + vec2(translate);\r\n            b2 = current - vec2(translate);\r\n            bg1 = texture2D(tMags, b1).x;\r\n            bg2 = texture2D(tMags, b2).x;\r\n            g1 = ag1 * abs(vComp) + (1.0-abs(vComp)) * bg1;\r\n            g2 = ag2 * abs(vComp) + (1.0-abs(vComp)) * bg2;\r\n        }\r\n        else {\r\n            translate = vec2(0.0, yTranslate/dim.y);\r\n            b1 = current + vec2(translate);\r\n            b2 = current - vec2(translate);\r\n            bg1 = texture2D(tMags, b1).x;\r\n            bg2 = texture2D(tMags, b2).x;\r\n            g1 = ag1 * abs(hComp) + (1.0-abs(hComp)) * bg1;\r\n            g2 = ag2 * abs(hComp) + (1.0-abs(hComp)) * bg2;\r\n        }\r\n\r\n        if (g1 > m || g2 > m) {\r\n            m = 0.0;\r\n        }\r\n\r\n        gl_FragColor = vec4(m, m, m, 1.0);\r\n\r\n    }`\r\n\r\nconst thresholdShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'max': { value : 1.0 },\r\n        'high': { value: 0.0},\r\n        'low': { value: 0.0}\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDiffuse;\r\n        uniform float max;\r\n        uniform float high;\r\n        uniform float low;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            float v = texture2D(tDiffuse, vUv).x;\r\n\r\n            vec4 texel;\r\n            if (v <= low) {\r\n                texel = vec4(0.0, 0.0, 0.0, 1.0);\r\n            } else if (v < high) {\r\n                texel = vec4(0.3, 0.3, 0.3, 1.0);\r\n            } else {\r\n                texel = vec4(1.0);\r\n            }\r\n\r\n            gl_FragColor = texel;\r\n\r\n        }`\r\n\r\n}\r\n\r\nconst dilationShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'dims': { value : new Vector2() },\r\n        'tolerance': { value: 1.0 },\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDiffuse;\r\n        uniform vec2 dims;\r\n        uniform int tolerance;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n            \r\n            if (dims.x > 0.0 && dims.y > 0.0) {\r\n                // vec2 coord = vec2(gl_FragCoord.x/dims.x, gl_FragCoord.y/dims.y);\r\n                // float v = texture2D(tDiffuse, coord).x;\r\n                // if (v < 0.7) v = 0.0;\r\n\r\n                float v = 0.0;\r\n                for (int j = -tolerance; j <= tolerance; j++) {\r\n                    for (int i = -tolerance; i <= tolerance; i++) {\r\n                        \r\n                        vec2 coord = vec2(gl_FragCoord.x/dims.x, gl_FragCoord.y/dims.y) + vec2( float(i)/dims.x, float(j)/dims.y );\r\n    \r\n                        if ( texture2D(tDiffuse, coord).x > 0.7) {\r\n    \r\n                            v = 1.0;\r\n                            break;\r\n    \r\n                        }\r\n    \r\n                    }\r\n                }\r\n    \r\n                gl_FragColor = vec4(v, v, v, 1.0);\r\n            }\r\n        }`\r\n\r\n}\r\n\r\nconst hysteresisCombineShader = {\r\n\r\n    uniforms: {\r\n        'tDilate': { value: null },\r\n        'tDiffuse': { value: null },\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDilate;\r\n        uniform sampler2D tDiffuse;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            float dilate = texture2D(tDilate, vUv).x;\r\n            float weak = texture2D(tDiffuse, vUv).x;\r\n\r\n            if (weak < 1.0 && weak > 0.0 && dilate > 0.3) {\r\n                weak = 1.0;\r\n            }\r\n\r\n            gl_FragColor = vec4(weak, weak, weak, 1.0);\r\n        }`\r\n\r\n}\r\n\r\nconst copyStrongShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'dims': { value: new Vector2() }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDiffuse;\r\n        uniform vec2 dims;\r\n\r\n        void main() {\r\n\r\n            vec2 coord = vec2(gl_FragCoord.x/dims.x, gl_FragCoord.y/dims.y);\r\n\r\n            float v = texture2D(tDiffuse, coord).x;\r\n            if ( v <= 0.7 ) {\r\n                v = 0.0;\r\n            }\r\n\r\n            gl_FragColor = vec4(v, v, v, 1.0);\r\n\r\n        }`\r\n\r\n}\r\n\r\nconst copyShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDiffuse;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            gl_FragColor = texture2D(tDiffuse, vUv);\r\n\r\n        }`\r\n\r\n}\r\n\r\nexport { normalizeShader, GrayscaleShader, hGaussianBlur, vGaussianBlur, sobelShader, gradientMagnitudeFragShader, gradientArgumentFragShader, nmsFragShader, thresholdShader, copyStrongShader, copyShader, dilationShader, hysteresisCombineShader };","import { ShaderMaterial, Uniform, Vector3 } from 'three';\r\nimport { Pass } from 'postprocessing';\r\nimport { GrayscaleShader } from './shaders';\r\n\r\nlet _weights;\r\n\r\nclass GrayscaleShaderMaterial extends ShaderMaterial {\r\n\r\n    constructor ( weights ) {\r\n\r\n        super({\r\n            type: \"CustomMaterial\",\r\n            uniforms: {\r\n                tDiffuse: new Uniform(null),\r\n                weights: new Uniform(new Vector3())\r\n            },\r\n\r\n            fragmentShader: GrayscaleShader.fragmentShader,\r\n            vertexShader: GrayscaleShader.vertexShader,\r\n            toneMapped: false,\r\n            depthWrite: false,\r\n            depthTest: false\r\n        });\r\n        \r\n        _weights = weights;\r\n    }\r\n}\r\n\r\nexport class GrayscalePass extends Pass {\r\n    constructor(weights) {\r\n        super(\"GrayscalePass\")\r\n        this.fullscreenMaterial = new GrayscaleShaderMaterial(weights);\r\n    }\r\n\r\n    render( renderer, inputBuffer, outputBuffer, deltaTime, stencilTest ) {\r\n\r\n        const material = this.fullscreenMaterial;\r\n        material.uniforms[ 'tDiffuse' ].value = inputBuffer ? inputBuffer.texture : null;\r\n        material.uniforms[ 'weights' ].value = _weights\r\n\r\n        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\r\n        renderer.render(this.scene, this.camera);\r\n\r\n    }\r\n}","import { ShaderMaterial, Uniform } from 'three';\r\nimport { Pass } from 'postprocessing';\r\nimport { hGaussianBlur } from './shaders';\r\n\r\nlet _kernel, _kernelSize, _hRes;\r\n\r\nclass HorizontalBlurShaderMaterial extends ShaderMaterial {\r\n\r\n    constructor ( kernel, kernelSize, hRes ) {\r\n\r\n        super({\r\n            type: \"CustomMaterial\",\r\n            uniforms: {\r\n                tDiffuse: new Uniform(null),\r\n                kernelSize: new Uniform(0),\r\n                kernel: new Uniform([0]),\r\n                hRes: new Uniform(0)\r\n            },\r\n\r\n            fragmentShader: hGaussianBlur.fragmentShader,\r\n            vertexShader: hGaussianBlur.vertexShader,\r\n            toneMapped: false,\r\n            depthWrite: false,\r\n            depthTest: false\r\n        });\r\n        \r\n        _kernel = kernel;\r\n        _kernelSize = kernelSize;\r\n        _hRes = hRes;\r\n    }\r\n}\r\n\r\nexport class HorizontalBlurPass extends Pass {\r\n\r\n    constructor ( kernel, kernelSize, hRes ) {\r\n        super(\"HorizontalBlurPass\");\r\n        this.fullscreenMaterial = new HorizontalBlurShaderMaterial(kernel, kernelSize, hRes)\r\n    }\r\n\r\n    render( renderer, inputBuffer, outputBuffer, deltaTime, stencilTest ) {\r\n\r\n        const material = this.fullscreenMaterial;\r\n        material.uniforms[ 'tDiffuse' ].value = inputBuffer ? inputBuffer.texture : null;\r\n        material.uniforms[ 'kernel' ].value = _kernel;\r\n        material.uniforms[ 'kernelSize' ].value = _kernelSize;\r\n        material.uniforms[ 'hRes' ].value = _hRes;\r\n\r\n        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\r\n        renderer.render(this.scene, this.camera);\r\n\r\n    }\r\n\r\n}","import { ShaderMaterial, Uniform } from 'three';\r\nimport { Pass } from 'postprocessing';\r\nimport { vGaussianBlur } from './shaders';\r\n\r\nlet _kernel, _kernelSize, _vRes;\r\n\r\nclass VerticalBlurShaderMaterial extends ShaderMaterial {\r\n\r\n    constructor ( kernel, kernelSize, vRes ) {\r\n\r\n        super({\r\n            type: \"CustomMaterial\",\r\n            uniforms: {\r\n                tDiffuse: new Uniform(null),\r\n                kernelSize: new Uniform(0),\r\n                kernel: new Uniform([0]),\r\n                vRes: new Uniform(0)\r\n            },\r\n\r\n            fragmentShader: vGaussianBlur.fragmentShader,\r\n            vertexShader: vGaussianBlur.vertexShader,\r\n            toneMapped: false,\r\n            depthWrite: false,\r\n            depthTest: false\r\n        });\r\n        \r\n        _kernel = kernel;\r\n        _kernelSize = kernelSize;\r\n        _vRes = vRes;\r\n    }\r\n}\r\n\r\nexport class VerticalBlurPass extends Pass {\r\n\r\n    constructor ( kernel, kernelSize, hRes ) {\r\n        super(\"VerticalBlurPass\");\r\n        this.fullscreenMaterial = new VerticalBlurShaderMaterial(kernel, kernelSize, hRes)\r\n    }\r\n\r\n    render( renderer, inputBuffer, outputBuffer, deltaTime, stencilTest ) {\r\n\r\n        const material = this.fullscreenMaterial;\r\n        material.uniforms[ 'tDiffuse' ].value = inputBuffer ? inputBuffer.texture : null;\r\n        material.uniforms[ 'kernel' ].value = _kernel;\r\n        material.uniforms[ 'kernelSize' ].value = _kernelSize;\r\n        material.uniforms[ 'vRes' ].value = _vRes;\r\n\r\n        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\r\n        renderer.render(this.scene, this.camera);\r\n\r\n    }\r\n\r\n}","import { ShaderMaterial, Uniform } from 'three';\r\nimport { Pass } from 'postprocessing';\r\nimport { normalizeShader, thresholdShader } from './shaders';\r\n\r\nlet _thresh_max, _thresh_high, _thresh_low;\r\nclass ThresholdShaderMaterial extends ShaderMaterial {\r\n\r\n    constructor ( max, high, low ) {\r\n        super({\r\n            type: \"CustomMaterial\",\r\n            uniforms: {\r\n                tDiffuse: new Uniform(null),\r\n                max: new Uniform(0),\r\n                high: new Uniform(0),\r\n                low: new Uniform(0),\r\n            },\r\n\r\n            fragmentShader: thresholdShader.fragmentShader,\r\n            vertexShader: thresholdShader.vertexShader,\r\n            toneMapped: false,\r\n            depthWrite: false,\r\n            depthTest: false\r\n        });\r\n        \r\n        _thresh_max = max;\r\n        _thresh_high = high;\r\n        _thresh_low = low;\r\n    }\r\n    \r\n}\r\n\r\nclass NormShaderMaterial extends ShaderMaterial {\r\n\r\n    constructor () {\r\n        super({\r\n            type: \"CustomMaterial\",\r\n            uniforms: {\r\n                tDiffuse: new Uniform(null),\r\n                max: new Uniform(0)\r\n            },\r\n\r\n            fragmentShader: normalizeShader.fragmentShader,\r\n            vertexShader: normalizeShader.vertexShader,\r\n            toneMapped: false,\r\n            depthWrite: false,\r\n            depthTest: false\r\n        });\r\n    }\r\n    \r\n}\r\n\r\n// Combines passes for Sobel operator onwards due to dependency on calculated information\r\nexport class GpuComputePass extends Pass {\r\n\r\n    constructor ( sobelParams, nmsParams, dim, doNMS, threshold ) {\r\n        super(\"GpuComputePass\");\r\n\r\n        this.doNMS = doNMS;\r\n        this.threshold = threshold;\r\n\r\n        this._normShaderMaterial = new NormShaderMaterial();\r\n        if (threshold) this._thresholdShaderMaterial = new ThresholdShaderMaterial();\r\n        \r\n        this.dims = dim;\r\n\r\n        this.sobelGpuCompute = sobelParams.gpuCompute;\r\n        this.magnitudeVariable = sobelParams.magnitudeVariable;\r\n        this.magnitudeUniforms = sobelParams.magnitudeUniforms;\r\n        this.argumentVariable = sobelParams.argumentVariable;\r\n        this.argumentUniforms = sobelParams.argumentUniforms;\r\n\r\n        if (doNMS) {\r\n            this.nmsGpuCompute = nmsParams.nmsGpuCompute;\r\n            this.nmsVariable = nmsParams.nmsVariable;\r\n            this.nmsUniforms = nmsParams.nmsUniforms;\r\n        }\r\n    }\r\n\r\n    render( renderer, inputBuffer, outputBuffer, deltaTime, stencilTest ) {\r\n\r\n        // Compute gradient magnitudes and angles\r\n        this.magnitudeUniforms[ 'tDiffuse' ].value = inputBuffer.texture;\r\n        if ( this.doNMS ) this.argumentUniforms[ 'tDiffuse' ].value = inputBuffer.texture;\r\n\r\n        this.sobelGpuCompute.compute();\r\n\r\n        // Pass in shader uniforms depending on the process shader.\r\n        let renderTarget;\r\n        if ( this.doNMS ) {\r\n            this.nmsUniforms[ 'tMags' ].value = this.sobelGpuCompute.getCurrentRenderTarget( this.magnitudeVariable ).texture;\r\n            this.nmsUniforms[ 'tArgs' ].value = this.sobelGpuCompute.getCurrentRenderTarget( this.argumentVariable ).texture;\r\n            this.nmsUniforms[ 'dim' ].value = this.dims;\r\n            this.nmsGpuCompute.compute();\r\n\r\n            renderTarget = this.nmsGpuCompute.getCurrentRenderTarget( this.nmsVariable )\r\n\r\n        } else {\r\n            renderTarget = this.sobelGpuCompute.getCurrentRenderTarget( this.magnitudeVariable )\r\n        }\r\n        \r\n        // Calculate the max value uniform for the normalize shader.\r\n\r\n        let read = new Float32Array( 4 * this.dims[0] * this.dims[1]);\r\n        renderer.readRenderTargetPixels(renderTarget, 0, 0, this.dims[0], this.dims[1], read);\r\n\r\n        // O(N) CPU bound search for max\r\n        let max = 0.0;\r\n        for (let i = 0; i < read.length; i+=4) {\r\n            if (read[i] > max) max = read[i];\r\n        }\r\n        \r\n        // Render norm pass in the effects chain.\r\n        if ( this.renderToScreen && !this.threshold ) {\r\n            this.fullscreenMaterial = this._normShaderMaterial;\r\n            const normMaterial = this.fullscreenMaterial;\r\n            normMaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\r\n            normMaterial.uniforms[ 'max' ].value = Math.max(max, 0);\r\n\r\n            renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);\r\n            renderer.render(this.scene, this.camera);\r\n        }\r\n\r\n        // Render threshold pass in the effects chain.\r\n        if ( this.threshold ) {\r\n            \r\n            let hi = this.threshold.high * max;\r\n\r\n            this.fullscreenMaterial = this._thresholdShaderMaterial;\r\n            const threshMaterial = this.fullscreenMaterial;\r\n            \r\n            threshMaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\r\n            threshMaterial.uniforms[ 'max' ].value = max;\r\n            threshMaterial.uniforms[ 'high' ].value = hi;\r\n            threshMaterial.uniforms[ 'low' ].value = this.threshold.low * hi;\r\n\r\n            renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\r\n            renderer.render(this.scene, this.camera);    \r\n        }\r\n    }\r\n}","import { ShaderMaterial, Uniform, Vector2 } from 'three';\r\nimport { Pass } from 'postprocessing';\r\nimport { copyStrongShader } from './shaders';\r\n\r\nlet _dims;\r\n\r\nclass CopyStrongShadermaterial extends ShaderMaterial {\r\n\r\n    constructor ( dims ) {\r\n\r\n        super({\r\n            type: \"CustomMaterial\",\r\n            uniforms: {\r\n                tDiffuse: new Uniform(null),\r\n                dims: new Uniform(new Vector2())\r\n            },\r\n\r\n            fragmentShader: copyStrongShader.fragmentShader,\r\n            vertexShader: copyStrongShader.vertexShader,\r\n            toneMapped: false,\r\n            depthWrite: false,\r\n            depthTest: false\r\n        });\r\n        \r\n        _dims = dims;\r\n    }\r\n}\r\n\r\nexport class CopyStrongPass extends Pass {\r\n\r\n    constructor ( dims ) {\r\n        super(\"CopyStrongPass\");\r\n        this.fullscreenMaterial = new CopyStrongShadermaterial(dims)\r\n    }\r\n\r\n    render( renderer, inputBuffer, outputBuffer, deltaTime, stencilTest ) {\r\n\r\n        const material = this.fullscreenMaterial;\r\n        material.uniforms[ 'tDiffuse' ].value = inputBuffer ? inputBuffer.texture : null;\r\n        material.uniforms[ 'dims' ].value = _dims;\r\n\r\n        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\r\n        renderer.render(this.scene, this.camera);\r\n\r\n    }\r\n\r\n}","import { ShaderMaterial, Uniform, Vector2 } from 'three';\r\nimport { Pass } from 'postprocessing';\r\nimport { sobelShader } from './shaders';\r\n\r\nlet _gx, _gy, _dim;\r\n\r\nclass SobelShaderMaterial extends ShaderMaterial {\r\n\r\n    constructor ( gx, gy, dim ) {\r\n\r\n        super({\r\n            type: \"CustomMaterial\",\r\n            uniforms: {\r\n                tDiffuse: new Uniform(null),\r\n                gx: new Uniform(0),\r\n                gy: new Uniform(0),\r\n                dim: new Uniform(new Vector2()),\r\n            },\r\n\r\n            fragmentShader: sobelShader.fragmentShader,\r\n            vertexShader: sobelShader.vertexShader,\r\n            toneMapped: false,\r\n            depthWrite: false,\r\n            depthTest: false\r\n        });\r\n        \r\n        _gx = gx;\r\n        _gy = gy;\r\n        _dim = dim;\r\n    }\r\n}\r\n\r\nexport class SobelPass extends Pass {\r\n\r\n    constructor ( gx, gy, dim ) {\r\n        super(\"SobelPass\");\r\n        this.fullscreenMaterial = new SobelShaderMaterial(gx, gy, dim)\r\n    }\r\n\r\n    render( renderer, inputBuffer, outputBuffer, deltaTime, stencilTest ) {\r\n\r\n        const material = this.fullscreenMaterial;\r\n        material.uniforms[ 'tDiffuse' ].value = inputBuffer ? inputBuffer.texture : null;\r\n        material.uniforms[ 'gx' ].value = _gx;\r\n        material.uniforms[ 'gy' ].value = _gy;\r\n        material.uniforms[ 'dim' ].value = _dim;\r\n\r\n        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\r\n        renderer.render(this.scene, this.camera);\r\n\r\n    }\r\n\r\n}","import { ShaderMaterial, Uniform, Vector2 } from 'three';\r\nimport { Pass } from 'postprocessing';\r\nimport { copyShader, dilationShader, hysteresisCombineShader } from './shaders';\r\n\r\nclass CopyShaderMaterial extends ShaderMaterial {\r\n\r\n    constructor () {\r\n\r\n        super({\r\n            type: \"CustomMaterial\",\r\n            uniforms: {\r\n                tDiffuse: new Uniform(null)\r\n            },\r\n\r\n            fragmentShader: copyShader.fragmentShader,\r\n            vertexShader: copyShader.vertexShader,\r\n            toneMapped: false,\r\n            depthWrite: false,\r\n            depthTest: false\r\n        });\r\n    }\r\n}\r\n\r\nclass DilationShaderMaterial extends ShaderMaterial {\r\n\r\n    constructor ( dims, tolerance ) {\r\n\r\n        super({\r\n            type: \"CustomMaterial\",\r\n            uniforms: {\r\n                tDiffuse: new Uniform(null),\r\n                dims: new Uniform(dims),\r\n                tolerance: new Uniform(tolerance)\r\n            },\r\n\r\n            fragmentShader: dilationShader.fragmentShader,\r\n            vertexShader: dilationShader.vertexShader,\r\n            toneMapped: false,\r\n            depthWrite: false,\r\n            depthTest: false\r\n        });\r\n    }\r\n}\r\n\r\nclass HysteresisShaderMaterial extends ShaderMaterial {\r\n\r\n    constructor() {\r\n\r\n        super({\r\n            type: \"CustomMaterial\",\r\n            uniforms: {\r\n                tDilate: new Uniform(null),\r\n                tDiffuse: new Uniform(null)\r\n            },\r\n\r\n            fragmentShader: hysteresisCombineShader.fragmentShader,\r\n            vertexShader: hysteresisCombineShader.vertexShader,\r\n            toneMapped: false,\r\n            depthWrite: false,\r\n            depthTest: false\r\n        });\r\n    }\r\n}\r\n\r\nexport class HysteresisPass extends Pass {\r\n\r\n    constructor ( tolerance, iterations, renderTarget, dims ) {\r\n        super(\"HysteresisPass\");\r\n\r\n        this.iterations = iterations;\r\n\r\n        if (iterations == 0) this.copyMaterial = new CopyShaderMaterial();\r\n        this.dilationMaterial = new DilationShaderMaterial(dims, tolerance);\r\n        this.hysMaterial = new HysteresisShaderMaterial();\r\n    }\r\n\r\n    render( renderer, inputBuffer, outputBuffer, deltaTime, stencilTest ) {\r\n\r\n        // This is very inefficient... too bad!\r\n        this.intermediateRt = outputBuffer.clone();\r\n\r\n        if (this.iterations == 0) {\r\n\r\n            this.fullscreenMaterial = this.copyMaterial;\r\n            const copyMaterial = this.fullscreenMaterial;\r\n            copyMaterial.uniforms[ 'tDiffuse' ].value = inputBuffer.texture;\r\n            \r\n            renderer.setRenderTarget(null);\r\n            renderer.render(this.scene, this.camera);\r\n\r\n        } else {\r\n\r\n            this.hysMaterial.uniforms[ 'tDiffuse' ].value = inputBuffer.texture;\r\n\r\n            for (let i = 0; i < this.iterations; i++) {\r\n                this.dilationMaterial.uniforms[ 'tDiffuse' ].value = i == 0 ? inputBuffer.texture : outputBuffer.texture;\r\n    \r\n                this.fullscreenMaterial = this.dilationMaterial;\r\n                renderer.setRenderTarget(this.intermediateRt);\r\n                if (this.clear) renderer.clear();\r\n                renderer.render(this.scene, this.camera);\r\n\r\n                this.hysMaterial.uniforms[ 'tDilate' ].value = this.intermediateRt.texture;\r\n\r\n                this.fullscreenMaterial = this.hysMaterial;\r\n                if ( i == this.iterations - 1  && this.renderToScreen ) {\r\n    \r\n                    renderer.setRenderTarget(null);\r\n                    renderer.render(this.scene, this.camera);\r\n    \r\n                } else {\r\n    \r\n                    renderer.setRenderTarget(outputBuffer);\r\n                    renderer.render(this.scene, this.camera);\r\n    \r\n                }\r\n            }\r\n        }\r\n\r\n        this.intermediateRt.dispose();\r\n        delete this.intermediateRt;\r\n    }\r\n}","import { GPUComputationRenderer } from 'three/examples/jsm//misc/GPUComputationRenderer';\r\nimport { gradientMagnitudeFragShader, gradientArgumentFragShader, nmsFragShader} from \"./shaders\";\r\n\r\n// Helper func to init empty computation matrix as a texture.\r\nconst fillTextureWithZeros = (texture) => {\r\n    let arr = texture.image.data;\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        arr[i] = 0;\r\n    }\r\n}\r\n\r\nconst getSobelComputeRenderer = (gl, dims, kernel, doNMS) => {\r\n\r\n    let gpuCompute = new GPUComputationRenderer(dims[0], dims[1], gl);\r\n\r\n    let gradMagnitude = gpuCompute.createTexture();\r\n    fillTextureWithZeros( gradMagnitude );\r\n    let magnitudeVariable = gpuCompute.addVariable( 'textureMagnitude', gradientMagnitudeFragShader, gradMagnitude);\r\n\r\n    // Only compute arguments if we are doing NMS - otherwise only Mags are needed.\r\n    let argumentVariable;\r\n    let gradArgument;\r\n    if ( doNMS ) {\r\n\r\n        gradArgument = gpuCompute.createTexture();\r\n        fillTextureWithZeros( gradArgument );\r\n        argumentVariable = gpuCompute.addVariable( 'textureArgument', gradientArgumentFragShader, gradArgument);\r\n\r\n        gpuCompute.setVariableDependencies( magnitudeVariable, [ argumentVariable, magnitudeVariable ] );\r\n        gpuCompute.setVariableDependencies( argumentVariable, [ argumentVariable, magnitudeVariable ] );\r\n\r\n\r\n    } else {\r\n        \r\n        gpuCompute.setVariableDependencies( magnitudeVariable, [ magnitudeVariable ] );\r\n\r\n    }\r\n\r\n    let magnitudeUniforms = magnitudeVariable.material.uniforms;\r\n\r\n    magnitudeUniforms[ 'GX' ] = { value: kernel.gx }\r\n    magnitudeUniforms[ 'GY' ] = { value: kernel.gy }\r\n    magnitudeUniforms[ 'dim' ] = { value: dims }\r\n    magnitudeUniforms[ 'tDiffuse' ] = { value: null }\r\n\r\n\r\n    let argumentUniforms;\r\n    if ( doNMS ) {\r\n\r\n        argumentUniforms = argumentVariable.material.uniforms;\r\n\r\n        argumentUniforms[ 'GX' ] = { value: kernel.gx }\r\n        argumentUniforms[ 'GY' ] = { value: kernel.gy }\r\n        argumentUniforms[ 'dim' ] = { value: dims }\r\n        argumentUniforms[ 'tDiffuse' ] = { value: null }\r\n\r\n    }\r\n\r\n    const error = gpuCompute.init();\r\n\r\n    if (error !== null) {\r\n        console.error(error);\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        gpuCompute: gpuCompute,\r\n        magnitudeVariable: magnitudeVariable,\r\n        magnitudeUniforms, magnitudeUniforms,\r\n        argumentVariable: argumentVariable,\r\n        argumentUniforms: argumentUniforms,\r\n        texture: gradArgument,\r\n        texture_2: gradMagnitude\r\n    }\r\n}\r\n\r\nconst getNMSComputeRenderer = (gl, dims, doNMS) => {\r\n\r\n    // Don't necessarily want to init NMS renderer as sobel comes before NMS in canny steps. (Saves computation time).\r\n    if (!doNMS) return null;\r\n\r\n    let nmsGpuCompute = new GPUComputationRenderer(dims[0], dims[1], gl);\r\n\r\n    let nms = nmsGpuCompute.createTexture();\r\n    fillTextureWithZeros( nms );\r\n    let nmsVariable = nmsGpuCompute.addVariable( 'textureNms', nmsFragShader, nms );\r\n    \r\n    nmsGpuCompute.setVariableDependencies( nmsVariable, [nmsVariable] );\r\n\r\n    let nmsUniforms = nmsVariable.material.uniforms;\r\n    \r\n    nmsUniforms[ 'dim' ] = { value: dims }\r\n    nmsUniforms[ 'tMags' ] = { value: null }\r\n    nmsUniforms[ 'tArgs' ] = { value: null }\r\n\r\n    const error = nmsGpuCompute.init();\r\n\r\n    if (error !== null) { \r\n        console.error(error);\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        nmsGpuCompute: nmsGpuCompute,\r\n        nmsVariable: nmsVariable,\r\n        nmsUniforms: nmsUniforms,\r\n        textures: [nms]\r\n    }\r\n}\r\n\r\nconst getComputationRenderers = (gl, dims, kernel, doNMS) => {\r\n\r\n    let obj = {sobel: getSobelComputeRenderer(gl, dims, kernel, doNMS), nms: getNMSComputeRenderer(gl, dims, doNMS)};\r\n\r\n    return obj;\r\n}\r\n\r\n\r\nexport default getComputationRenderers;","// Truncate the kernel as it is symmetrical - half of this data is irrelevant.\r\nconst getSeparableKernel = (r, sigma) => {\r\n\r\n    // console.log(\"generated kernel\")\r\n\r\n    let sum = 0;\r\n    let arr = [];\r\n    let coefficient = 1/(Math.sqrt(2 * Math.PI) * sigma);\r\n    let exponent;\r\n    for (let i=0; i <= r; i++) {\r\n        exponent = Math.exp(-Math.pow(i, 2)/(2 * Math.pow(sigma, 2)))\r\n        arr[i] = coefficient * exponent;\r\n\r\n        // Kernel sum used in normalisation - account for the fact we only generate one half of the kernel:\r\n        sum += i === 0 ? arr[i] : 2 * arr[i];\r\n    }\r\n\r\n    // Normalise\r\n    for (let i = 0; i <= r; i++) {\r\n        arr[i] /= sum;\r\n    }\r\n\r\n    return arr;\r\n}\r\n\r\nexport {getSeparableKernel}","import { Canvas, extend, useFrame, useThree } from '@react-three/fiber';\r\nimport React, { useState, useRef, Suspense, useEffect } from 'react';\r\nimport FadeIn from 'react-fade-in';\r\nimport { Image, Slider, InputNumber, Button, Row, Col, Select, Spin } from 'antd';\r\nimport { ArrowLeftOutlined, LoadingOutlined } from '@ant-design/icons';\r\nimport ImageUploader from \"./imageUploader\";\r\nimport \"./main.scss\";\r\n\r\n// Shader-related imports\r\nimport ThreeImagePlane from \"./threeImagePlane\";\r\nimport { EffectComposer, RenderPass } from 'postprocessing';\r\nimport { GrayscalePass, HorizontalBlurPass, VerticalBlurPass, GpuComputePass, HysteresisPass, CopyStrongPass } from './shaders';\r\nimport getComputationRenderers from \"./shaders/getComputationRenderers\";\r\nimport { WebGLRenderTarget } from 'three';\r\n\r\nimport { getSeparableKernel } from \"./gaussianKernel\";\r\n\r\n// Make sure to extend shader components so they work with three-fiber\r\nextend({ EffectComposer })\r\n//extend({ GrayscalePass, HorizontalBlurPass, VerticalBlurPass, SobelPass, GpuComputePass, HysteresisPass, CopyStrongPass });\r\n\r\nconst { Option } = Select;\r\n\r\n// Constants used for parameter selection:\r\n\r\n// Grayscale r, g, b channel weightings.\r\nconst grayScaleCoefficients = {\r\n    \"BT.601\" : [0.299, 0.587, 0.114],\r\n    \"BT.709\" : [0.2126, 0.7152, 0.0722],\r\n    \"BT.2100\" : [0.2627, 0.6780, 0.0593],\r\n    \"Mean\" : [0.3333, 0.3333, 0.3333]\r\n}\r\n\r\n// Edge detection kernels.\r\nconst edgefindingOperators = {\r\n\r\n    \"sobel\" : {\r\n        gx: [\r\n            1, 0, -1,\r\n            2, 0, -2,\r\n            1, 0, -1\r\n        ],\r\n\r\n        gy: [\r\n            1, 2, 1,\r\n            0, 0, 0,\r\n            -1,-2,-1\r\n        ]\r\n    },\r\n\r\n    \"prewitt\" : {\r\n        gx: [\r\n            1, 0, -1,\r\n            1, 0, -1,\r\n            1, 0, -1\r\n        ],\r\n\r\n        gy: [\r\n            1, 1, 1,\r\n            0, 0, 0,\r\n            -1,-1,-1\r\n        ]\r\n    }\r\n\r\n}\r\n\r\n\r\nconst Steps = () => {\r\n\r\n    // Store the step in the canny process that is currently shown.\r\n    const maxStep = 7;\r\n    const [step, setStep] = useState(0);\r\n\r\n    // Set a ref to the container of the processed image so it can be centered.\r\n    const ImgContainerRef = useRef();\r\n    const [shaderDisplayDim, setDisplayDim] = useState({width: 0, height: 0});\r\n\r\n    // Data about the uploaded image (dimensions and pixel content).\r\n    const [imgDims, setImgDims] = useState(null);\r\n    const [imgSource, setImgSourceVar] = useState(null);\r\n\r\n    // Whether or not to display the image uploader.\r\n    const [uploadVisibility, setUploadVisibility] = useState(true);\r\n\r\n    const [intermediateRT, setIntermediateRT] = useState(null);\r\n\r\n    // Canny algorithm parameters.\r\n    const [selectedGrayscaleTag, setSelectedGrayscaleTag] = useState(\"BT.601\")\r\n    const [selectedGrayscaleEncoding, setSelectedGrayscaleEncoding] = useState(grayScaleCoefficients[selectedGrayscaleTag]);\r\n\r\n    const [gaussRadius, setGaussRadius] = useState(3);\r\n    const [gaussSigma, setGaussSigma] = useState(1);\r\n\r\n    const [selectedEdgeTag, setSelectedEdgeTag] = useState(\"sobel\")\r\n    const [selectedEdgeOperator, setSelectedEdgeOperator] = useState(edgefindingOperators[selectedEdgeTag])\r\n\r\n    const [lowThreshold, setLowThreshold] = useState(0.3);\r\n    const [highThreshold, setHighThreshold] = useState(0.3);\r\n\r\n    const [hysteresisTolerance, setTolerance] = useState(1);\r\n    const [hysteresisIters, setHysteresisIters] = useState(1);\r\n\r\n    // Memoization\r\n\r\n    // Setting up make-shift compute shaders is quite time costly hence the memoization\r\n    const [memoRenderers, setMemoRenderers] = useState(null);\r\n    const [memoRendererParams, setMemoRendererParams] = useState(null);\r\n\r\n    // Calculating gaussian kernel is quite fast but for larger kernels this will improve the framerate.\r\n    const [memoGaussParams, setMemoGaussParams] = useState(null);\r\n    const [memoGauss, setMemoGauss] = useState(null);\r\n\r\n    // WebGL reference for saving image (cannot be done through Canvas obj itself).\r\n    const [rendererRef, setRendererRef] = useState(null);\r\n    const [savingState, setSavingState] = useState(false);\r\n\r\n    const _getDisplay = ({reverse = false, value = \"block\"} = {}) => {\r\n        if (reverse) return uploadVisibility ? \"none\" : value;\r\n        return uploadVisibility ? value : \"none\";\r\n    }\r\n\r\n    const setImgSource = (v) => {\r\n        // Revoke previous img URL if exists to prevent memory leaks.\r\n        if (imgSource) URL.revokeObjectURL(imgSource);\r\n        setImgSourceVar(v);\r\n    }\r\n\r\n    const onImageUpload = data => {\r\n        setImgSource(data.src);\r\n        setImgDims(data.dim);\r\n        setUploadVisibility(false);\r\n    }\r\n\r\n    // Return to upload screen.\r\n    const goBack = () => {\r\n        setImgSource(null);\r\n        setImgDims(null);\r\n        setUploadVisibility(true);\r\n    }\r\n\r\n    // Ensure step counter increments and decrements in range 0 -> {maxSteps}\r\n    const hasNextStep = (step) => {\r\n        return 0 <= step && step < maxStep;\r\n    }\r\n\r\n    const stepTitles = {\r\n        0: \"Grayscale Encoding\",\r\n        1: \"Gaussian Blur\",\r\n        2: \"Edgefinding Operation\",\r\n        3: \"Non-maximum suppression\",\r\n        4: \"Double Threshold\",\r\n        5: \"Edge-Tracking (Hysteresis)\",\r\n        6: \"Final Image\"\r\n    }\r\n\r\n    // Map for option UI (React components) per step No.\r\n    const stepOptions = {\r\n        \r\n        0: (\r\n            <>\r\n                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                    <Col flex=\"120px\">Encoding Type</Col>\r\n                    <Col flex=\"auto\">\r\n                        <Select defaultValue={selectedGrayscaleTag} onChange={v => {setSelectedGrayscaleTag(v); setSelectedGrayscaleEncoding(grayScaleCoefficients[v])}}>\r\n                            <Option value=\"BT.601\">BT.601</Option>\r\n                            <Option value=\"BT.709\">BT.709</Option>\r\n                            <Option value=\"BT.2100\">BT.2100</Option>\r\n                            <Option value=\"Mean\">Mean</Option>\r\n                        </Select>\r\n                    </Col>\r\n                </Row>\r\n            </>\r\n        ),\r\n\r\n        1: (\r\n            <>\r\n                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                    <Col flex=\"60px\">Radius</Col>\r\n                    <Col flex=\"auto\"><Slider value={gaussRadius} onChange={v => setGaussRadius(v)} min={0} max={20}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={gaussRadius} onChange={v => setGaussRadius(v) } min={0} max={20}/></Col>\r\n                </Row>\r\n                \r\n                <Row style={{display: \"flex\", alignItems: \"center\"}}>\r\n                    <Col flex=\"60px\">Sigma ()</Col>\r\n                    <Col flex=\"auto\"><Slider defaultValue={gaussSigma} onChange={v => setGaussSigma(v)} min={0.01} max={15} step={0.01}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={gaussSigma} onChange={v => setGaussSigma(v) } min={0} max={20} step={0.01}/></Col>\r\n                </Row>\r\n            </>\r\n        ),\r\n\r\n        2: (\r\n            <>\r\n                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                    <Col flex=\"70px\">Operator</Col>\r\n                    <Col flex=\"auto\">\r\n                        <Select defaultValue={selectedEdgeTag} onChange={v => {setSelectedEdgeTag(v); setSelectedEdgeOperator(edgefindingOperators[v])}}>\r\n                            <Option value=\"sobel\">Sobel</Option>\r\n                            <Option value=\"prewitt\">Prewitt</Option>\r\n                        </Select>\r\n                    </Col>\r\n                </Row>\r\n            </>\r\n        ),\r\n\r\n        3: (<p><i>(No options available)</i></p>),\r\n\r\n        4: (\r\n            <>\r\n                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                    <Col flex=\"60px\">High</Col>\r\n                    <Col flex=\"auto\"><Slider value={highThreshold} onChange={v => setHighThreshold(v)} min={0} max={1} step={0.01}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={highThreshold} onChange={v => setHighThreshold(v) } min={0} max={1} step={0.01}/></Col>\r\n                </Row>\r\n                \r\n                <Row style={{display: \"flex\", alignItems: \"center\"}}>\r\n                    <Col flex=\"60px\">Low</Col>\r\n                    <Col flex=\"auto\"><Slider value={lowThreshold} onChange={v => setLowThreshold(v)} min={0} max={1} step={0.01}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={lowThreshold} onChange={v => setLowThreshold(v) } min={0} max={1} step={0.01}/></Col>\r\n\r\n                </Row>\r\n            </>\r\n        ),\r\n\r\n        5: (\r\n            <>\r\n                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                    <Col flex=\"100px\">Tolerance (px)</Col>\r\n                    <Col flex=\"auto\"><Slider value={hysteresisTolerance} onChange={v => setTolerance(v)} min={0} max={5}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={hysteresisTolerance} onChange={v => setTolerance(v) } min={0} max={5}/></Col>\r\n                </Row>\r\n\r\n                <Row style={{display: \"flex\", alignItems: \"center\"}}>\r\n                    <Col flex=\"100px\">Iterations</Col>\r\n                    <Col flex=\"auto\"><Slider value={hysteresisIters} onChange={v => setHysteresisIters(v)} min={0} max={500}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={hysteresisIters} onChange={v => setHysteresisIters(v) } min={0} max={500}/></Col>\r\n                </Row>\r\n            </>\r\n        )\r\n    }\r\n\r\n    const downloadCanvas = async () => {\r\n        if (rendererRef) {\r\n\r\n            // Set a flag to indicate saving has begun.\r\n            setSavingState(true);\r\n\r\n            // Put img conversion in promise to make asynchronous.\r\n            new Promise(resolve => {\r\n\r\n                setTimeout(() => {\r\n\r\n                    let img = rendererRef.domElement.toDataURL();\r\n                    resolve(img);\r\n                    \r\n                }, 30);\r\n\r\n            }).then(img => {\r\n\r\n                // Automatically download image from created data URL.\r\n                let link = document.createElement(\"a\");\r\n                link.download = \"Canny_Step_\" + step;\r\n                link.href = img;\r\n                link.click();\r\n                // Set flag to indicate saving has finished.\r\n                setSavingState(false);\r\n            })\r\n\r\n        }\r\n    }\r\n\r\n    const disposeRenderers = currentRenderers => {\r\n\r\n        // Go through each attribute of the renderers and dispose of them manually if applicable. Three fiber does not automatically dispose these renderers.\r\n        if (currentRenderers) {\r\n            // Separation of sobel and nms renderers here as same obj structure is used for both i.e {sobel: ..., nms: none} for a sobel computation renderer.\r\n            if (currentRenderers.sobel) {\r\n                for (const [k, v] of Object.entries(currentRenderers.sobel)) {\r\n                    if (v) {\r\n                        if (v.dispose) v.dispose();\r\n                        delete currentRenderers.sobel[k];\r\n                    };\r\n                }\r\n                currentRenderers.sobel = null;\r\n            }\r\n\r\n            if (currentRenderers.nms) {\r\n                for (const [k, v] of Object.entries(currentRenderers.nms)) {\r\n                    if (v) {\r\n                        if (v.dispose) v.dispose();\r\n                        delete currentRenderers.nms[k];\r\n                    };\r\n                }\r\n                currentRenderers.nms = null;\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    // Wrap options in container for css styling.\r\n    const getOptions = (step) => {\r\n\r\n        return (\r\n            <div className=\"processor-options\">\r\n                {stepOptions[step]}\r\n            </div>\r\n        )\r\n    }\r\n\r\n    const Shaders = () => {\r\n        const composer = useRef();\r\n        const { scene, gl, size, camera } = useThree();\r\n\r\n        // Do manual memoization here of kernel and renderers as useMemo() does not have expected performance\r\n        // (Unsure why as of now, though this works fine. Just a little more verbose).\r\n\r\n        let currentKernel = memoGauss;\r\n        let gaussParams = {r: gaussRadius, s: gaussSigma}\r\n        if (memoGaussParams == null) {\r\n            setMemoGaussParams(gaussParams);\r\n\r\n            currentKernel = getSeparableKernel(gaussParams.r, gaussParams.s);\r\n            setMemoGauss(currentKernel);\r\n        }\r\n\r\n        else if (gaussParams.r != memoGaussParams.r || gaussParams.s != memoGaussParams.s) {\r\n\r\n            setMemoGaussParams(gaussParams);\r\n\r\n            currentKernel = getSeparableKernel(gaussParams.r, gaussParams.s);\r\n            setMemoGauss(currentKernel);\r\n\r\n        }\r\n\r\n        // Use most recent kernel from after memoization.\r\n        const kernel = currentKernel;\r\n        const kernelSize = kernel.length;\r\n\r\n        // Memo renderers & their parameters in the same fashion as the kernel.\r\n        let currentRenderers = memoRenderers;\r\n        let renderParams = {gl: gl, dims: [ImgContainerRef.current.offsetWidth, ImgContainerRef.current.offsetHeight], kernel: selectedEdgeOperator, doNMS: (step > 2)}\r\n\r\n        if (memoRendererParams == null) {\r\n            setMemoRendererParams(renderParams);\r\n\r\n            currentRenderers = getComputationRenderers(renderParams.gl, renderParams.dims, renderParams.kernel, renderParams.doNMS);\r\n            setMemoRenderers(currentRenderers)\r\n            \r\n        }\r\n\r\n        // An intermediate Render Target is needed to transfer information from one computation renderer to the next; this is essentially a replacement for the render buffer.\r\n        if (intermediateRT == null) {\r\n            setIntermediateRT({tg: new WebGLRenderTarget(renderParams.dims.x, renderParams.dims.y)});\r\n        }\r\n        \r\n        // TODO: This is verbose, ensure obj comparison i.e. (renderParams != memoRendererParams) has expected behaviour to reduce this if statement.\r\n        else if (renderParams.gl != memoRendererParams.gl \r\n            || renderParams.dims[0] != memoRendererParams.dims[0]\r\n            || renderParams.dims[1] != memoRendererParams.dims[1]\r\n            || renderParams.kernel != memoRendererParams.kernel\r\n            || renderParams.doNMS != memoRendererParams.doNMS) {\r\n\r\n                // Update the current memoized parameters.\r\n                setMemoRendererParams(renderParams);\r\n\r\n                // Before updating the renderers ref, dispose of ALL objects from the custom renderer to avoid HUGE memory leaks (three-fiber doesn't auto-dispose these).\r\n                disposeRenderers(currentRenderers);\r\n\r\n                // Create new renderers (costly, hence memoization).\r\n                currentRenderers = getComputationRenderers(renderParams.gl, renderParams.dims, renderParams.kernel, renderParams.doNMS);\r\n                setMemoRenderers(currentRenderers)\r\n                \r\n                // If the image dimensions have changed (due to screen resize, etc.), the shape of the make-shift render buffer (render target) must be changed accordingly.\r\n                if (renderParams.dims[0] != memoRendererParams.dims[0] || renderParams.dims[1] != memoRendererParams.dims[1]) {\r\n                    \r\n                    // Manual dispose of previous render target.\r\n                    if (intermediateRT.tg) {\r\n                        if (intermediateRT.tg.dispose) intermediateRT.tg.dispose();\r\n                        delete intermediateRT.tg;\r\n                    }                    \r\n                    setIntermediateRT({tg: new WebGLRenderTarget(renderParams.dims.x, renderParams.dims.y)});\r\n                }\r\n        }\r\n\r\n        // Save GL environment to state to allow downloading of the canvas.\r\n        if (gl != rendererRef) {\r\n            setRendererRef(gl);\r\n        }\r\n\r\n        // Set up and render post-processing on mount.\r\n        useEffect(() => {\r\n            // Note: The r3f library is an absolute NIGHTMARE for adding extra passes.\r\n            //       It is so bad that I can literally only get this to work by adding passes normally\r\n            //       through three.js\r\n            composer.current.addPass(new RenderPass(scene, camera));\r\n            if (step >= 0) composer.current.addPass(new GrayscalePass(selectedGrayscaleEncoding));\r\n            if (step >= 1) composer.current.addPass(new HorizontalBlurPass(kernel, kernelSize, ImgContainerRef.current.offsetWidth));\r\n            if (step >= 1) composer.current.addPass(new VerticalBlurPass(kernel, kernelSize, ImgContainerRef.current.offsetHeight));\r\n            if (step >= 2) composer.current.addPass(new GpuComputePass(currentRenderers.sobel, currentRenderers.nms, renderParams.dims, false, null));\r\n            if (step >= 3) composer.current.addPass(new GpuComputePass(currentRenderers.sobel, currentRenderers.nms, renderParams.dims, true, null));\r\n            if (step >= 4) composer.current.addPass(new GpuComputePass(currentRenderers.sobel, currentRenderers.nms, renderParams.dims, true, {high: highThreshold, low: lowThreshold}));\r\n            if (step >= 5) composer.current.addPass(new HysteresisPass(hysteresisTolerance, hysteresisIters, intermediateRT.tg, renderParams.dims));\r\n            if (step >= 6) composer.current.addPass(new CopyStrongPass(renderParams.dims));\r\n            composer.current.render()\r\n\r\n        }, []);\r\n\r\n        // Render on each frame thereafter.\r\n        useFrame(() => {\r\n            composer.current.render()\r\n        \r\n        }, 1);\r\n\r\n        return (\r\n            <effectComposer ref={composer} args={[gl]} />\r\n        )\r\n    }\r\n\r\n    return (\r\n\r\n        <div className=\"fill-container\">\r\n\r\n            <FadeIn visible={uploadVisibility}>\r\n                <ImageUploader onLoadCallback={onImageUpload} style={{display: _getDisplay()}}/>\r\n            </FadeIn>\r\n\r\n            {(imgSource != null && imgDims != null) ? (\r\n                <div className=\"fill-container\">\r\n                    <FadeIn className=\"fill-and-vertically-center\">\r\n\r\n                        <Row gutter={[16,16]} justify=\"center\" align=\"middle\" style={{display: \"flex\", alignItems: \"center\", marginRight: \"0\"}}>\r\n\r\n                            {/* Input image */}\r\n                            <Col className=\"process-preview-grid-col\" flex={1}>\r\n                                <div className=\"process-preview-container\" ><div ref={ImgContainerRef}><Image id=\"preview-before\" src={imgSource} onLoad={() => setDisplayDim({width: ImgContainerRef.current.offsetWidth, height: ImgContainerRef.current.offsetHeight})} /></div></div>\r\n                            </Col>\r\n\r\n                            {/* Processed Image */}\r\n                            <Col className=\"process-preview-grid-col\" flex={1}>\r\n                                <div className=\"process-preview-container\">\r\n                                    <Canvas \r\n                                        className=\"shader\"\r\n                                        camera={{fov: 50, position: [0, 0, 30]}}\r\n                                        gl={{preserveDrawingBuffer: true}}\r\n                                        style={{position: \"relative\", width: shaderDisplayDim.width, height: shaderDisplayDim.height}}\r\n                                    >\r\n                                        <ThreeImagePlane img={imgSource} dim={{width: imgDims.width, height: imgDims.height}}/>\r\n                                        <Shaders /> \r\n                                    </Canvas>\r\n                                </div>\r\n                            </Col>\r\n                            \r\n                            {/* Processing parameters */}\r\n                            <Col className=\"process-preview-grid-col\" flex={1} style={{alignSelf: \"stretch\"}}>\r\n                                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                                    <Col ><Button onClick={() => setStep(prev => prev - 1)} disabled={!hasNextStep(step - 1)}>Previous</Button></Col>\r\n                                    <Col flex=\"auto\" align=\"center\"><h1 id=\"title\" style={{display: \"inline-block\", alignSelf: \"center\"}}><b>{stepTitles[step]}</b></h1></Col>\r\n                                    <Col align=\"right\" style={{paddingRight: \"5px\"}}><Button onClick={() => setStep(prev => prev + 1)} disabled={!hasNextStep(step + 1)} style={{float: \"right\"}}>Next</Button></Col>\r\n                                    <Col align=\"right\"><Button type=\"primary\" onClick={downloadCanvas} style={{float: \"right\"}}>{savingState ? <Spin size=\"middle\" indicator={<LoadingOutlined spin style={{color: \"white\"}}/>}/> : \"Save\"}</Button></Col>\r\n                                </Row>\r\n                                {getOptions(step)}\r\n                            </Col>\r\n\r\n                        </Row>\r\n                    </FadeIn>\r\n                    \r\n                    <FadeIn className=\"back-overlay\" visible={!uploadVisibility}>\r\n                        <Button id=\"button\"\r\n                            type=\"link\" \r\n                            style={{fontSize: \"15px\"}}\r\n                            onClick={() => {disposeRenderers(memoRenderers); goBack()}}\r\n                        >\r\n                            <ArrowLeftOutlined /> \r\n                            Change image\r\n                        </Button> \r\n                    </FadeIn>\r\n\r\n                </div>\r\n            ) : null}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport {Steps}; ","import React, { useState } from 'react'\r\nimport { notification } from 'antd';\r\nimport { WarningTwoTone } from '@ant-design/icons';\r\nimport { Steps } from './steps';\r\nimport \"./main.scss\";\r\n\r\n\r\nconst Main = () => {\r\n\r\n    // Only send notif once per acces to this route - not using state would make this notif appear on every re-render.\r\n    const [notifSent, setNotifSent] = useState(false);\r\n\r\n    const performanceNotification = () => {\r\n        if (notifSent === false) {\r\n            notification.open({\r\n                message: \"This project works best on a powerful machine!\",\r\n                description: <span>This page uses WebGL - a dedicated GPU is STRONGLY recommended.<br />Loading images which are too large or updating parameters too quickly <i>may</i> cause the browser to run out of memory.</span>,\r\n                icon: <WarningTwoTone twoToneColor=\"#FFA500\" />,\r\n                key: \"performance-notif\",\r\n                style: {width: 500}\r\n            });\r\n            setNotifSent(true);\r\n        }\r\n    }\r\n\r\n    performanceNotification();\r\n\r\n    return (\r\n        <div className=\"fill-container\">\r\n            {Steps()}\r\n        </div>\r\n    );\r\n}   \r\n\r\nexport default Main;"],"names":["Dragger","Upload","UploadIcon","_ref","loading","_jsx","LoadingOutlined","spin","InboxOutlined","_ref2","onLoadCallback","style","loadingImage","setLoadingImage","useState","_jsxs","name","multiple","listType","className","showUploadList","customRequest","async","file","onSuccess","_ref3","Promise","resolve","setTimeout","src","URL","createObjectURL","img","Image","onload","dim","width","height","then","data","beforeUpload","type","message","error","onChange","info","status","response","console","log","children","image","useLoader","TextureLoader","minFilter","LinearFilter","factor","arguments","length","undefined","viewport","v","aspect","useThree","adaptedHeight","useAspect","scale","attach","map","depthTest","toneMapped","Vector3","GrayscaleShader","hGaussianBlur","Array","vGaussianBlur","normalizeShader","Vector2","thresholdShader","dilationShader","hysteresisCombineShader","copyStrongShader","copyShader","_weights","_kernel","_kernelSize","_hRes","_vRes","_thresh_max","_thresh_high","_thresh_low","_dims","GrayscaleShaderMaterial","ShaderMaterial","constructor","weights","super","uniforms","tDiffuse","Uniform","fragmentShader","vertexShader","depthWrite","GrayscalePass","Pass","this","fullscreenMaterial","render","renderer","inputBuffer","outputBuffer","deltaTime","stencilTest","material","value","texture","setRenderTarget","renderToScreen","scene","camera","HorizontalBlurShaderMaterial","kernel","kernelSize","hRes","HorizontalBlurPass","VerticalBlurShaderMaterial","vRes","VerticalBlurPass","ThresholdShaderMaterial","max","high","low","NormShaderMaterial","GpuComputePass","sobelParams","nmsParams","doNMS","threshold","_normShaderMaterial","_thresholdShaderMaterial","dims","sobelGpuCompute","gpuCompute","magnitudeVariable","magnitudeUniforms","argumentVariable","argumentUniforms","nmsGpuCompute","nmsVariable","nmsUniforms","renderTarget","compute","getCurrentRenderTarget","read","Float32Array","readRenderTargetPixels","i","normMaterial","Math","hi","threshMaterial","CopyShaderMaterial","DilationShaderMaterial","tolerance","HysteresisShaderMaterial","tDilate","HysteresisPass","iterations","copyMaterial","dilationMaterial","hysMaterial","intermediateRt","clone","clear","dispose","CopyStrongShadermaterial","CopyStrongPass","fillTextureWithZeros","arr","getSobelComputeRenderer","gl","GPUComputationRenderer","gradMagnitude","createTexture","gradArgument","addVariable","setVariableDependencies","gx","gy","init","texture_2","getNMSComputeRenderer","nms","textures","getComputationRenderers","sobel","getSeparableKernel","r","sigma","exponent","sum","coefficient","sqrt","PI","exp","pow","extend","EffectComposer","Option","Select","grayScaleCoefficients","edgefindingOperators","Steps","step","setStep","ImgContainerRef","useRef","shaderDisplayDim","setDisplayDim","imgDims","setImgDims","imgSource","setImgSourceVar","uploadVisibility","setUploadVisibility","intermediateRT","setIntermediateRT","selectedGrayscaleTag","setSelectedGrayscaleTag","selectedGrayscaleEncoding","setSelectedGrayscaleEncoding","gaussRadius","setGaussRadius","gaussSigma","setGaussSigma","selectedEdgeTag","setSelectedEdgeTag","selectedEdgeOperator","setSelectedEdgeOperator","lowThreshold","setLowThreshold","highThreshold","setHighThreshold","hysteresisTolerance","setTolerance","hysteresisIters","setHysteresisIters","memoRenderers","setMemoRenderers","memoRendererParams","setMemoRendererParams","memoGaussParams","setMemoGaussParams","memoGauss","setMemoGauss","rendererRef","setRendererRef","savingState","setSavingState","setImgSource","revokeObjectURL","hasNextStep","stepOptions","_Fragment","Row","display","alignItems","paddingBottom","Col","flex","defaultValue","Slider","min","align","InputNumber","disposeRenderers","currentRenderers","k","Object","entries","Shaders","composer","size","currentKernel","gaussParams","s","renderParams","current","offsetWidth","offsetHeight","tg","WebGLRenderTarget","x","y","useEffect","addPass","RenderPass","useFrame","ref","args","FadeIn","visible","ImageUploader","reverse","_getDisplay","gutter","justify","marginRight","id","onLoad","Canvas","fov","position","preserveDrawingBuffer","ThreeImagePlane","alignSelf","Button","onClick","prev","disabled","paddingRight","float","domElement","toDataURL","link","document","createElement","download","href","click","Spin","indicator","color","getOptions","fontSize","ArrowLeftOutlined","Main","notifSent","setNotifSent","notification","open","description","icon","WarningTwoTone","twoToneColor","key"],"sourceRoot":""}