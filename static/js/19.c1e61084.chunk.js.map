{"version":3,"sources":["../node_modules/@react-three/drei/node_modules/@babel/runtime/helpers/esm/extends.js","../../src/index.tsx","../node_modules/@react-three/drei/core/PerspectiveCamera.js","web/home/shaders/copyPass.js","web/home/home.jsx","web/home/bumpShader.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","refs","ref","PerspectiveCamera","React","makeDefault","manual","props","set","useThree","camera","size","cameraRef","cam","current","aspect","width","height","updateProjectionMatrix","oldCam","mergeRefs","copyShader","uniforms","value","vertexShader","fragmentShader","Pass","extend","EffectComposer","ShaderPass","RenderPass","Terrain","noisePos","clock","callback","useMemo","bumpScale","zoom","gl","scene","useFrame","state","delta","getDelta","previous","position","rotation","Math","PI","scale","attach","args","side","DoubleSide","HomePage","useState","setNoisePos","Clock","style","top","left","backgroundColor","near","far","fallback","color"],"mappings":"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","file":"static/js/19.c1e61084.chunk.js","sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","import * as React from \"react\";\n\nexport default function mergeRefs<T = any>(\n  refs: Array<React.MutableRefObject<T> | React.LegacyRef<T>>\n): React.RefCallback<T> {\n  return (value) => {\n    refs.forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        (ref as React.MutableRefObject<T | null>).current = value;\n      }\n    });\n  };\n}\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useThree } from '@react-three/fiber';\nimport mergeRefs from 'react-merge-refs';\n\nconst PerspectiveCamera = /*#__PURE__*/React.forwardRef(({\n  makeDefault,\n  manual,\n  ...props\n}, ref) => {\n  const set = useThree(({\n    set\n  }) => set);\n  const camera = useThree(({\n    camera\n  }) => camera);\n  const size = useThree(({\n    size\n  }) => size);\n  const cameraRef = React.useRef();\n  React.useLayoutEffect(() => {\n    const {\n      current: cam\n    } = cameraRef;\n\n    if (cam && !manual) {\n      cam.aspect = size.width / size.height;\n      cam.updateProjectionMatrix();\n    }\n  }, [size, props]);\n  React.useLayoutEffect(() => {\n    if (makeDefault && cameraRef.current) {\n      const oldCam = camera;\n      set(() => ({\n        camera: cameraRef.current\n      }));\n      return () => set(() => ({\n        camera: oldCam\n      }));\n    }\n  }, [camera, cameraRef, makeDefault, set]);\n  return /*#__PURE__*/React.createElement(\"perspectiveCamera\", _extends({\n    ref: mergeRefs([cameraRef, ref])\n  }, props));\n});\n\nexport { PerspectiveCamera };\n","import { ShaderMaterial, UniformsUtils } from 'three';\r\nimport { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';\r\n\r\nexport const copyShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'cameraNear': { value: 0 },\r\n        'cameraFar': { value: 0 }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        #include <packing>\r\n\r\n        varying vec2 vUv;\r\n        uniform sampler2D tDiffuse;\r\n        uniform float cameraNear;\r\n        uniform float cameraFar;\r\n\r\n        \r\n        float readDepth( sampler2D depthSampler, vec2 coord ) {\r\n            float fragCoordZ = texture2D( depthSampler, coord ).x;\r\n            float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\r\n            return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\r\n        }\r\n\r\n        void main() {\r\n\r\n            float depth = readDepth(tDiffuse, vUv);\r\n\r\n            gl_FragColor.rgb = 1.0 - vec3( depth );\r\n            gl_FragColor.a = 1.0;\r\n\r\n        }`\r\n\r\n}\r\n\r\nexport class CopyPass extends Pass {\r\n\r\n    constructor ( dims ) {\r\n\r\n        super();\r\n\r\n        this.initCopyShader();\r\n\r\n    }\r\n\r\n    render( renderer, writeBuffer, readBuffer ) {\r\n\r\n        this.copyUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n        if ( this.renderToScreen ) { \r\n            \r\n            renderer.setRenderTarget(null);\r\n            this.copyFsQuad.render(renderer);\r\n\r\n        } else {\r\n\r\n            renderer.setRenderTarget(writeBuffer);\r\n            if (this.clear) renderer.clear();\r\n            this.copyFsQuad.render(renderer);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    initCopyShader() {\r\n\r\n        const cpyShader = copyShader;\r\n\r\n        this.copyUniforms = UniformsUtils.clone( cpyShader.uniforms );\r\n\r\n        this.copyMaterial = new ShaderMaterial({\r\n\r\n            uniforms: this.copyUniforms,\r\n            vertexShader: cpyShader.vertexShader,\r\n            fragmentShader: cpyShader.fragmentShader\r\n\r\n        })\r\n\r\n        this.copyFsQuad = new FullScreenQuad(this.copyMaterial);\r\n\r\n    }\r\n}","import React, { Suspense, useEffect, useState, useRef, useCallback , useMemo} from 'react';\r\nimport { Button } from 'antd'\r\nimport { Canvas, useFrame, useThree, extend } from 'react-three-fiber';\r\nimport { DoubleSide, Clock, DepthTexture, LinearFilter, RGBFormat, WebGLRenderTarget, NearestFilter, UnsignedShortType } from 'three';\r\nimport { OrbitControls, PerspectiveCamera } from '@react-three/drei'\r\nimport { fragmentShader, vertexShader } from './bumpShader';\r\n\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';\r\nimport { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';\r\nimport { copyShader } from \"./shaders/copyPass\";\r\n\r\nextend({ EffectComposer, ShaderPass, RenderPass });\r\n\r\nconst Water = () => {\r\n\r\n  const composer = useRef();\r\n  const ref = useRef()\r\n  const { gl, size, scene, camera } = useThree();\r\n\r\n  const [ target ] = useMemo(() =>  {\r\n    const target = new WebGLRenderTarget(\r\n        window.innerWidth,\r\n        window.innerHeight,\r\n        {\r\n            minFilter: NearestFilter,\r\n            magFilter: NearestFilter,\r\n            format: RGBFormat,\r\n            generateMipmaps: false,\r\n            stencilBuffer: false,\r\n            depthBuffer: true,\r\n            depthTexture: new DepthTexture(),\r\n            type: UnsignedShortType\r\n        }\r\n    );\r\n    return [ target ];\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n      composer.current.setSize(size.width, size.height)\r\n  }, [size])\r\n\r\n  useFrame((state) => {\r\n\r\n    state.gl.setRenderTarget(target);\r\n    state.gl.render(scene, camera);\r\n\r\n    if (ref.current) {\r\n      ref.current.uniforms['tDiffuse'].value = target.depthTexture;\r\n      ref.current.uniforms['cameraNear'].value = camera.near;\r\n      ref.current.uniforms['cameraFar'].value = camera.far;\r\n    }\r\n    composer.current.render()\r\n  }, 1);\r\n\r\n  return (\r\n    <effectComposer ref={composer} args={[gl]}>\r\n      <renderPass attachArray=\"passes\" scene={scene} camera={camera} />\r\n      <shaderPass attachArray=\"passes\" ref={ref} args={[copyShader]} renderToScreen />\r\n    </effectComposer>\r\n  )\r\n}\r\n\r\nconst Terrain = ({noisePos, clock, callback}) => {\r\n\r\n  const uniforms = useMemo(() => ({\r\n    noisePos: { value: 0.0 },\r\n    bumpScale: { value: 100 },\r\n    zoom: { value: 4 }\r\n  }), [])\r\n\r\n  const { gl, size, scene, camera } = useThree();\r\n\r\n  // const material = museRef()\r\n  // if (material.current) aterial.current.uniforms.noisePos.value = noisePos;\r\n\r\n  useFrame(state => {\r\n\r\n    let speed = 0.5\r\n    let delta = clock.getDelta()\r\n    uniforms.noisePos.value = noisePos + speed * delta\r\n    callback(previous => previous + speed * delta);\r\n    \r\n  })\r\n\r\n  return (\r\n    <mesh \r\n      position={[0, 0, 0]}\r\n      rotation={[-Math.PI / 2, 0, 0]}\r\n      scale={[1 / 256, 1 / 256, 1 / 256]}\r\n    >\r\n      <planeBufferGeometry attach=\"geometry\" args={[1024, 1024, 1024, 1024]}/>\r\n      <shaderMaterial\r\n        attach=\"material\"\r\n        uniforms={uniforms}\r\n        vertexShader={vertexShader}\r\n        fragmentShader={fragmentShader}\r\n        side={DoubleSide}\r\n      />\r\n      {/* <planeBufferGeometry attach=\"geometry\" args={[1024, 1024, 1024, 1024]}/>\r\n      <shaderMaterial\r\n        attach=\"material\"\r\n        uniforms={uniforms}\r\n        vertexShader={vertexShader}\r\n        fragmentShader={fragmentShader}\r\n        side={DoubleSide}\r\n      /> */}\r\n    </mesh>\r\n  )\r\n\r\n}\r\n\r\nconst HomePage = () => {\r\n\r\n    const [noisePos, setNoisePos] = useState(0)\r\n    const [clock, setClock] = useState(new Clock())\r\n\r\n    return (\r\n      <> \r\n        <div style={{position: \"absolute\", top: 0, left: 0, height: \"100vh\", width: \"100vw\", backgroundColor: \"black\"}}/>\r\n        <Canvas\r\n          style={{position: \"absolute\", top: 0, left: 0, height: \"100vh\", width: \"100vw\"}}\r\n        >\r\n          <PerspectiveCamera\r\n            position={[0.05896666849764306, 1.0630507657317696, 0.9790701530639065]}\r\n            rotation={[-0.8264992153403403, 0.040778606785100945, 0.04423528266176858]}\r\n            near={0.01}\r\n            far={1000}\r\n            makeDefault\r\n          />\r\n          {/* <OrbitControls screenSpacePanning={false} /> */}\r\n          <color attach=\"background\" args={['#000']} />\r\n          <Suspense fallback>\r\n            \r\n            <Terrain noisePos={noisePos} clock={clock} callback={setNoisePos}/>\r\n            <ambientLight />\r\n          </Suspense>\r\n\r\n          {/* <Water /> */}\r\n\r\n        </Canvas>\r\n        <p style={{position: \"absolute\", color: \"white\"}}>Nothing here for now. See projects tab</p>\r\n      </>\r\n    );\r\n}\r\n\r\nexport default HomePage","export const vertexShader = `\r\nuniform float noisePos;\r\nuniform float bumpScale;\r\nuniform float zoom;\r\n\r\n// A variable to store the height of the point\r\nvarying float vAmount;\r\n// The UV mapping coordinates of a vertex\r\nvarying vec2 vUV;\r\n\r\n//\r\n// Description : Array and textureless GLSL 2D simplex noise function.\r\n//      Author : Ian McEwan, Ashima Arts.\r\n//  Maintainer : stegu\r\n//     Lastmod : 20110822 (ijm)\r\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\r\n//               Distributed under the MIT License. See LICENSE file.\r\n//               https://github.com/ashima/webgl-noise\r\n//               https://github.com/stegu/webgl-noise\r\n// \r\n\r\nvec3 mod289(vec3 x) {\r\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec2 mod289(vec2 x) {\r\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec3 permute(vec3 x) {\r\n  return mod289(((x*34.0)+10.0)*x);\r\n}\r\n\r\nfloat snoise(vec2 v)\r\n  {\r\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\r\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\r\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\r\n                      0.024390243902439); // 1.0 / 41.0\r\n// First corner\r\n  vec2 i  = floor(v + dot(v, C.yy) );\r\n  vec2 x0 = v -   i + dot(i, C.xx);\r\n\r\n// Other corners\r\n  vec2 i1;\r\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\r\n  //i1.y = 1.0 - i1.x;\r\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\r\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\r\n  // x1 = x0 - i1 + 1.0 * C.xx ;\r\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\r\n  vec4 x12 = x0.xyxy + C.xxzz;\r\n  x12.xy -= i1;\r\n\r\n// Permutations\r\n  i = mod289(i); // Avoid truncation effects in permutation\r\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\r\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\r\n\r\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\r\n  m = m*m ;\r\n  m = m*m ;\r\n\r\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\r\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\r\n\r\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\r\n  vec3 h = abs(x) - 0.5;\r\n  vec3 ox = floor(x + 0.5);\r\n  vec3 a0 = x - ox;\r\n\r\n// Normalise gradients implicitly by scaling m\r\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\r\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\r\n\r\n// Compute final noise value at P\r\n  vec3 g;\r\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\r\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\r\n  return 130.0 * dot(m, g);\r\n}\r\n\r\nvoid main()\r\n{\r\n    // The \"coordinates\" in UV mapping representation\r\n    vUV = uv;\r\n\r\n    // The heightmap data at those coordinates\r\n    vec2 pos = (zoom * uv + vec2(noisePos, 0));\r\n    float bumpData = (snoise(pos) + 0.5 * snoise(2.0 * pos) + 0.25 * snoise(4.0 * pos) + 0.125 * snoise(8.0 * pos));\r\n\r\n    // height map is grayscale, so it doesn't matter if you use r, g, or b.\r\n    vAmount = bumpData;\r\n\r\n    // move the position along the normal\r\n    vec3 newPosition = position + normal * bumpScale * vAmount;\r\n\r\n    // Compute the position of the vertex using a standard formula\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\r\n}\r\n`;\r\n\r\nexport const fragmentShader = `\r\nvarying vec2 vUV;\r\nvarying float vAmount;\r\n\r\nvoid main()\r\n{\r\n    gl_FragColor = vec4(0.0, vAmount, 0.0, 1.0);\r\n}\r\n`;"],"sourceRoot":""}