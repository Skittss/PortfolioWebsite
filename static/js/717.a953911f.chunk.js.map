{"version":3,"file":"static/js/717.a953911f.chunk.js","mappings":"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","sources":["projects/Webgl-Canny/src/imageUploader.jsx","projects/Webgl-Canny/src/threeImagePlane.jsx","projects/Webgl-Canny/src/shaders/shaders.jsx","projects/Webgl-Canny/src/shaders/grayscalePass.js","projects/Webgl-Canny/src/shaders/horizontalBlurPass.js","projects/Webgl-Canny/src/shaders/verticalBlurPass.js","projects/Webgl-Canny/src/shaders/sobelPass.js","projects/Webgl-Canny/src/shaders/gpuComputePass.js","projects/Webgl-Canny/src/shaders/hysteresisPass.js","projects/Webgl-Canny/src/shaders/copyStrongPass.js","projects/Webgl-Canny/src/shaders/getComputationRenderers.jsx","projects/Webgl-Canny/src/gaussianKernel.jsx","projects/Webgl-Canny/src/steps.jsx","projects/Webgl-Canny/src/main.jsx"],"sourcesContent":["import React, { useState } from 'react'\r\nimport { message, Upload } from 'antd'\r\nimport { InboxOutlined, LoadingOutlined } from '@ant-design/icons';\r\nconst { Dragger } = Upload;\r\n\r\nconst UploadIcon = ({loading}) => {\r\n    return (\r\n        loading ? <LoadingOutlined spin /> : <InboxOutlined />\r\n    )\r\n}\r\n\r\nconst ImageUploader = ({onLoadCallback, style}) => {\r\n\r\n    const [loadingImage, setLoadingImage] = useState(false);\r\n\r\n    // Load image from the uploaded file.\r\n    // Antd usually expects an API call for uploading files, so this works the same way as an API call.\r\n    const loadImageLocally = async ({ file, onSuccess }) => {\r\n\r\n        new Promise(resolve => {\r\n\r\n            setTimeout(() => {\r\n\r\n                let src = URL.createObjectURL(file);\r\n                let img = new Image();\r\n                img.onload = () => {\r\n                    resolve({src: src, dim: {width: img.width, height: img.height}})\r\n                }\r\n                img.src = src;\r\n\r\n            }, 30);\r\n        }).then(data => onSuccess(data));\r\n    }\r\n\r\n    // Handle status of uploading file from antd component.\r\n    const handleChange = info => {\r\n        if (info.file.status === \"uploading\") {\r\n            setLoadingImage(true);\r\n        } else if (info.file.status === \"done\") {\r\n            setLoadingImage(false);\r\n            onLoadCallback(info.file.response);\r\n        } else {\r\n            setLoadingImage(false);\r\n            console.log(info.file.status);\r\n        }\r\n    }\r\n\r\n    const validateUpload = file => {\r\n        // TODO: I *think* more than these file formats can be handled as well, but they should be tested individually to check.\r\n        const validFormat = (\r\n            file.type === \"image/png\" || file.type ===\"image/jpeg\"\r\n        );\r\n        if (!validFormat) {\r\n            message.error(\"Only PNG/JPEG files are supported.\")\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    return (\r\n        <Dragger style={style}\r\n            name=\"source-image\"\r\n            multiple={false}\r\n            listType=\"picture-card\"\r\n            className=\"src-img-uploader\"\r\n            showUploadList={false}\r\n            customRequest={loadImageLocally}\r\n            beforeUpload={validateUpload}\r\n            onChange={handleChange}\r\n        >\r\n            <p className=\"ant-upload-drag-icon\">\r\n                <UploadIcon loading={loadingImage} />\r\n            </p>\r\n            <p className=\"ant-upload-text\">\r\n                {\"Click or drag an image to this area to begin\"}\r\n            </p>\r\n            <p className=\"ant-upload-hint\">\r\n                (large images may take a long time to process)\r\n            </p>\r\n        </Dragger>\r\n    );\r\n}\r\n\r\nexport default ImageUploader;","import React from 'react';\r\nimport { TextureLoader, LinearFilter } from 'three';\r\nimport { useLoader, useThree } from '@react-three/fiber';\r\n\r\n// Custom Three.js component - Image projected onto plane which fills the entirety of the viewport.\r\n\r\n// Calculates necessary width/height to be projected fully (factor = 1) onto threejs camera.\r\nconst useAspect = (width, height, factor = 1) => {\r\n    const { viewport: v, aspect } = useThree();\r\n    const adaptedHeight = height * (aspect > width / height ? v.width / width : v.height / height);\r\n    const adaptedWidth = width * (aspect > width / height ? v.width / width : v.height / height);\r\n    return [adaptedWidth * factor, adaptedHeight * factor, 1];\r\n}\r\n\r\nconst ThreeImagePlane = ({img, dim}) => {\r\n\r\n    const image = useLoader(TextureLoader, img);\r\n    // Use a linear filter to avoid sharp edges in the preview from the camera.\r\n    image.minFilter = LinearFilter;\r\n\r\n\r\n    const [width, height] = useAspect(dim.width, dim.height);\r\n\r\n    return (\r\n        <mesh scale={[width, height, 1]}>\r\n            <planeGeometry attach=\"geometry\"/>\r\n            <meshBasicMaterial attach=\"material\" map={image} depthTest={false} toneMapped={false}/>\r\n        </mesh>\r\n    )\r\n}\r\n\r\nexport default ThreeImagePlane;","import { Vector3, Vector2 } from 'three';\r\n\r\n// Fragment and vertex shaders for postprocessing passes.\r\n\r\nconst GrayscaleShader = {\r\n\r\n\tuniforms: {\r\n\t\t'tDiffuse': { value: null },\r\n        'weights': { value: new Vector3() }\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\t\tvarying vec2 vUv;\r\n\t\tvoid main() {\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\t\tuniform float opacity;\r\n\t\tuniform sampler2D tDiffuse;\r\n        uniform vec3 weights;\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\r\n            float w_a = weights.x * texel.x + weights.y * texel.y + weights.z * texel.z;\r\n\t\t\tgl_FragColor = vec4(w_a, w_a, w_a, 1.0);\r\n\t\t}`\r\n\r\n};\r\n\r\nconst hGaussianBlur = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'kernelSize': { value: 0 },\r\n        'kernel': { value: new Array(128) },\r\n        'hRes': { value: 0.0 }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n        uniform float hRes;\r\n        uniform int kernelSize;\r\n        uniform float kernel[128];\r\n        uniform sampler2D tDiffuse;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            vec4 color = texture2D(tDiffuse, vUv) * kernel[0];\r\n\r\n            for (int i=1; i < 128; i++) {\r\n                if (i == kernelSize) break;\r\n                color += texture2D(tDiffuse, vUv + vec2(float(i)/hRes, 0.0)) * kernel[i];\r\n                color += texture2D(tDiffuse, vUv - vec2(float(i)/hRes, 0.0)) * kernel[i];\r\n            }\r\n\r\n            gl_FragColor = color;\r\n        }`\r\n};\r\n\r\nconst vGaussianBlur = { \r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'kernelSize': { value: 0 },\r\n        'kernel': { value: new Array(128) },\r\n        'vRes': { value: 0.0 }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`            \r\n        uniform float vRes;\r\n        uniform int kernelSize;\r\n        uniform float kernel[128];\r\n        uniform sampler2D tDiffuse;\r\n        \r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            vec4 color = texture2D(tDiffuse, vUv) * kernel[0];\r\n\r\n            for (int i=1; i < 128; i++) {\r\n                if (i == kernelSize) break;\r\n                color += texture2D(tDiffuse, vUv + vec2(0.0, float(i)/vRes)) * kernel[i];\r\n                color += texture2D(tDiffuse, vUv - vec2(0.0, float(i)/vRes)) * kernel[i];\r\n            }\r\n\r\n            gl_FragColor = color;\r\n        }`\r\n\r\n};\r\n\r\nconst sobelShader = {\r\n    \r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'dim': { value: new Vector2() },\r\n        'GX': { value: new Array(9) },\r\n        'GY': { value: new Array(9) }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform vec2 dim;\r\n        uniform float GX[9];\r\n        uniform float GY[9];\r\n        uniform sampler2D tDiffuse;\r\n\r\n        void main() {\r\n            \r\n            vec4 gx = vec4(0.0);\r\n            vec4 gy = vec4(0.0);\r\n            vec4 v;\r\n\r\n            for (int j=0; j<3; j++) {\r\n                for (int i=0; i<3; i++) {\r\n                    v = texture2D(tDiffuse, vec2(gl_FragCoord.x/dim.x, gl_FragCoord.y/dim.y) + vec2( float(i-1)/dim.x, float(j-1)/dim.y ) );\r\n                    gx += GX[j * 3 + i] * v;\r\n                    gy += GY[j * 3 + i] * v;\r\n                }\r\n            }\r\n\r\n            vec4 mag = sqrt(gx * gx + gy * gy);\r\n            float arg = atan(gy.x, gx.x);\r\n\r\n\r\n            gl_FragColor = vec4(mag.x, mag.y, mag.z, 1.0);\r\n        }`\r\n}\r\n\r\nconst gradientMagnitudeFragShader = `\r\n    precision highp float;\r\n\r\n    uniform vec2 dim;\r\n    uniform float GX[9];\r\n    uniform float GY[9];\r\n    uniform sampler2D tDiffuse;\r\n\r\n    void main() {\r\n        \r\n        vec4 gx = vec4(0.0);\r\n        vec4 gy = vec4(0.0);\r\n        vec4 v;\r\n\r\n        for (int j=0; j<3; j++) {\r\n            for (int i=0; i<3; i++) {\r\n                v = texture2D(tDiffuse, vec2(gl_FragCoord.x/dim.x, gl_FragCoord.y/dim.y) + vec2( float(i-1)/dim.x, float(j-1)/dim.y ) );\r\n                gx += GX[j * 3 + i] * v;\r\n                gy += GY[j * 3 + i] * v;\r\n            }\r\n        }\r\n\r\n        vec4 mag = sqrt(gx * gx + gy * gy);\r\n        gl_FragColor = vec4(mag.x, mag.y, mag.z, 1.0);\r\n    }`\r\n\r\nconst gradientArgumentFragShader = `\r\n    precision highp float;\r\n\r\n    uniform vec2 dim;\r\n    uniform float GX[9];\r\n    uniform float GY[9];\r\n    uniform sampler2D tDiffuse;\r\n\r\n    void main() {\r\n        \r\n        vec4 gx = vec4(0.0);\r\n        vec4 gy = vec4(0.0);\r\n        vec4 v;\r\n\r\n        for (int j=0; j<3; j++) {\r\n            for (int i=0; i<3; i++) {\r\n                v = texture2D(tDiffuse, vec2(gl_FragCoord.x/dim.x, gl_FragCoord.y/dim.y) + vec2( float(i-1)/dim.x, float(j-1)/dim.y ) );\r\n                gx += GX[j * 3 + i] * v;\r\n                gy += GY[j * 3 + i] * v;\r\n            }\r\n        }\r\n\r\n        vec4 mag = sqrt(gx * gx + gy * gy);\r\n        float arg = atan(gy.x, gx.x);\r\n\r\n        gl_FragColor = vec4(arg, arg, arg, arg);\r\n    }`\r\n\r\nconst normalizeShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'max': { value : 1.0 }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDiffuse;\r\n        uniform float max;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            float v = texture2D(tDiffuse, vUv).x;\r\n            float norm = v / max;\r\n\r\n            gl_FragColor = vec4(norm, norm, norm, 1.0);\r\n\r\n        }`\r\n\r\n}\r\n\r\nconst nmsFragShader = `\r\n\r\n    uniform sampler2D tMags;\r\n    uniform sampler2D tArgs;\r\n    uniform vec2 dim;\r\n\r\n    void main() {\r\n        \r\n        vec2 current = vec2(gl_FragCoord.x/dim.x, gl_FragCoord.y/dim.y);\r\n\r\n        float m = texture2D(tMags, current).x;\r\n        float a = texture2D(tArgs, current).x;\r\n\r\n        float hComp = cos(a);\r\n        float vComp = sin(a);\r\n        float xTranslate = sign(hComp);\r\n        float yTranslate = sign(vComp);\r\n\r\n        vec2 translate = vec2(xTranslate/dim.x, yTranslate/dim.y);\r\n        vec2 a1 = current + translate;\r\n        vec2 a2 = current - translate;\r\n        float ag1 = texture2D(tMags, a1).x;\r\n        float ag2 = texture2D(tMags, a2).x;\r\n\r\n        vec2 b1, b2;\r\n        float bg1, bg2;\r\n\r\n        float g1, g2;\r\n\r\n        if (abs(hComp) > abs(vComp)) {\r\n            translate = vec2(xTranslate/dim.x, 0.0);\r\n            b1 = current + vec2(translate);\r\n            b2 = current - vec2(translate);\r\n            bg1 = texture2D(tMags, b1).x;\r\n            bg2 = texture2D(tMags, b2).x;\r\n            g1 = ag1 * abs(vComp) + (1.0-abs(vComp)) * bg1;\r\n            g2 = ag2 * abs(vComp) + (1.0-abs(vComp)) * bg2;\r\n        }\r\n        else {\r\n            translate = vec2(0.0, yTranslate/dim.y);\r\n            b1 = current + vec2(translate);\r\n            b2 = current - vec2(translate);\r\n            bg1 = texture2D(tMags, b1).x;\r\n            bg2 = texture2D(tMags, b2).x;\r\n            g1 = ag1 * abs(hComp) + (1.0-abs(hComp)) * bg1;\r\n            g2 = ag2 * abs(hComp) + (1.0-abs(hComp)) * bg2;\r\n        }\r\n\r\n        if (g1 > m || g2 > m) {\r\n            m = 0.0;\r\n        }\r\n\r\n        gl_FragColor = vec4(m, m, m, 1.0);\r\n\r\n    }`\r\n\r\nconst thresholdShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'max': { value : 1.0 },\r\n        'high': { value: 0.0},\r\n        'low': { value: 0.0}\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDiffuse;\r\n        uniform float max;\r\n        uniform float high;\r\n        uniform float low;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            float v = texture2D(tDiffuse, vUv).x;\r\n\r\n            vec4 texel;\r\n            if (v <= low) {\r\n                texel = vec4(0.0, 0.0, 0.0, 1.0);\r\n            } else if (v < high) {\r\n                texel = vec4(0.3, 0.3, 0.3, 1.0);\r\n            } else {\r\n                texel = vec4(1.0);\r\n            }\r\n\r\n            gl_FragColor = texel;\r\n\r\n        }`\r\n\r\n}\r\n\r\nconst dilationShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'dims': { value : new Vector2() },\r\n        'tolerance': { value: 1.0},\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDiffuse;\r\n        uniform vec2 dims;\r\n        uniform int tolerance;\r\n\r\n        void main() {\r\n\r\n            float v = 0.0;\r\n            for (int j = -tolerance; j <= tolerance; j++) {\r\n                for (int i = -tolerance; i <= tolerance; i++) {\r\n                    \r\n                    vec2 coord = vec2(gl_FragCoord.x/dims.x, gl_FragCoord.y/dims.y) + vec2( float(i)/dims.x, float(j)/dims.y );\r\n\r\n                    if ( texture2D(tDiffuse, coord).x > 0.3) {\r\n\r\n                        v = 1.0;\r\n                        break;\r\n\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            gl_FragColor = vec4(v, v, v, 1.0);\r\n\r\n        }`\r\n\r\n}\r\n\r\nconst hysteresisCombineShader = {\r\n\r\n    uniforms: {\r\n        'tDilate': { value: null },\r\n        'tDiffuse': { value: null },\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDilate;\r\n        uniform sampler2D tDiffuse;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            float dilate = texture2D(tDilate, vUv).x;\r\n            float weak = texture2D(tDiffuse, vUv).x;\r\n\r\n            if (weak < 1.0 && weak > 0.0 && dilate > 0.3) {\r\n\r\n                weak = 1.0;\r\n\r\n            }\r\n\r\n            gl_FragColor = vec4(weak, weak, weak, 1.0);\r\n        }`\r\n\r\n}\r\n\r\nconst copyStrongShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'dims': { value: new Vector2() }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDiffuse;\r\n        uniform vec2 dims;\r\n\r\n        void main() {\r\n\r\n            vec2 coord = vec2(gl_FragCoord.x/dims.x, gl_FragCoord.y/dims.y);\r\n\r\n            float v = texture2D(tDiffuse, coord).x;\r\n            if ( v <= 0.3 ) {\r\n                v = 0.0;\r\n            }\r\n\r\n            gl_FragColor = vec4(v, v, v, 1.0);\r\n\r\n        }`\r\n\r\n}\r\n\r\nconst copyShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDiffuse;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            gl_FragColor = texture2D(tDiffuse, vUv);\r\n\r\n        }`\r\n\r\n}\r\n\r\nexport { normalizeShader, GrayscaleShader, hGaussianBlur, vGaussianBlur, sobelShader, gradientMagnitudeFragShader, gradientArgumentFragShader, nmsFragShader, thresholdShader, copyStrongShader, copyShader, dilationShader, hysteresisCombineShader };","import { ShaderMaterial, UniformsUtils } from 'three';\r\nimport { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';\r\nimport { GrayscaleShader } from './shaders';\r\n\r\nclass GrayscalePass extends Pass {\r\n\r\n    constructor ( weights ) {\r\n\r\n        super();\r\n\r\n        const shader = GrayscaleShader;\r\n\r\n        this.uniforms = UniformsUtils.clone( shader.uniforms );\r\n        \r\n        this.material = new ShaderMaterial({\r\n\r\n            uniforms: this.uniforms,\r\n            vertexShader: shader.vertexShader,\r\n            fragmentShader: shader.fragmentShader\r\n        \r\n        });\r\n\r\n        if (weights !== undefined) this.uniforms.weights.value = weights;\r\n\r\n        this.fsQuad = new FullScreenQuad(this.material);\r\n\r\n    }\r\n\r\n    render( renderer, writeBuffer, readBuffer) {\r\n\r\n        this.uniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n        if ( this.renderToScreen ) { \r\n            \r\n            renderer.setRenderTarget(null);\r\n            this.fsQuad.render(renderer);\r\n\r\n        } else {\r\n\r\n            renderer.setRenderTarget(writeBuffer);\r\n            if (this.clear) renderer.clear();\r\n            this.fsQuad.render(renderer);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nexport default GrayscalePass;","import { ShaderMaterial, UniformsUtils } from 'three';\r\nimport { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';\r\nimport { hGaussianBlur } from './shaders';\r\n\r\nclass HorizontalBlurPass extends Pass {\r\n\r\n    constructor ( kernel, kernelSize, width ) {\r\n\r\n        super();\r\n\r\n        const shader = hGaussianBlur;\r\n\r\n        this.uniforms = UniformsUtils.clone( shader.uniforms );\r\n        \r\n        this.material = new ShaderMaterial({\r\n\r\n            uniforms: this.uniforms,\r\n            vertexShader: shader.vertexShader,\r\n            fragmentShader: shader.fragmentShader\r\n        \r\n        });\r\n\r\n        if (kernel !== undefined) this.uniforms.kernel.value = kernel;\r\n        if (kernelSize !== undefined) this.uniforms.kernelSize.value = kernelSize;\r\n        if (width !== undefined) this.uniforms.hRes.value = width;\r\n\r\n        this.fsQuad = new FullScreenQuad(this.material);\r\n\r\n    }\r\n\r\n    render( renderer, writeBuffer, readBuffer) {\r\n\r\n        this.uniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n        if ( this.renderToScreen ) { \r\n            \r\n            renderer.setRenderTarget(null);\r\n            this.fsQuad.render(renderer);\r\n\r\n        } else {\r\n\r\n            renderer.setRenderTarget(writeBuffer);\r\n            if (this.clear) renderer.clear();\r\n            this.fsQuad.render(renderer);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nexport default HorizontalBlurPass;","import { ShaderMaterial, UniformsUtils } from 'three';\r\nimport { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';\r\nimport { vGaussianBlur } from './shaders';\r\n\r\nclass HorizontalBlurPass extends Pass {\r\n\r\n    constructor ( kernel, kernelSize, height ) {\r\n\r\n        super();\r\n\r\n        const shader = vGaussianBlur;\r\n\r\n        this.uniforms = UniformsUtils.clone( shader.uniforms );\r\n        \r\n        this.material = new ShaderMaterial({\r\n\r\n            uniforms: this.uniforms,\r\n            vertexShader: shader.vertexShader,\r\n            fragmentShader: shader.fragmentShader\r\n        \r\n        });\r\n\r\n        if (kernel !== undefined) this.uniforms.kernel.value = kernel;\r\n        if (kernelSize !== undefined) this.uniforms.kernelSize.value = kernelSize;\r\n        if (height !== undefined) this.uniforms.vRes.value = height;\r\n\r\n        this.fsQuad = new FullScreenQuad(this.material);\r\n\r\n    }\r\n\r\n    render( renderer, writeBuffer, readBuffer) {\r\n\r\n        this.uniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n        if ( this.renderToScreen ) { \r\n            \r\n            renderer.setRenderTarget(null);\r\n            this.fsQuad.render(renderer);\r\n\r\n        } else {\r\n\r\n            renderer.setRenderTarget(writeBuffer);\r\n            if (this.clear) renderer.clear();\r\n            this.fsQuad.render(renderer);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nexport default HorizontalBlurPass;","import { ShaderMaterial, UniformsUtils } from 'three';\r\nimport { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';\r\nimport { sobelShader } from './shaders';\r\n\r\nclass SobelPass extends Pass {\r\n\r\n    constructor ( gx, gy, dim ) {\r\n\r\n        super();\r\n\r\n        const shader = sobelShader;\r\n\r\n        this.uniforms = UniformsUtils.clone( shader.uniforms );\r\n        \r\n        this.material = new ShaderMaterial({\r\n\r\n            uniforms: this.uniforms,\r\n            vertexShader: shader.vertexShader,\r\n            fragmentShader: shader.fragmentShader\r\n        \r\n        });\r\n\r\n        if (gx !== undefined) this.uniforms.GX.value = gx;\r\n        if (gy !== undefined) this.uniforms.GY.value = gy;\r\n        if (dim !== undefined) this.uniforms.dim.value = dim;\r\n\r\n        this.fsQuad = new FullScreenQuad(this.material);\r\n\r\n    }\r\n\r\n    render( renderer, writeBuffer, readBuffer) {\r\n\r\n        this.uniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n        if ( this.renderToScreen ) { \r\n            \r\n            renderer.setRenderTarget(null);\r\n            this.fsQuad.render(renderer);\r\n\r\n        } else {\r\n\r\n            renderer.setRenderTarget(writeBuffer);\r\n            if (this.clear) renderer.clear();\r\n            this.fsQuad.render(renderer);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nexport default SobelPass;","import { ShaderMaterial, UniformsUtils } from 'three';\r\nimport { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';\r\nimport { normalizeShader, thresholdShader } from './shaders';\r\n\r\n// Combines passes for Sobel operator onwards due to dependency on calculated information\r\nclass GpuComputePass extends Pass {\r\n\r\n    constructor ( sobelParams, nmsParams, dim, doNMS, threshold ) {\r\n\r\n        super();\r\n\r\n        this.doNMS = doNMS;\r\n        this.threshold = threshold;\r\n\r\n        this.dims = dim;\r\n\r\n        this.gpuCompute = sobelParams.gpuCompute;\r\n        this.magnitudeVariable = sobelParams.magnitudeVariable;\r\n        this.magnitudeUniforms = sobelParams.magnitudeUniforms;\r\n        this.argumentVariable = sobelParams.argumentVariable;\r\n        this.argumentUniforms = sobelParams.argumentUniforms;\r\n\r\n        if (doNMS) {\r\n            this.nmsGpuCompute = nmsParams.nmsGpuCompute;\r\n            this.nmsVariable = nmsParams.nmsVariable;\r\n            this.nmsUniforms = nmsParams.nmsUniforms;\r\n        }\r\n\r\n        // Normalize values to range 0 -> 1.\r\n        this.initNormalizeShader();\r\n\r\n        if (threshold) this.initThresholdShader();\r\n    }\r\n\r\n    render( renderer, writeBuffer, readBuffer) {\r\n\r\n        // Compute gradient magnitudes and angles\r\n        this.magnitudeUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n        if ( this.doNMS ) this.argumentUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n        this.gpuCompute.compute();\r\n\r\n        // Pass in shader uniforms depending on the process shader.\r\n        let renderTarget;\r\n        if ( this.doNMS ) {\r\n\r\n            this.nmsUniforms[ 'tMags' ].value = this.gpuCompute.getCurrentRenderTarget( this.magnitudeVariable ).texture;\r\n            this.nmsUniforms[ 'tArgs' ].value = this.gpuCompute.getCurrentRenderTarget( this.argumentVariable ).texture;\r\n            this.nmsUniforms[ 'dim' ].value = this.dims;\r\n\r\n            this.nmsGpuCompute.compute();\r\n\r\n            renderTarget = this.nmsGpuCompute.getCurrentRenderTarget( this.nmsVariable )\r\n\r\n        } else {\r\n\r\n            renderTarget = this.gpuCompute.getCurrentRenderTarget( this.magnitudeVariable )\r\n\r\n        }\r\n        \r\n        // Calculate the max value uniform for the normalize shader.\r\n\r\n        let read = new Float32Array( 4 * this.dims[0] * this.dims[1]);\r\n        renderer.readRenderTargetPixels(renderTarget, 0, 0, this.dims[0], this.dims[1], read);\r\n\r\n        // O(N) CPU bound search for max\r\n\r\n        let max = 0.0;\r\n        for (let i = 0; i < read.length; i+=4) {\r\n            if (read[i] > max) max = read[i];\r\n        }\r\n\r\n        if (max > 0.0) this.normUniforms[ 'max' ].value = max;\r\n        this.normUniforms[ 'tDiffuse' ].value = renderTarget.texture;\r\n\r\n        // Render norm pass in the effects chain.\r\n\r\n        if ( this.renderToScreen && !this.threshold ) {\r\n\r\n            renderer.setRenderTarget(null);\r\n            this.normFsQuad.render(renderer);\r\n\r\n        } else {\r\n\r\n            renderer.setRenderTarget(readBuffer);\r\n            if (this.clear) renderer.clear();\r\n            this.normFsQuad.render(renderer);\r\n\r\n        }\r\n\r\n        // Render threshold pass in the effects chain.\r\n\r\n        if ( this.threshold ) {\r\n            \r\n            let hi = this.threshold.high * max;\r\n\r\n            this.threshUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n            this.threshUniforms[ 'max' ].value = max;\r\n            this.threshUniforms[ 'high' ].value = hi;\r\n            this.threshUniforms[ 'low' ].value = this.threshold.low * hi;\r\n\r\n            if (this.renderToScreen) {\r\n\r\n                renderer.setRenderTarget(null);\r\n                this.threshFsQuad.render(renderer)\r\n\r\n            } else {\r\n\r\n                renderer.setRenderTarget(writeBuffer);\r\n                if (this.clear) renderer.clear();\r\n                this.threshFsQuad.render(renderer);\r\n\r\n            }\r\n\r\n        }\r\n    }\r\n    \r\n    initNormalizeShader() {\r\n\r\n        const normShader = normalizeShader;\r\n\r\n        this.normUniforms = UniformsUtils.clone( normShader.uniforms );\r\n\r\n        this.normMaterial = new ShaderMaterial({\r\n\r\n            uniforms: this.normUniforms,\r\n            vertexShader: normShader.vertexShader,\r\n            fragmentShader: normShader.fragmentShader\r\n\r\n        })\r\n\r\n        this.normFsQuad = new FullScreenQuad(this.normMaterial);\r\n    \r\n    }\r\n\r\n    initThresholdShader() {\r\n\r\n        const threshShader = thresholdShader;\r\n\r\n        this.threshUniforms = UniformsUtils.clone( thresholdShader.uniforms );\r\n\r\n        this.threshMaterial = new ShaderMaterial({\r\n\r\n            uniforms: this.threshUniforms,\r\n            vertexShader: threshShader.vertexShader,\r\n            fragmentShader: threshShader.fragmentShader\r\n\r\n        })\r\n\r\n        this.threshFsQuad = new FullScreenQuad(this.threshMaterial);\r\n\r\n    }\r\n}\r\n\r\nexport default GpuComputePass;","import { ShaderMaterial, UniformsUtils, WebGLRenderTarget } from 'three';\r\nimport { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';\r\nimport { copyShader, copyStrongShader, dilationShader, hysteresisCombineShader } from './shaders';\r\n\r\nclass HysteresisPass extends Pass {\r\n\r\n    constructor ( tolerance, iterations, renderTarget, dims ) {\r\n\r\n        super();\r\n\r\n        this.iterations = iterations;\r\n\r\n        if (iterations == 0) this.initCopyShader();\r\n        this.initDilationShader(dims, tolerance);\r\n        this.initHysteresisShader();\r\n\r\n    }\r\n\r\n    render( renderer, writeBuffer, readBuffer) {\r\n\r\n        this.intermediateRt = writeBuffer.clone();\r\n\r\n        if (this.iterations == 0) {\r\n            \r\n            this.copyUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n            renderer.setRenderTarget(null);\r\n            this.copyFsQuad.render(renderer);\r\n\r\n        } else {\r\n\r\n            this.hysUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n            for (let i = 0; i < this.iterations; i++) {\r\n\r\n                this.uniforms[ 'tDiffuse' ].value = i == 0 ? readBuffer.texture : writeBuffer.texture;\r\n    \r\n                renderer.setRenderTarget(this.intermediateRt);\r\n                if (this.clear) renderer.clear();\r\n                this.fsQuad.render(renderer);\r\n\r\n                this.hysUniforms[ 'tDilate' ].value = this.intermediateRt.texture;\r\n\r\n                if ( i == this.iterations - 1  && this.renderToScreen) {\r\n    \r\n                    renderer.setRenderTarget(null);\r\n                    this.hysFsQuad.render(renderer);\r\n    \r\n                } else {\r\n    \r\n                    renderer.setRenderTarget(writeBuffer);\r\n                    if (this.clear) renderer.clear();\r\n                    this.hysFsQuad.render(renderer);\r\n    \r\n                }\r\n            }\r\n        }\r\n\r\n        this.intermediateRt.dispose();\r\n        delete this.intermediateRt;\r\n    }\r\n\r\n    initCopyShader() {\r\n\r\n        const cpyShader = copyShader;\r\n\r\n        this.copyUniforms = UniformsUtils.clone( cpyShader.uniforms );\r\n\r\n        this.copyMaterial = new ShaderMaterial({\r\n\r\n            uniforms: this.copyUniforms,\r\n            vertexShader: cpyShader.vertexShader,\r\n            fragmentShader: cpyShader.fragmentShader\r\n\r\n        })\r\n\r\n        this.copyFsQuad = new FullScreenQuad(this.copyMaterial);\r\n\r\n    }\r\n\r\n    initDilationShader(dims, tolerance) {\r\n\r\n        const shader = dilationShader;\r\n\r\n        this.uniforms = UniformsUtils.clone( shader.uniforms );\r\n        \r\n        this.material = new ShaderMaterial({\r\n\r\n            uniforms: this.uniforms,\r\n            vertexShader: shader.vertexShader,\r\n            fragmentShader: shader.fragmentShader\r\n        \r\n        });\r\n\r\n        if (dims !== undefined) this.uniforms.dims.value = dims;\r\n        if (tolerance !== undefined) this.uniforms.tolerance.value = tolerance;\r\n\r\n        this.fsQuad = new FullScreenQuad(this.material);\r\n    }\r\n\r\n    initHysteresisShader() {\r\n        const hysShader = hysteresisCombineShader;\r\n\r\n        this.hysUniforms = UniformsUtils.clone( hysShader.uniforms );\r\n\r\n        this.hysMaterial = new ShaderMaterial({\r\n\r\n            uniforms: this.hysUniforms,\r\n            vertexShader: hysShader.vertexShader,\r\n            fragmentShader: hysShader.fragmentShader\r\n            \r\n        })\r\n\r\n        this.hysFsQuad = new FullScreenQuad(this.hysMaterial);\r\n    }\r\n\r\n}\r\n\r\nexport default HysteresisPass;","import { ShaderMaterial, UniformsUtils } from 'three';\r\nimport { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';\r\nimport { copyStrongShader } from './shaders';\r\n\r\n// Copy only pixels above a threshold.\r\n// Value is currently hard-coded into the shader, could add as a uniform and pass in as an arg here.\r\nclass CopyStrongPass extends Pass {\r\n\r\n    constructor ( dims ) {\r\n\r\n        super();\r\n\r\n        this.initCopyShader();\r\n\r\n        if (dims !== null) this.copyUniforms.dims.value = dims;\r\n\r\n    }\r\n\r\n    render( renderer, writeBuffer, readBuffer ) {\r\n\r\n        this.copyUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n        if ( this.renderToScreen ) { \r\n            \r\n            renderer.setRenderTarget(null);\r\n            this.copyFsQuad.render(renderer);\r\n\r\n        } else {\r\n\r\n            renderer.setRenderTarget(writeBuffer);\r\n            if (this.clear) renderer.clear();\r\n            this.copyFsQuad.render(renderer);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    initCopyShader() {\r\n\r\n        const cpyShader = copyStrongShader;\r\n\r\n        this.copyUniforms = UniformsUtils.clone( cpyShader.uniforms );\r\n\r\n        this.copyMaterial = new ShaderMaterial({\r\n\r\n            uniforms: this.copyUniforms,\r\n            vertexShader: cpyShader.vertexShader,\r\n            fragmentShader: cpyShader.fragmentShader\r\n\r\n        })\r\n\r\n        this.copyFsQuad = new FullScreenQuad(this.copyMaterial);\r\n\r\n    }\r\n}\r\n\r\nexport default CopyStrongPass;","import { GPUComputationRenderer } from 'three/examples/jsm//misc/GPUComputationRenderer';\r\nimport { gradientMagnitudeFragShader, gradientArgumentFragShader, nmsFragShader} from \"./shaders\";\r\n\r\n// Helper func to init empty computation matrix as a texture.\r\nconst fillTextureWithZeros = (texture) => {\r\n    let arr = texture.image.data;\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        arr[i] = 0;\r\n    }\r\n}\r\n\r\nconst getSobelComputeRenderer = (gl, dims, kernel, doNMS) => {\r\n\r\n    let gpuCompute = new GPUComputationRenderer(dims[0], dims[1], gl);\r\n\r\n    let gradMagnitude = gpuCompute.createTexture();\r\n    fillTextureWithZeros( gradMagnitude );\r\n    let magnitudeVariable = gpuCompute.addVariable( 'textureMagnitude', gradientMagnitudeFragShader, gradMagnitude);\r\n\r\n    // Only compute arguments if we are doing NMS - otherwise only Mags are needed.\r\n    let argumentVariable;\r\n    let gradArgument;\r\n    if ( doNMS ) {\r\n\r\n        gradArgument = gpuCompute.createTexture();\r\n        fillTextureWithZeros( gradArgument );\r\n        argumentVariable = gpuCompute.addVariable( 'textureArgument', gradientArgumentFragShader, gradArgument);\r\n\r\n        gpuCompute.setVariableDependencies( magnitudeVariable, [ argumentVariable, magnitudeVariable ] );\r\n        gpuCompute.setVariableDependencies( argumentVariable, [ argumentVariable, magnitudeVariable ] );\r\n\r\n\r\n    } else {\r\n        \r\n        gpuCompute.setVariableDependencies( magnitudeVariable, [ magnitudeVariable ] );\r\n\r\n    }\r\n\r\n    let magnitudeUniforms = magnitudeVariable.material.uniforms;\r\n\r\n    magnitudeUniforms[ 'GX' ] = { value: kernel.gx }\r\n    magnitudeUniforms[ 'GY' ] = { value: kernel.gy }\r\n    magnitudeUniforms[ 'dim' ] = { value: dims }\r\n    magnitudeUniforms[ 'tDiffuse' ] = { value: null }\r\n\r\n\r\n    let argumentUniforms;\r\n    if ( doNMS ) {\r\n\r\n        argumentUniforms = argumentVariable.material.uniforms;\r\n\r\n        argumentUniforms[ 'GX' ] = { value: kernel.gx }\r\n        argumentUniforms[ 'GY' ] = { value: kernel.gy }\r\n        argumentUniforms[ 'dim' ] = { value: dims }\r\n        argumentUniforms[ 'tDiffuse' ] = { value: null }\r\n\r\n    }\r\n\r\n    const error = gpuCompute.init();\r\n\r\n    if (error !== null) {\r\n        console.error(error);\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        gpuCompute: gpuCompute,\r\n        magnitudeVariable: magnitudeVariable,\r\n        magnitudeUniforms, magnitudeUniforms,\r\n        argumentVariable: argumentVariable,\r\n        argumentUniforms: argumentUniforms,\r\n        texture: gradArgument,\r\n        texture_2: gradMagnitude\r\n    }\r\n}\r\n\r\nconst getNMSComputeRenderer = (gl, dims, doNMS) => {\r\n\r\n    // Don't necessarily want to init NMS renderer as sobel comes before NMS in canny steps. (Saves computation time).\r\n    if (!doNMS) return null;\r\n\r\n    let nmsGpuCompute = new GPUComputationRenderer(dims[0], dims[1], gl);\r\n\r\n    let nms = nmsGpuCompute.createTexture();\r\n    fillTextureWithZeros( nms );\r\n    let nmsVariable = nmsGpuCompute.addVariable( 'textureNms', nmsFragShader, nms );\r\n    \r\n    nmsGpuCompute.setVariableDependencies( nmsVariable, [nmsVariable] );\r\n\r\n    let nmsUniforms = nmsVariable.material.uniforms;\r\n    \r\n    nmsUniforms[ 'dim' ] = { value: dims }\r\n    nmsUniforms[ 'tMags' ] = { value: null }\r\n    nmsUniforms[ 'tArgs' ] = { value: null }\r\n\r\n    const error = nmsGpuCompute.init();\r\n\r\n    if (error !== null) { \r\n        console.error(error);\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        nmsGpuCompute: nmsGpuCompute,\r\n        nmsVariable: nmsVariable,\r\n        nmsUniforms: nmsUniforms,\r\n        textures: [nms]\r\n    }\r\n}\r\n\r\nconst getComputationRenderers = (gl, dims, kernel, doNMS) => {\r\n\r\n    let obj = {sobel: getSobelComputeRenderer(gl, dims, kernel, doNMS), nms: getNMSComputeRenderer(gl, dims, doNMS)};\r\n\r\n    return obj;\r\n}\r\n\r\n\r\nexport default getComputationRenderers;","// Truncate the kernel as it is symmetrical - half of this data is irrelevant.\r\nconst getSeparableKernel = (r, sigma) => {\r\n\r\n    // console.log(\"generated kernel\")\r\n\r\n    let sum = 0;\r\n    let arr = [];\r\n    let coefficient = 1/(Math.sqrt(2 * Math.PI) * sigma);\r\n    let exponent;\r\n    for (let i=0; i <= r; i++) {\r\n        exponent = Math.exp(-Math.pow(i, 2)/(2 * Math.pow(sigma, 2)))\r\n        arr[i] = coefficient * exponent;\r\n\r\n        // Kernel sum used in normalisation - account for the fact we only generate one half of the kernel:\r\n        sum += i === 0 ? arr[i] : 2 * arr[i];\r\n    }\r\n\r\n    // Normalise\r\n    for (let i = 0; i <= r; i++) {\r\n        arr[i] /= sum;\r\n    }\r\n\r\n    return arr;\r\n}\r\n\r\nexport {getSeparableKernel}","import { Canvas, extend, useFrame, useThree } from '@react-three/fiber';\r\nimport React, { useState, useRef, Suspense, useEffect } from 'react';\r\nimport FadeIn from 'react-fade-in';\r\nimport { Image, Slider, InputNumber, Button, Row, Col, Select, Spin } from 'antd';\r\nimport { ArrowLeftOutlined, LoadingOutlined } from '@ant-design/icons';\r\nimport ImageUploader from \"./imageUploader\";\r\nimport \"./main.scss\";\r\n\r\n// Shader-related imports\r\nimport ThreeImagePlane from \"./threeImagePlane\";\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';\r\nimport { GrayscalePass, HorizontalBlurPass, VerticalBlurPass, SobelPass, GpuComputePass, HysteresisPass, CopyStrongPass } from './shaders';\r\nimport getComputationRenderers from \"./shaders/getComputationRenderers\";\r\nimport { WebGLRenderTarget } from 'three';\r\n\r\nimport { getSeparableKernel } from \"./gaussianKernel\";\r\n\r\n// Make sure to extend shader components so they work with three-fiber\r\nextend({ EffectComposer, RenderPass, GrayscalePass, HorizontalBlurPass, VerticalBlurPass, SobelPass, GpuComputePass, HysteresisPass, CopyStrongPass });\r\n\r\nconst { Option } = Select;\r\n\r\n// Constants used for parameter selection:\r\n\r\n// Grayscale r, g, b channel weightings.\r\nconst grayScaleCoefficients = {\r\n    \"BT.601\" : [0.299, 0.587, 0.114],\r\n    \"BT.709\" : [0.2126, 0.7152, 0.0722],\r\n    \"BT.2100\" : [0.2627, 0.6780, 0.0593],\r\n    \"Mean\" : [0.3333, 0.3333, 0.3333]\r\n}\r\n\r\n// Edge detection kernels.\r\nconst edgefindingOperators = {\r\n\r\n    \"sobel\" : {\r\n        gx: [\r\n            1, 0, -1,\r\n            2, 0, -2,\r\n            1, 0, -1\r\n        ],\r\n\r\n        gy: [\r\n            1, 2, 1,\r\n            0, 0, 0,\r\n            -1,-2,-1\r\n        ]\r\n    },\r\n\r\n    \"prewitt\" : {\r\n        gx: [\r\n            1, 0, -1,\r\n            1, 0, -1,\r\n            1, 0, -1\r\n        ],\r\n\r\n        gy: [\r\n            1, 1, 1,\r\n            0, 0, 0,\r\n            -1,-1,-1\r\n        ]\r\n    }\r\n\r\n}\r\n\r\n\r\nconst Steps = () => {\r\n\r\n    // Store the step in the canny process that is currently shown.\r\n    const maxStep = 7;\r\n    const [step, setStep] = useState(0);\r\n\r\n    // Set a ref to the container of the processed image so it can be centered.\r\n    const ImgContainerRef = useRef();\r\n    const [shaderDisplayDim, setDisplayDim] = useState({width: 0, height: 0});\r\n\r\n    // Data about the uploaded image (dimensions and pixel content).\r\n    const [imgDims, setImgDims] = useState(null);\r\n    const [imgSource, setImgSourceVar] = useState(null);\r\n\r\n    // Whether or not to display the image uploader.\r\n    const [uploadVisibility, setUploadVisibility] = useState(true);\r\n\r\n    const [intermediateRT, setIntermediateRT] = useState(null);\r\n\r\n    // Canny algorithm parameters.\r\n    const [selectedGrayscaleTag, setSelectedGrayscaleTag] = useState(\"BT.601\")\r\n    const [selectedGrayscaleEncoding, setSelectedGrayscaleEncoding] = useState(grayScaleCoefficients[selectedGrayscaleTag]);\r\n\r\n    const [gaussRadius, setGaussRadius] = useState(3);\r\n    const [gaussSigma, setGaussSigma] = useState(1);\r\n\r\n    const [selectedEdgeTag, setSelectedEdgeTag] = useState(\"sobel\")\r\n    const [selectedEdgeOperator, setSelectedEdgeOperator] = useState(edgefindingOperators[selectedEdgeTag])\r\n\r\n    const [lowThreshold, setLowThreshold] = useState(0.3);\r\n    const [highThreshold, setHighThreshold] = useState(0.3);\r\n\r\n    const [hysteresisTolerance, setTolerance] = useState(1);\r\n    const [hysteresisIters, setHysteresisIters] = useState(1);\r\n\r\n    // Memoization\r\n\r\n    // Setting up make-shift compute shaders is quite time costly hence the memoization\r\n    const [memoRenderers, setMemoRenderers] = useState(null);\r\n    const [memoRendererParams, setMemoRendererParams] = useState(null);\r\n\r\n    // Calculating gaussian kernel is quite fast but for larger kernels this will improve the framerate.\r\n    const [memoGaussParams, setMemoGaussParams] = useState(null);\r\n    const [memoGauss, setMemoGauss] = useState(null);\r\n\r\n    // WebGL reference for saving image (cannot be done through Canvas obj itself).\r\n    const [rendererRef, setRendererRef] = useState(null);\r\n    const [savingState, setSavingState] = useState(false);\r\n\r\n    const _getDisplay = ({reverse = false, value = \"block\"} = {}) => {\r\n        if (reverse) return uploadVisibility ? \"none\" : value;\r\n        return uploadVisibility ? value : \"none\";\r\n    }\r\n\r\n    const setImgSource = (v) => {\r\n        // Revoke previous img URL if exists to prevent memory leaks.\r\n        if (imgSource) URL.revokeObjectURL(imgSource);\r\n        setImgSourceVar(v);\r\n    }\r\n\r\n    const onImageUpload = data => {\r\n        setImgSource(data.src);\r\n        setImgDims(data.dim);\r\n        setUploadVisibility(false);\r\n    }\r\n\r\n    // Return to upload screen.\r\n    const goBack = () => {\r\n        setImgSource(null);\r\n        setImgDims(null);\r\n        setUploadVisibility(true);\r\n    }\r\n\r\n    // Ensure step counter increments and decrements in range 0 -> {maxSteps}\r\n    const hasNextStep = (step) => {\r\n        return 0 <= step && step < maxStep;\r\n    }\r\n\r\n    const stepTitles = {\r\n        0: \"Grayscale Encoding\",\r\n        1: \"Gaussian Blur\",\r\n        2: \"Edgefinding Operation\",\r\n        3: \"Non-maximum suppression\",\r\n        4: \"Double Threshold\",\r\n        5: \"Edge-Tracking (Hysteresis)\",\r\n        6: \"Final Image\"\r\n    }\r\n\r\n    // Map for option UI (React components) per step No.\r\n    const stepOptions = {\r\n        \r\n        0: (\r\n            <>\r\n                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                    <Col flex=\"120px\">Encoding Type</Col>\r\n                    <Col flex=\"auto\">\r\n                        <Select defaultValue={selectedGrayscaleTag} onChange={v => {setSelectedGrayscaleTag(v); setSelectedGrayscaleEncoding(grayScaleCoefficients[v])}}>\r\n                            <Option value=\"BT.601\">BT.601</Option>\r\n                            <Option value=\"BT.709\">BT.709</Option>\r\n                            <Option value=\"BT.2100\">BT.2100</Option>\r\n                            <Option value=\"Mean\">Mean</Option>\r\n                        </Select>\r\n                    </Col>\r\n                </Row>\r\n            </>\r\n        ),\r\n\r\n        1: (\r\n            <>\r\n                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                    <Col flex=\"60px\">Radius</Col>\r\n                    <Col flex=\"auto\"><Slider value={gaussRadius} onChange={v => setGaussRadius(v)} min={0} max={20}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={gaussRadius} onChange={v => setGaussRadius(v) } min={0} max={20}/></Col>\r\n                </Row>\r\n                \r\n                <Row style={{display: \"flex\", alignItems: \"center\"}}>\r\n                    <Col flex=\"60px\">Sigma ()</Col>\r\n                    <Col flex=\"auto\"><Slider defaultValue={gaussSigma} onChange={v => setGaussSigma(v)} min={0.01} max={15} step={0.01}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={gaussSigma} onChange={v => setGaussSigma(v) } min={0} max={20} step={0.01}/></Col>\r\n                </Row>\r\n            </>\r\n        ),\r\n\r\n        2: (\r\n            <>\r\n                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                    <Col flex=\"70px\">Operator</Col>\r\n                    <Col flex=\"auto\">\r\n                        <Select defaultValue={selectedEdgeTag} onChange={v => {setSelectedEdgeTag(v); setSelectedEdgeOperator(edgefindingOperators[v])}}>\r\n                            <Option value=\"sobel\">Sobel</Option>\r\n                            <Option value=\"prewitt\">Prewitt</Option>\r\n                        </Select>\r\n                    </Col>\r\n                </Row>\r\n            </>\r\n        ),\r\n\r\n        3: (<p><i>(No options available)</i></p>),\r\n\r\n        4: (\r\n            <>\r\n                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                    <Col flex=\"60px\">High</Col>\r\n                    <Col flex=\"auto\"><Slider value={highThreshold} onChange={v => setHighThreshold(v)} min={0} max={1} step={0.01}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={highThreshold} onChange={v => setHighThreshold(v) } min={0} max={1} step={0.01}/></Col>\r\n                </Row>\r\n                \r\n                <Row style={{display: \"flex\", alignItems: \"center\"}}>\r\n                    <Col flex=\"60px\">Low</Col>\r\n                    <Col flex=\"auto\"><Slider value={lowThreshold} onChange={v => setLowThreshold(v)} min={0} max={1} step={0.01}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={lowThreshold} onChange={v => setLowThreshold(v) } min={0} max={1} step={0.01}/></Col>\r\n\r\n                </Row>\r\n            </>\r\n        ),\r\n\r\n        5: (\r\n            <>\r\n                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                    <Col flex=\"100px\">Tolerance (px)</Col>\r\n                    <Col flex=\"auto\"><Slider value={hysteresisTolerance} onChange={v => setTolerance(v)} min={0} max={5}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={hysteresisTolerance} onChange={v => setTolerance(v) } min={0} max={5}/></Col>\r\n                </Row>\r\n\r\n                <Row style={{display: \"flex\", alignItems: \"center\"}}>\r\n                    <Col flex=\"100px\">Iterations</Col>\r\n                    <Col flex=\"auto\"><Slider value={hysteresisIters} onChange={v => setHysteresisIters(v)} min={0} max={500}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={hysteresisIters} onChange={v => setHysteresisIters(v) } min={0} max={500}/></Col>\r\n                </Row>\r\n            </>\r\n        )\r\n    }\r\n\r\n    const downloadCanvas = async () => {\r\n        if (rendererRef) {\r\n\r\n            // Set a flag to indicate saving has begun.\r\n            setSavingState(true);\r\n\r\n            // Put img conversion in promise to make asynchronous.\r\n            new Promise(resolve => {\r\n\r\n                setTimeout(() => {\r\n\r\n                    let img = rendererRef.domElement.toDataURL();\r\n                    resolve(img);\r\n                    \r\n                }, 30);\r\n\r\n            }).then(img => {\r\n\r\n                // Automatically download image from created data URL.\r\n                let link = document.createElement(\"a\");\r\n                link.download = \"Canny_Step_\" + step;\r\n                link.href = img;\r\n                link.click();\r\n                // Set flag to indicate saving has finished.\r\n                setSavingState(false);\r\n            })\r\n\r\n        }\r\n    }\r\n\r\n    const disposeRenderers = currentRenderers => {\r\n\r\n        // Go through each attribute of the renderers and dispose of them manually if applicable. Three fiber does not automatically dispose these renderers.\r\n        if (currentRenderers) {\r\n            // Separation of sobel and nms renderers here as same obj structure is used for both i.e {sobel: ..., nms: none} for a sobel computation renderer.\r\n            if (currentRenderers.sobel) {\r\n                for (const [k, v] of Object.entries(currentRenderers.sobel)) {\r\n                    if (v) {\r\n                        if (v.dispose) v.dispose();\r\n                        delete currentRenderers.sobel[k];\r\n                    };\r\n                }\r\n                currentRenderers.sobel = null;\r\n            }\r\n\r\n            if (currentRenderers.nms) {\r\n                for (const [k, v] of Object.entries(currentRenderers.nms)) {\r\n                    if (v) {\r\n                        if (v.dispose) v.dispose();\r\n                        delete currentRenderers.nms[k];\r\n                    };\r\n                }\r\n                currentRenderers.nms = null;\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    const GetStepShaders = (step, gl) => {\r\n\r\n        // Do manual memoization here of kernel and renderers as useMemo() does not have expected performance\r\n        // (Unsure why as of now, though this works fine. Just a little more verbose).\r\n\r\n        let currentKernel = memoGauss;\r\n        let gaussParams = {r: gaussRadius, s: gaussSigma}\r\n        if (memoGaussParams == null) {\r\n            setMemoGaussParams(gaussParams);\r\n\r\n            currentKernel = getSeparableKernel(gaussParams.r, gaussParams.s);\r\n            setMemoGauss(currentKernel);\r\n        }\r\n\r\n        else if (gaussParams.r != memoGaussParams.r || gaussParams.s != memoGaussParams.s) {\r\n\r\n            setMemoGaussParams(gaussParams);\r\n\r\n            currentKernel = getSeparableKernel(gaussParams.r, gaussParams.s);\r\n            setMemoGauss(currentKernel);\r\n\r\n        }\r\n\r\n        // Use most recent kernel from after memoization.\r\n        const kernel = currentKernel;\r\n        const kernelSize = kernel.length;\r\n\r\n        // Memo renderers & their parameters in the same fashion as the kernel.\r\n        let currentRenderers = memoRenderers;\r\n        let renderParams = {gl: gl, dims: [ImgContainerRef.current.offsetWidth, ImgContainerRef.current.offsetHeight], kernel: selectedEdgeOperator, doNMS: (step > 2)}\r\n\r\n        if (memoRendererParams == null) {\r\n            setMemoRendererParams(renderParams);\r\n\r\n            currentRenderers = getComputationRenderers(renderParams.gl, renderParams.dims, renderParams.kernel, renderParams.doNMS);\r\n            setMemoRenderers(currentRenderers)\r\n            \r\n        }\r\n\r\n        // An intermediate Render Target is needed to transfer information from one computation renderer to the next; this is essentially a replacement for the render buffer.\r\n        if (intermediateRT == null) {\r\n            setIntermediateRT({tg: new WebGLRenderTarget(renderParams.dims.x, renderParams.dims.y)});\r\n        }\r\n        \r\n        // TODO: This is verbose, ensure obj comparison i.e. (renderParams != memoRendererParams) has expected behaviour to reduce this if statement.\r\n        else if (renderParams.gl != memoRendererParams.gl \r\n            || renderParams.dims[0] != memoRendererParams.dims[0]\r\n            || renderParams.dims[1] != memoRendererParams.dims[1]\r\n            || renderParams.kernel != memoRendererParams.kernel\r\n            || renderParams.doNMS != memoRendererParams.doNMS) {\r\n\r\n                // Update the current memoized parameters.\r\n                setMemoRendererParams(renderParams);\r\n\r\n                // Before updating the renderers ref, dispose of ALL objects from the custom renderer to avoid HUGE memory leaks (three-fiber doesn't auto-dispose these).\r\n                disposeRenderers(currentRenderers);\r\n\r\n                // Create new renderers (costly, hence memoization).\r\n                currentRenderers = getComputationRenderers(renderParams.gl, renderParams.dims, renderParams.kernel, renderParams.doNMS);\r\n                setMemoRenderers(currentRenderers)\r\n                \r\n                // If the image dimensions have changed (due to screen resize, etc.), the shape of the make-shift render buffer (render target) must be changed accordingly.\r\n                if (renderParams.dims[0] != memoRendererParams.dims[0] || renderParams.dims[1] != memoRendererParams.dims[1]) {\r\n                    \r\n                    // Manual dispose of previous render target.\r\n                    if (intermediateRT.tg) {\r\n                        if (intermediateRT.tg.dispose) intermediateRT.tg.dispose();\r\n                        delete intermediateRT.tg;\r\n                    }\r\n                    \r\n                    setIntermediateRT({tg: new WebGLRenderTarget(renderParams.dims.x, renderParams.dims.y)});\r\n                }\r\n        }\r\n\r\n        // Sequence of shaders to be put into the post-processing passes (Threejs EffectComposer).\r\n        // only include shaders up to the current step to enable each step of the process to be previewed.\r\n        return (\r\n            <>\r\n                {step >= 0 ? <grayscalePass attachArray=\"passes\" args={[selectedGrayscaleEncoding]} /> : null}\r\n                {step >= 1 ?  \r\n                <>\r\n                    <horizontalBlurPass attachArray=\"passes\" args={[kernel, kernelSize, ImgContainerRef.current.offsetWidth]} />\r\n                    <verticalBlurPass attachArray=\"passes\" args={[kernel, kernelSize, ImgContainerRef.current.offsetHeight]} />\r\n                </>\r\n                : null}\r\n                {step == 2 ? <gpuComputePass attachArray=\"passes\" args={[currentRenderers.sobel, currentRenderers.nms, renderParams.dims, false, null]} /> : null}\r\n                {step == 3 ? <gpuComputePass attachArray=\"passes\" args={[currentRenderers.sobel, currentRenderers.nms, renderParams.dims, true, null]} /> : null}\r\n                {step >= 4 ? <gpuComputePass attachArray=\"passes\" args={[currentRenderers.sobel, currentRenderers.nms, renderParams.dims, true, {high: highThreshold, low: lowThreshold}]} /> : null}\r\n                {step >= 5 ? <hysteresisPass attachArray=\"passes\" args={[hysteresisTolerance, hysteresisIters, intermediateRT.tg, renderParams.dims]}/> : null}\r\n                {step >= 6 ? <copyStrongPass attachArray=\"passes\" args={[renderParams.dims]}/> : null}\r\n            </>\r\n        )\r\n    }\r\n\r\n    // Wrap options in container for css styling.\r\n    const getOptions = (step) => {\r\n\r\n        return (\r\n            <div className=\"processor-options\">\r\n                {stepOptions[step]}\r\n            </div>\r\n        )\r\n    }\r\n\r\n    const Shaders = () => {\r\n        const composer = useRef();\r\n        const { scene, gl, size, camera } = useThree();\r\n\r\n        // Save GL environment to state to allow downloading of the canvas.\r\n        if (gl != rendererRef) {\r\n            setRendererRef(gl);\r\n        }\r\n\r\n        // Render post-processing once on mount.\r\n        useEffect(() => composer.current.render(), []);\r\n        // Render on each frame thereafter.\r\n        useFrame(() => composer.current.render(), 1);\r\n\r\n        return (\r\n            <effectComposer ref={composer} args={[gl]}>\r\n                <renderPass attachArray=\"passes\" scene={scene} camera={camera} />\r\n                {GetStepShaders(step, gl)}\r\n            </effectComposer>\r\n        )\r\n    }\r\n\r\n    return (\r\n\r\n        <div className=\"fill-container\">\r\n\r\n            <FadeIn visible={uploadVisibility}>\r\n                <ImageUploader onLoadCallback={onImageUpload} style={{display: _getDisplay()}}/>\r\n            </FadeIn>\r\n\r\n            {(imgSource != null && imgDims != null) ? (\r\n                <div className=\"fill-container\">\r\n                    <FadeIn className=\"fill-and-vertically-center\">\r\n\r\n                        <Row gutter={[16,16]} justify=\"center\" align=\"middle\" style={{display: \"flex\", alignItems: \"center\"}}>\r\n\r\n                            {/* Input image */}\r\n                            <Col className=\"process-preview-grid-col\" flex={1}>\r\n                                <div className=\"process-preview-container\" ><div ref={ImgContainerRef}><Image id=\"preview-before\" src={imgSource} onLoad={() => setDisplayDim({width: ImgContainerRef.current.offsetWidth, height: ImgContainerRef.current.offsetHeight})} /></div></div>\r\n                            </Col>\r\n\r\n                            {/* Processed Image */}\r\n                            <Col className=\"process-preview-grid-col\" flex={1}>\r\n                                <div className=\"process-preview-container\">\r\n                                    <Canvas \r\n                                        className=\"shader\"\r\n                                        camera={{fov: 50, position: [0, 0, 30]}}\r\n                                        gl={{preserveDrawingBuffer: true}}\r\n                                        style={{position: \"relative\", width: shaderDisplayDim.width, height: shaderDisplayDim.height}}\r\n                                    >\r\n                                        <Suspense fallback=\"Loading...\">\r\n                                            <ThreeImagePlane img={imgSource} dim={{width: imgDims.width, height: imgDims.height}}/>\r\n                                        </Suspense>\r\n                                        <Shaders />\r\n                                    </Canvas>\r\n                                </div>\r\n                            </Col>\r\n                            \r\n                            {/* Processing parameters */}\r\n                            <Col className=\"process-preview-grid-col\" flex={1} style={{alignSelf: \"stretch\"}}>\r\n                                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                                    <Col ><Button onClick={() => setStep(prev => prev - 1)} disabled={!hasNextStep(step - 1)}>Previous</Button></Col>\r\n                                    <Col flex=\"auto\" align=\"center\"><h1 id=\"title\" style={{display: \"inline-block\", alignSelf: \"center\"}}><b>{stepTitles[step]}</b></h1></Col>\r\n                                    <Col align=\"right\" style={{paddingRight: \"5px\"}}><Button onClick={() => setStep(prev => prev + 1)} disabled={!hasNextStep(step + 1)} style={{float: \"right\"}}>Next</Button></Col>\r\n                                    <Col align=\"right\"><Button type=\"primary\" onClick={downloadCanvas} style={{float: \"right\"}}>{savingState ? <Spin size=\"middle\" indicator={<LoadingOutlined spin style={{color: \"white\"}}/>}/> : \"Save\"}</Button></Col>\r\n                                </Row>\r\n                                {getOptions(step)}\r\n                            </Col>\r\n\r\n                        </Row>\r\n                    </FadeIn>\r\n                    \r\n                    <FadeIn className=\"back-overlay\" visible={!uploadVisibility}>\r\n                        <Button id=\"button\"\r\n                            type=\"link\" \r\n                            style={{fontSize: \"15px\"}}\r\n                            onClick={() => {disposeRenderers(memoRenderers); goBack()}}\r\n                        >\r\n                            <ArrowLeftOutlined /> \r\n                            Change image\r\n                        </Button> \r\n                    </FadeIn>\r\n\r\n                </div>\r\n            ) : null}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport {Steps}; ","import React, { useState } from 'react'\r\nimport { notification } from 'antd';\r\nimport { WarningTwoTone } from '@ant-design/icons';\r\nimport { Steps } from './steps';\r\nimport \"./main.scss\";\r\n\r\n\r\nconst Main = () => {\r\n\r\n    // Only send notif once per acces to this route - not using state would make this notif appear on every re-render.\r\n    const [notifSent, setNotifSent] = useState(false);\r\n\r\n    const performanceNotification = () => {\r\n        if (notifSent === false) {\r\n            notification.open({\r\n                message: \"This project works best on a powerful machine!\",\r\n                description: <span>This page uses WebGL - a dedicated GPU is STRONGLY recommended.<br />Loading images which are too large or updating parameters too quickly <i>may</i> cause the browser to run out of memory.</span>,\r\n                icon: <WarningTwoTone twoToneColor=\"#FFA500\" />,\r\n                key: \"performance-notif\",\r\n                style: {width: 500}\r\n            });\r\n            setNotifSent(true);\r\n        }\r\n    }\r\n\r\n    performanceNotification();\r\n\r\n    return (\r\n        <div className=\"fill-container\">\r\n            {Steps()}\r\n        </div>\r\n    );\r\n}   \r\n\r\nexport default Main;"],"names":["Dragger","Upload","UploadIcon","_ref","loading","_jsx","LoadingOutlined","spin","InboxOutlined","_ref2","onLoadCallback","style","loadingImage","setLoadingImage","useState","_jsxs","name","multiple","listType","className","showUploadList","customRequest","async","file","onSuccess","_ref3","Promise","resolve","setTimeout","src","URL","createObjectURL","img","Image","onload","dim","width","height","then","data","beforeUpload","type","message","error","onChange","info","status","response","console","log","children","image","useLoader","TextureLoader","minFilter","LinearFilter","factor","arguments","length","undefined","viewport","v","aspect","useThree","adaptedHeight","useAspect","scale","attach","map","depthTest","toneMapped","GrayscaleShader","uniforms","value","Vector3","vertexShader","fragmentShader","hGaussianBlur","Array","vGaussianBlur","sobelShader","Vector2","normalizeShader","thresholdShader","dilationShader","hysteresisCombineShader","copyStrongShader","copyShader","GrayscalePass","Pass","constructor","weights","super","shader","this","UniformsUtils","clone","material","ShaderMaterial","fsQuad","FullScreenQuad","render","renderer","writeBuffer","readBuffer","texture","renderToScreen","setRenderTarget","clear","HorizontalBlurPass","kernel","kernelSize","hRes","vRes","SobelPass","gx","gy","GX","GY","GpuComputePass","sobelParams","nmsParams","doNMS","threshold","dims","gpuCompute","magnitudeVariable","magnitudeUniforms","argumentVariable","argumentUniforms","nmsGpuCompute","nmsVariable","nmsUniforms","initNormalizeShader","initThresholdShader","renderTarget","compute","getCurrentRenderTarget","read","Float32Array","readRenderTargetPixels","max","i","normUniforms","normFsQuad","hi","high","threshUniforms","low","threshFsQuad","normShader","normMaterial","threshShader","threshMaterial","HysteresisPass","tolerance","iterations","initCopyShader","initDilationShader","initHysteresisShader","intermediateRt","copyUniforms","copyFsQuad","hysUniforms","hysFsQuad","dispose","cpyShader","copyMaterial","hysShader","hysMaterial","CopyStrongPass","fillTextureWithZeros","arr","getSobelComputeRenderer","gl","GPUComputationRenderer","gradMagnitude","createTexture","gradArgument","addVariable","setVariableDependencies","init","texture_2","getNMSComputeRenderer","nms","textures","getComputationRenderers","sobel","getSeparableKernel","r","sigma","exponent","sum","coefficient","Math","sqrt","PI","exp","pow","extend","EffectComposer","RenderPass","VerticalBlurPass","Option","Select","grayScaleCoefficients","edgefindingOperators","Steps","step","setStep","ImgContainerRef","useRef","shaderDisplayDim","setDisplayDim","imgDims","setImgDims","imgSource","setImgSourceVar","uploadVisibility","setUploadVisibility","intermediateRT","setIntermediateRT","selectedGrayscaleTag","setSelectedGrayscaleTag","selectedGrayscaleEncoding","setSelectedGrayscaleEncoding","gaussRadius","setGaussRadius","gaussSigma","setGaussSigma","selectedEdgeTag","setSelectedEdgeTag","selectedEdgeOperator","setSelectedEdgeOperator","lowThreshold","setLowThreshold","highThreshold","setHighThreshold","hysteresisTolerance","setTolerance","hysteresisIters","setHysteresisIters","memoRenderers","setMemoRenderers","memoRendererParams","setMemoRendererParams","memoGaussParams","setMemoGaussParams","memoGauss","setMemoGauss","rendererRef","setRendererRef","savingState","setSavingState","setImgSource","revokeObjectURL","hasNextStep","stepOptions","_Fragment","Row","display","alignItems","paddingBottom","Col","flex","defaultValue","Slider","min","align","InputNumber","disposeRenderers","currentRenderers","k","Object","entries","GetStepShaders","currentKernel","gaussParams","s","renderParams","current","offsetWidth","offsetHeight","tg","WebGLRenderTarget","x","y","attachArray","args","Shaders","composer","scene","size","camera","useEffect","useFrame","ref","FadeIn","visible","ImageUploader","reverse","_getDisplay","gutter","justify","id","onLoad","Canvas","fov","position","preserveDrawingBuffer","Suspense","fallback","ThreeImagePlane","alignSelf","Button","onClick","prev","disabled","paddingRight","float","domElement","toDataURL","link","document","createElement","download","href","click","Spin","indicator","color","getOptions","fontSize","ArrowLeftOutlined","Main","notifSent","setNotifSent","notification","open","description","icon","WarningTwoTone","twoToneColor","key"],"sourceRoot":""}