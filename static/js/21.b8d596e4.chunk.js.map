{"version":3,"sources":["projects/Webgl-Canny/src/imageUploader.jsx","projects/Webgl-Canny/src/threeImagePlane.jsx","projects/Webgl-Canny/src/shaders/shaders.jsx","projects/Webgl-Canny/src/shaders/grayscalePass.js","projects/Webgl-Canny/src/shaders/horizontalBlurPass.js","projects/Webgl-Canny/src/shaders/verticalBlurPass.js","projects/Webgl-Canny/src/shaders/sobelPass.js","projects/Webgl-Canny/src/shaders/gpuComputePass.js","projects/Webgl-Canny/src/shaders/hysteresisPass.js","projects/Webgl-Canny/src/shaders/copyStrongPass.js","projects/Webgl-Canny/src/shaders/getComputationRenderers.jsx","projects/Webgl-Canny/src/gaussianKernel.jsx","projects/Webgl-Canny/src/steps.jsx","projects/Webgl-Canny/src/main.jsx"],"names":["Dragger","Upload","UploadIcon","loading","LoadingOutlined","spin","InboxOutlined","ImageUploader","onLoadCallback","style","useState","loadingImage","setLoadingImage","loadImageLocally","a","file","onSuccess","Promise","resolve","setTimeout","src","URL","createObjectURL","img","Image","onload","dim","width","height","then","data","name","multiple","listType","className","showUploadList","customRequest","beforeUpload","type","message","error","onChange","info","status","response","console","log","ThreeImagePlane","image","useLoader","TextureLoader","minFilter","LinearFilter","factor","useThree","v","viewport","aspect","adaptedHeight","useAspect","scale","attach","map","depthTest","toneMapped","GrayscaleShader","uniforms","value","Vector3","vertexShader","fragmentShader","hGaussianBlur","Array","vGaussianBlur","sobelShader","Vector2","normalizeShader","thresholdShader","dilationShader","hysteresisCombineShader","copyStrongShader","copyShader","GrayscalePass","weights","shader","UniformsUtils","clone","material","ShaderMaterial","undefined","fsQuad","FullScreenQuad","renderer","writeBuffer","readBuffer","this","texture","renderToScreen","setRenderTarget","render","clear","Pass","HorizontalBlurPass","kernel","kernelSize","hRes","vRes","SobelPass","gx","gy","GX","GY","GpuComputePass","sobelParams","nmsParams","doNMS","threshold","dims","gpuCompute","magnitudeVariable","magnitudeUniforms","argumentVariable","argumentUniforms","nmsGpuCompute","nmsVariable","nmsUniforms","initNormalizeShader","initThresholdShader","renderTarget","compute","getCurrentRenderTarget","read","Float32Array","readRenderTargetPixels","max","i","length","normUniforms","normFsQuad","hi","high","threshUniforms","low","threshFsQuad","normShader","normMaterial","threshShader","threshMaterial","HysteresisPass","tolerance","iterations","initCopyShader","initDilationShader","initHysteresisShader","intermediateRt","copyUniforms","copyFsQuad","hysUniforms","hysFsQuad","dispose","cpyShader","copyMaterial","hysShader","hysMaterial","CopyStrongPass","fillTextureWithZeros","arr","getSobelComputeRenderer","gl","GPUComputationRenderer","gradMagnitude","createTexture","gradArgument","addVariable","setVariableDependencies","init","getNMSComputeRenderer","nms","textures","getComputationRenderers","sobel","getSeparableKernel","r","sigma","exponent","sum","coefficient","Math","sqrt","PI","exp","pow","extend","EffectComposer","RenderPass","VerticalBlurPass","Option","Select","grayScaleCoefficients","edgefindingOperators","Steps","step","setStep","ImgContainerRef","useRef","shaderDisplayDim","setDisplayDim","imgDims","setImgDims","imgSource","setImgSourceVar","uploadVisibility","setUploadVisibility","intermediateRT","setIntermediateRT","selectedGrayscaleTag","setSelectedGrayscaleTag","selectedGrayscaleEncoding","setSelectedGrayscaleEncoding","gaussRadius","setGaussRadius","gaussSigma","setGaussSigma","selectedEdgeTag","setSelectedEdgeTag","selectedEdgeOperator","setSelectedEdgeOperator","lowThreshold","setLowThreshold","highThreshold","setHighThreshold","hysteresisTolerance","setTolerance","hysteresisIters","setHysteresisIters","memoRenderers","setMemoRenderers","memoRendererParams","setMemoRendererParams","memoGaussParams","setMemoGaussParams","memoGauss","setMemoGauss","rendererRef","setRendererRef","savingState","setSavingState","setImgSource","revokeObjectURL","hasNextStep","stepOptions","0","display","alignItems","paddingBottom","flex","defaultValue","1","min","align","2","3","4","5","downloadCanvas","domElement","toDataURL","link","document","createElement","download","href","click","disposeRenderers","currentRenderers","Object","entries","k","GetStepShaders","currentKernel","gaussParams","s","renderParams","current","offsetWidth","offsetHeight","tg","WebGLRenderTarget","x","y","attachArray","args","Shaders","composer","scene","camera","size","useEffect","useFrame","ref","visible","reverse","_getDisplay","gutter","justify","id","onLoad","fov","position","preserveDrawingBuffer","fallback","alignSelf","onClick","prev","disabled","6","paddingRight","float","indicator","color","getOptions","fontSize","ArrowLeftOutlined","Main","notifSent","setNotifSent","notification","open","description","icon","WarningTwoTone","twoToneColor","key"],"mappings":"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","file":"static/js/21.b8d596e4.chunk.js","sourcesContent":["import React, { useState } from 'react'\r\nimport { message, Upload } from 'antd'\r\nimport { InboxOutlined, LoadingOutlined } from '@ant-design/icons';\r\nconst { Dragger } = Upload;\r\n\r\nconst UploadIcon = ({loading}) => {\r\n    return (\r\n        loading ? <LoadingOutlined spin /> : <InboxOutlined />\r\n    )\r\n}\r\n\r\nconst ImageUploader = ({onLoadCallback, style}) => {\r\n\r\n    const [loadingImage, setLoadingImage] = useState(false);\r\n\r\n    // Load image from the uploaded file.\r\n    // Antd usually expects an API call for uploading files, so this works the same way as an API call.\r\n    const loadImageLocally = async ({ file, onSuccess }) => {\r\n\r\n        new Promise(resolve => {\r\n\r\n            setTimeout(() => {\r\n\r\n                let src = URL.createObjectURL(file);\r\n                let img = new Image();\r\n                img.onload = () => {\r\n                    resolve({src: src, dim: {width: img.width, height: img.height}})\r\n                }\r\n                img.src = src;\r\n\r\n            }, 30);\r\n        }).then(data => onSuccess(data));\r\n    }\r\n\r\n    // Handle status of uploading file from antd component.\r\n    const handleChange = info => {\r\n        if (info.file.status === \"uploading\") {\r\n            setLoadingImage(true);\r\n        } else if (info.file.status === \"done\") {\r\n            setLoadingImage(false);\r\n            onLoadCallback(info.file.response);\r\n        } else {\r\n            setLoadingImage(false);\r\n            console.log(info.file.status);\r\n        }\r\n    }\r\n\r\n    const validateUpload = file => {\r\n        // TODO: I *think* more than these file formats can be handled as well, but they should be tested individually to check.\r\n        const validFormat = (\r\n            file.type === \"image/png\" || file.type ===\"image/jpeg\"\r\n        );\r\n        if (!validFormat) {\r\n            message.error(\"Only PNG/JPEG files are supported.\")\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    return (\r\n        <Dragger style={style}\r\n            name=\"source-image\"\r\n            multiple={false}\r\n            listType=\"picture-card\"\r\n            className=\"src-img-uploader\"\r\n            showUploadList={false}\r\n            customRequest={loadImageLocally}\r\n            beforeUpload={validateUpload}\r\n            onChange={handleChange}\r\n        >\r\n            <p className=\"ant-upload-drag-icon\">\r\n                <UploadIcon loading={loadingImage} />\r\n            </p>\r\n            <p className=\"ant-upload-text\">\r\n                {\"Click or drag an image to this area to begin\"}\r\n            </p>\r\n            <p className=\"ant-upload-hint\">\r\n                (large images may take a long time to process)\r\n            </p>\r\n        </Dragger>\r\n    );\r\n}\r\n\r\nexport default ImageUploader;","import React from 'react';\r\nimport { TextureLoader, LinearFilter } from 'three';\r\nimport { useLoader, useThree } from 'react-three-fiber';\r\n\r\n// Custom Three.js component - Image projected onto plane which fills the entirety of the viewport.\r\n\r\n// Calculates necessary width/height to be projected fully (factor = 1) onto threejs camera.\r\nconst useAspect = (width, height, factor = 1) => {\r\n    const { viewport: v, aspect } = useThree();\r\n    const adaptedHeight = height * (aspect > width / height ? v.width / width : v.height / height);\r\n    const adaptedWidth = width * (aspect > width / height ? v.width / width : v.height / height);\r\n    return [adaptedWidth * factor, adaptedHeight * factor, 1];\r\n}\r\n\r\nconst ThreeImagePlane = ({img, dim}) => {\r\n\r\n    const image = useLoader(TextureLoader, img);\r\n    // Use a linear filter to avoid sharp edges in the preview from the camera.\r\n    image.minFilter = LinearFilter;\r\n\r\n\r\n    const [width, height] = useAspect(dim.width, dim.height);\r\n\r\n    return (\r\n        <mesh scale={[width, height, 1]}>\r\n            <planeBufferGeometry attach=\"geometry\"/>\r\n            <meshBasicMaterial attach=\"material\" map={image} depthTest={false} toneMapped={false}/>\r\n        </mesh>\r\n    )\r\n}\r\n\r\nexport default ThreeImagePlane;","import { Vector3, Vector2 } from 'three';\r\n\r\n// Fragment and vertex shaders for postprocessing passes.\r\n\r\nconst GrayscaleShader = {\r\n\r\n\tuniforms: {\r\n\t\t'tDiffuse': { value: null },\r\n        'weights': { value: new Vector3() }\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\t\tvarying vec2 vUv;\r\n\t\tvoid main() {\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\t\tuniform float opacity;\r\n\t\tuniform sampler2D tDiffuse;\r\n        uniform vec3 weights;\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\r\n            float w_a = weights.x * texel.x + weights.y * texel.y + weights.z * texel.z;\r\n\t\t\tgl_FragColor = vec4(w_a, w_a, w_a, 1.0);\r\n\t\t}`\r\n\r\n};\r\n\r\nconst hGaussianBlur = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'kernelSize': { value: 0 },\r\n        'kernel': { value: new Array(128) },\r\n        'hRes': { value: 0.0 }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n        uniform float hRes;\r\n        uniform int kernelSize;\r\n        uniform float kernel[128];\r\n        uniform sampler2D tDiffuse;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            vec4 color = texture2D(tDiffuse, vUv) * kernel[0];\r\n\r\n            for (int i=1; i < 128; i++) {\r\n                if (i == kernelSize) break;\r\n                color += texture2D(tDiffuse, vUv + vec2(float(i)/hRes, 0.0)) * kernel[i];\r\n                color += texture2D(tDiffuse, vUv - vec2(float(i)/hRes, 0.0)) * kernel[i];\r\n            }\r\n\r\n            gl_FragColor = color;\r\n        }`\r\n};\r\n\r\nconst vGaussianBlur = { \r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'kernelSize': { value: 0 },\r\n        'kernel': { value: new Array(128) },\r\n        'vRes': { value: 0.0 }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`            \r\n        uniform float vRes;\r\n        uniform int kernelSize;\r\n        uniform float kernel[128];\r\n        uniform sampler2D tDiffuse;\r\n        \r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            vec4 color = texture2D(tDiffuse, vUv) * kernel[0];\r\n\r\n            for (int i=1; i < 128; i++) {\r\n                if (i == kernelSize) break;\r\n                color += texture2D(tDiffuse, vUv + vec2(0.0, float(i)/vRes)) * kernel[i];\r\n                color += texture2D(tDiffuse, vUv - vec2(0.0, float(i)/vRes)) * kernel[i];\r\n            }\r\n\r\n            gl_FragColor = color;\r\n        }`\r\n\r\n};\r\n\r\nconst sobelShader = {\r\n    \r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'dim': { value: new Vector2() },\r\n        'GX': { value: new Array(9) },\r\n        'GY': { value: new Array(9) }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform vec2 dim;\r\n        uniform float GX[9];\r\n        uniform float GY[9];\r\n        uniform sampler2D tDiffuse;\r\n\r\n        void main() {\r\n            \r\n            vec4 gx = vec4(0.0);\r\n            vec4 gy = vec4(0.0);\r\n            vec4 v;\r\n\r\n            for (int j=0; j<3; j++) {\r\n                for (int i=0; i<3; i++) {\r\n                    v = texture2D(tDiffuse, vec2(gl_FragCoord.x/dim.x, gl_FragCoord.y/dim.y) + vec2( float(i-1)/dim.x, float(j-1)/dim.y ) );\r\n                    gx += GX[j * 3 + i] * v;\r\n                    gy += GY[j * 3 + i] * v;\r\n                }\r\n            }\r\n\r\n            vec4 mag = sqrt(gx * gx + gy * gy);\r\n            float arg = atan(gy.x, gx.x);\r\n\r\n\r\n            gl_FragColor = vec4(mag.x, mag.y, mag.z, 1.0);\r\n        }`\r\n}\r\n\r\nconst gradientMagnitudeFragShader = `\r\n    precision highp float;\r\n\r\n    uniform vec2 dim;\r\n    uniform float GX[9];\r\n    uniform float GY[9];\r\n    uniform sampler2D tDiffuse;\r\n\r\n    void main() {\r\n        \r\n        vec4 gx = vec4(0.0);\r\n        vec4 gy = vec4(0.0);\r\n        vec4 v;\r\n\r\n        for (int j=0; j<3; j++) {\r\n            for (int i=0; i<3; i++) {\r\n                v = texture2D(tDiffuse, vec2(gl_FragCoord.x/dim.x, gl_FragCoord.y/dim.y) + vec2( float(i-1)/dim.x, float(j-1)/dim.y ) );\r\n                gx += GX[j * 3 + i] * v;\r\n                gy += GY[j * 3 + i] * v;\r\n            }\r\n        }\r\n\r\n        vec4 mag = sqrt(gx * gx + gy * gy);\r\n        gl_FragColor = vec4(mag.x, mag.y, mag.z, 1.0);\r\n    }`\r\n\r\nconst gradientArgumentFragShader = `\r\n    precision highp float;\r\n\r\n    uniform vec2 dim;\r\n    uniform float GX[9];\r\n    uniform float GY[9];\r\n    uniform sampler2D tDiffuse;\r\n\r\n    void main() {\r\n        \r\n        vec4 gx = vec4(0.0);\r\n        vec4 gy = vec4(0.0);\r\n        vec4 v;\r\n\r\n        for (int j=0; j<3; j++) {\r\n            for (int i=0; i<3; i++) {\r\n                v = texture2D(tDiffuse, vec2(gl_FragCoord.x/dim.x, gl_FragCoord.y/dim.y) + vec2( float(i-1)/dim.x, float(j-1)/dim.y ) );\r\n                gx += GX[j * 3 + i] * v;\r\n                gy += GY[j * 3 + i] * v;\r\n            }\r\n        }\r\n\r\n        vec4 mag = sqrt(gx * gx + gy * gy);\r\n        float arg = atan(gy.x, gx.x);\r\n\r\n        gl_FragColor = vec4(arg, arg, arg, arg);\r\n    }`\r\n\r\nconst normalizeShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'max': { value : 1.0 }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDiffuse;\r\n        uniform float max;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            float v = texture2D(tDiffuse, vUv).x;\r\n            float norm = v / max;\r\n\r\n            gl_FragColor = vec4(norm, norm, norm, 1.0);\r\n\r\n        }`\r\n\r\n}\r\n\r\nconst nmsFragShader = `\r\n\r\n    uniform sampler2D tMags;\r\n    uniform sampler2D tArgs;\r\n    uniform vec2 dim;\r\n\r\n    void main() {\r\n        \r\n        vec2 current = vec2(gl_FragCoord.x/dim.x, gl_FragCoord.y/dim.y);\r\n\r\n        float m = texture2D(tMags, current).x;\r\n        float a = texture2D(tArgs, current).x;\r\n\r\n        float hComp = cos(a);\r\n        float vComp = sin(a);\r\n        float xTranslate = sign(hComp);\r\n        float yTranslate = sign(vComp);\r\n\r\n        vec2 translate = vec2(xTranslate/dim.x, yTranslate/dim.y);\r\n        vec2 a1 = current + translate;\r\n        vec2 a2 = current - translate;\r\n        float ag1 = texture2D(tMags, a1).x;\r\n        float ag2 = texture2D(tMags, a2).x;\r\n\r\n        vec2 b1, b2;\r\n        float bg1, bg2;\r\n\r\n        float g1, g2;\r\n\r\n        if (abs(hComp) > abs(vComp)) {\r\n            translate = vec2(xTranslate/dim.x, 0.0);\r\n            b1 = current + vec2(translate);\r\n            b2 = current - vec2(translate);\r\n            bg1 = texture2D(tMags, b1).x;\r\n            bg2 = texture2D(tMags, b2).x;\r\n            g1 = ag1 * abs(vComp) + (1.0-abs(vComp)) * bg1;\r\n            g2 = ag2 * abs(vComp) + (1.0-abs(vComp)) * bg2;\r\n        }\r\n        else {\r\n            translate = vec2(0.0, yTranslate/dim.y);\r\n            b1 = current + vec2(translate);\r\n            b2 = current - vec2(translate);\r\n            bg1 = texture2D(tMags, b1).x;\r\n            bg2 = texture2D(tMags, b2).x;\r\n            g1 = ag1 * abs(hComp) + (1.0-abs(hComp)) * bg1;\r\n            g2 = ag2 * abs(hComp) + (1.0-abs(hComp)) * bg2;\r\n        }\r\n\r\n        if (g1 > m || g2 > m) {\r\n            m = 0.0;\r\n        }\r\n\r\n        gl_FragColor = vec4(m, m, m, 1.0);\r\n\r\n    }`\r\n\r\nconst thresholdShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'max': { value : 1.0 },\r\n        'high': { value: 0.0},\r\n        'low': { value: 0.0}\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDiffuse;\r\n        uniform float max;\r\n        uniform float high;\r\n        uniform float low;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            float v = texture2D(tDiffuse, vUv).x;\r\n\r\n            vec4 texel;\r\n            if (v <= low) {\r\n                texel = vec4(0.0, 0.0, 0.0, 1.0);\r\n            } else if (v < high) {\r\n                texel = vec4(0.3, 0.3, 0.3, 1.0);\r\n            } else {\r\n                texel = vec4(1.0);\r\n            }\r\n\r\n            gl_FragColor = texel;\r\n\r\n        }`\r\n\r\n}\r\n\r\nconst dilationShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'dims': { value : new Vector2() },\r\n        'tolerance': { value: 1.0},\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDiffuse;\r\n        uniform vec2 dims;\r\n        uniform int tolerance;\r\n\r\n        void main() {\r\n\r\n            float v = 0.0;\r\n            for (int j = -tolerance; j <= tolerance; j++) {\r\n                for (int i = -tolerance; i <= tolerance; i++) {\r\n                    \r\n                    vec2 coord = vec2(gl_FragCoord.x/dims.x, gl_FragCoord.y/dims.y) + vec2( float(i)/dims.x, float(j)/dims.y );\r\n\r\n                    if ( texture2D(tDiffuse, coord).x > 0.3) {\r\n\r\n                        v = 1.0;\r\n                        break;\r\n\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            gl_FragColor = vec4(v, v, v, 1.0);\r\n\r\n        }`\r\n\r\n}\r\n\r\nconst hysteresisCombineShader = {\r\n\r\n    uniforms: {\r\n        'tDilate': { value: null },\r\n        'tDiffuse': { value: null },\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDilate;\r\n        uniform sampler2D tDiffuse;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            float dilate = texture2D(tDilate, vUv).x;\r\n            float weak = texture2D(tDiffuse, vUv).x;\r\n\r\n            if (weak < 1.0 && weak > 0.0 && dilate > 0.3) {\r\n\r\n                weak = 1.0;\r\n\r\n            }\r\n\r\n            gl_FragColor = vec4(weak, weak, weak, 1.0);\r\n        }`\r\n\r\n}\r\n\r\nconst copyStrongShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'dims': { value: new Vector2() }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDiffuse;\r\n        uniform vec2 dims;\r\n\r\n        void main() {\r\n\r\n            vec2 coord = vec2(gl_FragCoord.x/dims.x, gl_FragCoord.y/dims.y);\r\n\r\n            float v = texture2D(tDiffuse, coord).x;\r\n            if ( v <= 0.3 ) {\r\n                v = 0.0;\r\n            }\r\n\r\n            gl_FragColor = vec4(v, v, v, 1.0);\r\n\r\n        }`\r\n\r\n}\r\n\r\nconst copyShader = {\r\n\r\n    uniforms: {\r\n        'tDiffuse': { value: null }\r\n    },\r\n\r\n    vertexShader: /* glsl */`\r\n        varying vec2 vUv;\r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n\r\n    fragmentShader: /* glsl */`\r\n\r\n        precision highp float;\r\n\r\n        uniform sampler2D tDiffuse;\r\n\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n\r\n            gl_FragColor = texture2D(tDiffuse, vUv);\r\n\r\n        }`\r\n\r\n}\r\n\r\nexport { normalizeShader, GrayscaleShader, hGaussianBlur, vGaussianBlur, sobelShader, gradientMagnitudeFragShader, gradientArgumentFragShader, nmsFragShader, thresholdShader, copyStrongShader, copyShader, dilationShader, hysteresisCombineShader };","import { ShaderMaterial, UniformsUtils } from 'three';\r\nimport { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';\r\nimport { GrayscaleShader } from './shaders';\r\n\r\nclass GrayscalePass extends Pass {\r\n\r\n    constructor ( weights ) {\r\n\r\n        super();\r\n\r\n        const shader = GrayscaleShader;\r\n\r\n        this.uniforms = UniformsUtils.clone( shader.uniforms );\r\n        \r\n        this.material = new ShaderMaterial({\r\n\r\n            uniforms: this.uniforms,\r\n            vertexShader: shader.vertexShader,\r\n            fragmentShader: shader.fragmentShader\r\n        \r\n        });\r\n\r\n        if (weights !== undefined) this.uniforms.weights.value = weights;\r\n\r\n        this.fsQuad = new FullScreenQuad(this.material);\r\n\r\n    }\r\n\r\n    render( renderer, writeBuffer, readBuffer) {\r\n\r\n        this.uniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n        if ( this.renderToScreen ) { \r\n            \r\n            renderer.setRenderTarget(null);\r\n            this.fsQuad.render(renderer);\r\n\r\n        } else {\r\n\r\n            renderer.setRenderTarget(writeBuffer);\r\n            if (this.clear) renderer.clear();\r\n            this.fsQuad.render(renderer);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nexport default GrayscalePass;","import { ShaderMaterial, UniformsUtils } from 'three';\r\nimport { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';\r\nimport { hGaussianBlur } from './shaders';\r\n\r\nclass HorizontalBlurPass extends Pass {\r\n\r\n    constructor ( kernel, kernelSize, width ) {\r\n\r\n        super();\r\n\r\n        const shader = hGaussianBlur;\r\n\r\n        this.uniforms = UniformsUtils.clone( shader.uniforms );\r\n        \r\n        this.material = new ShaderMaterial({\r\n\r\n            uniforms: this.uniforms,\r\n            vertexShader: shader.vertexShader,\r\n            fragmentShader: shader.fragmentShader\r\n        \r\n        });\r\n\r\n        if (kernel !== undefined) this.uniforms.kernel.value = kernel;\r\n        if (kernelSize !== undefined) this.uniforms.kernelSize.value = kernelSize;\r\n        if (width !== undefined) this.uniforms.hRes.value = width;\r\n\r\n        this.fsQuad = new FullScreenQuad(this.material);\r\n\r\n    }\r\n\r\n    render( renderer, writeBuffer, readBuffer) {\r\n\r\n        this.uniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n        if ( this.renderToScreen ) { \r\n            \r\n            renderer.setRenderTarget(null);\r\n            this.fsQuad.render(renderer);\r\n\r\n        } else {\r\n\r\n            renderer.setRenderTarget(writeBuffer);\r\n            if (this.clear) renderer.clear();\r\n            this.fsQuad.render(renderer);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nexport default HorizontalBlurPass;","import { ShaderMaterial, UniformsUtils } from 'three';\r\nimport { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';\r\nimport { vGaussianBlur } from './shaders';\r\n\r\nclass HorizontalBlurPass extends Pass {\r\n\r\n    constructor ( kernel, kernelSize, height ) {\r\n\r\n        super();\r\n\r\n        const shader = vGaussianBlur;\r\n\r\n        this.uniforms = UniformsUtils.clone( shader.uniforms );\r\n        \r\n        this.material = new ShaderMaterial({\r\n\r\n            uniforms: this.uniforms,\r\n            vertexShader: shader.vertexShader,\r\n            fragmentShader: shader.fragmentShader\r\n        \r\n        });\r\n\r\n        if (kernel !== undefined) this.uniforms.kernel.value = kernel;\r\n        if (kernelSize !== undefined) this.uniforms.kernelSize.value = kernelSize;\r\n        if (height !== undefined) this.uniforms.vRes.value = height;\r\n\r\n        this.fsQuad = new FullScreenQuad(this.material);\r\n\r\n    }\r\n\r\n    render( renderer, writeBuffer, readBuffer) {\r\n\r\n        this.uniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n        if ( this.renderToScreen ) { \r\n            \r\n            renderer.setRenderTarget(null);\r\n            this.fsQuad.render(renderer);\r\n\r\n        } else {\r\n\r\n            renderer.setRenderTarget(writeBuffer);\r\n            if (this.clear) renderer.clear();\r\n            this.fsQuad.render(renderer);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nexport default HorizontalBlurPass;","import { ShaderMaterial, UniformsUtils } from 'three';\r\nimport { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';\r\nimport { sobelShader } from './shaders';\r\n\r\nclass SobelPass extends Pass {\r\n\r\n    constructor ( gx, gy, dim ) {\r\n\r\n        super();\r\n\r\n        const shader = sobelShader;\r\n\r\n        this.uniforms = UniformsUtils.clone( shader.uniforms );\r\n        \r\n        this.material = new ShaderMaterial({\r\n\r\n            uniforms: this.uniforms,\r\n            vertexShader: shader.vertexShader,\r\n            fragmentShader: shader.fragmentShader\r\n        \r\n        });\r\n\r\n        if (gx !== undefined) this.uniforms.GX.value = gx;\r\n        if (gy !== undefined) this.uniforms.GY.value = gy;\r\n        if (dim !== undefined) this.uniforms.dim.value = dim;\r\n\r\n        this.fsQuad = new FullScreenQuad(this.material);\r\n\r\n    }\r\n\r\n    render( renderer, writeBuffer, readBuffer) {\r\n\r\n        this.uniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n        if ( this.renderToScreen ) { \r\n            \r\n            renderer.setRenderTarget(null);\r\n            this.fsQuad.render(renderer);\r\n\r\n        } else {\r\n\r\n            renderer.setRenderTarget(writeBuffer);\r\n            if (this.clear) renderer.clear();\r\n            this.fsQuad.render(renderer);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nexport default SobelPass;","import { ShaderMaterial, UniformsUtils } from 'three';\r\nimport { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';\r\nimport { normalizeShader, thresholdShader } from './shaders';\r\n\r\n// Combines passes for Sobel operator onwards due to dependency on calculated information\r\nclass GpuComputePass extends Pass {\r\n\r\n    constructor ( sobelParams, nmsParams, dim, doNMS, threshold ) {\r\n\r\n        super();\r\n\r\n        this.doNMS = doNMS;\r\n        this.threshold = threshold;\r\n\r\n        this.dims = dim;\r\n\r\n        this.gpuCompute = sobelParams.gpuCompute;\r\n        this.magnitudeVariable = sobelParams.magnitudeVariable;\r\n        this.magnitudeUniforms = sobelParams.magnitudeUniforms;\r\n        this.argumentVariable = sobelParams.argumentVariable;\r\n        this.argumentUniforms = sobelParams.argumentUniforms;\r\n\r\n        if (doNMS) {\r\n            this.nmsGpuCompute = nmsParams.nmsGpuCompute;\r\n            this.nmsVariable = nmsParams.nmsVariable;\r\n            this.nmsUniforms = nmsParams.nmsUniforms;\r\n        }\r\n\r\n        // Normalize values to range 0 -> 1.\r\n        this.initNormalizeShader();\r\n\r\n        if (threshold) this.initThresholdShader();\r\n    }\r\n\r\n    render( renderer, writeBuffer, readBuffer) {\r\n\r\n        // Compute gradient magnitudes and angles\r\n        this.magnitudeUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n        if ( this.doNMS ) this.argumentUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n        this.gpuCompute.compute();\r\n\r\n        // Pass in shader uniforms depending on the process shader.\r\n        let renderTarget;\r\n        if ( this.doNMS ) {\r\n\r\n            this.nmsUniforms[ 'tMags' ].value = this.gpuCompute.getCurrentRenderTarget( this.magnitudeVariable ).texture;\r\n            this.nmsUniforms[ 'tArgs' ].value = this.gpuCompute.getCurrentRenderTarget( this.argumentVariable ).texture;\r\n            this.nmsUniforms[ 'dim' ].value = this.dims;\r\n\r\n            this.nmsGpuCompute.compute();\r\n\r\n            renderTarget = this.nmsGpuCompute.getCurrentRenderTarget( this.nmsVariable )\r\n\r\n        } else {\r\n\r\n            renderTarget = this.gpuCompute.getCurrentRenderTarget( this.magnitudeVariable )\r\n\r\n        }\r\n        \r\n        // Calculate the max value uniform for the normalize shader.\r\n\r\n        let read = new Float32Array( 4 * this.dims[0] * this.dims[1]);\r\n        renderer.readRenderTargetPixels(renderTarget, 0, 0, this.dims[0], this.dims[1], read);\r\n\r\n        // O(N) CPU bound search for max\r\n\r\n        let max = 0.0;\r\n        for (let i = 0; i < read.length; i+=4) {\r\n            if (read[i] > max) max = read[i];\r\n        }\r\n\r\n        if (max > 0.0) this.normUniforms[ 'max' ].value = max;\r\n        this.normUniforms[ 'tDiffuse' ].value = renderTarget.texture;\r\n\r\n        // Render norm pass in the effects chain.\r\n\r\n        if ( this.renderToScreen && !this.threshold ) {\r\n\r\n            renderer.setRenderTarget(null);\r\n            this.normFsQuad.render(renderer);\r\n\r\n        } else {\r\n\r\n            renderer.setRenderTarget(readBuffer);\r\n            if (this.clear) renderer.clear();\r\n            this.normFsQuad.render(renderer);\r\n\r\n        }\r\n\r\n        // Render threshold pass in the effects chain.\r\n\r\n        if ( this.threshold ) {\r\n            \r\n            let hi = this.threshold.high * max;\r\n\r\n            this.threshUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n            this.threshUniforms[ 'max' ].value = max;\r\n            this.threshUniforms[ 'high' ].value = hi;\r\n            this.threshUniforms[ 'low' ].value = this.threshold.low * hi;\r\n\r\n            if (this.renderToScreen) {\r\n\r\n                renderer.setRenderTarget(null);\r\n                this.threshFsQuad.render(renderer)\r\n\r\n            } else {\r\n\r\n                renderer.setRenderTarget(writeBuffer);\r\n                if (this.clear) renderer.clear();\r\n                this.threshFsQuad.render(renderer);\r\n\r\n            }\r\n\r\n        }\r\n    }\r\n    \r\n    initNormalizeShader() {\r\n\r\n        const normShader = normalizeShader;\r\n\r\n        this.normUniforms = UniformsUtils.clone( normShader.uniforms );\r\n\r\n        this.normMaterial = new ShaderMaterial({\r\n\r\n            uniforms: this.normUniforms,\r\n            vertexShader: normShader.vertexShader,\r\n            fragmentShader: normShader.fragmentShader\r\n\r\n        })\r\n\r\n        this.normFsQuad = new FullScreenQuad(this.normMaterial);\r\n    \r\n    }\r\n\r\n    initThresholdShader() {\r\n\r\n        const threshShader = thresholdShader;\r\n\r\n        this.threshUniforms = UniformsUtils.clone( thresholdShader.uniforms );\r\n\r\n        this.threshMaterial = new ShaderMaterial({\r\n\r\n            uniforms: this.threshUniforms,\r\n            vertexShader: threshShader.vertexShader,\r\n            fragmentShader: threshShader.fragmentShader\r\n\r\n        })\r\n\r\n        this.threshFsQuad = new FullScreenQuad(this.threshMaterial);\r\n\r\n    }\r\n}\r\n\r\nexport default GpuComputePass;","import { ShaderMaterial, UniformsUtils, WebGLRenderTarget } from 'three';\r\nimport { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';\r\nimport { copyShader, copyStrongShader, dilationShader, hysteresisCombineShader } from './shaders';\r\n\r\nclass HysteresisPass extends Pass {\r\n\r\n    constructor ( tolerance, iterations, renderTarget, dims ) {\r\n\r\n        super();\r\n\r\n        this.iterations = iterations;\r\n\r\n        if (iterations == 0) this.initCopyShader();\r\n        this.initDilationShader(dims, tolerance);\r\n        this.initHysteresisShader();\r\n\r\n    }\r\n\r\n    render( renderer, writeBuffer, readBuffer) {\r\n\r\n        this.intermediateRt = writeBuffer.clone();\r\n\r\n        if (this.iterations == 0) {\r\n            \r\n            this.copyUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n            renderer.setRenderTarget(null);\r\n            this.copyFsQuad.render(renderer);\r\n\r\n        } else {\r\n\r\n            this.hysUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n            for (let i = 0; i < this.iterations; i++) {\r\n\r\n                this.uniforms[ 'tDiffuse' ].value = i == 0 ? readBuffer.texture : writeBuffer.texture;\r\n    \r\n                renderer.setRenderTarget(this.intermediateRt);\r\n                if (this.clear) renderer.clear();\r\n                this.fsQuad.render(renderer);\r\n\r\n                this.hysUniforms[ 'tDilate' ].value = this.intermediateRt.texture;\r\n\r\n                if ( i == this.iterations - 1  && this.renderToScreen) {\r\n    \r\n                    renderer.setRenderTarget(null);\r\n                    this.hysFsQuad.render(renderer);\r\n    \r\n                } else {\r\n    \r\n                    renderer.setRenderTarget(writeBuffer);\r\n                    if (this.clear) renderer.clear();\r\n                    this.hysFsQuad.render(renderer);\r\n    \r\n                }\r\n            }\r\n        }\r\n\r\n        this.intermediateRt.dispose();\r\n        delete this.intermediateRt;\r\n    }\r\n\r\n    initCopyShader() {\r\n\r\n        const cpyShader = copyShader;\r\n\r\n        this.copyUniforms = UniformsUtils.clone( cpyShader.uniforms );\r\n\r\n        this.copyMaterial = new ShaderMaterial({\r\n\r\n            uniforms: this.copyUniforms,\r\n            vertexShader: cpyShader.vertexShader,\r\n            fragmentShader: cpyShader.fragmentShader\r\n\r\n        })\r\n\r\n        this.copyFsQuad = new FullScreenQuad(this.copyMaterial);\r\n\r\n    }\r\n\r\n    initDilationShader(dims, tolerance) {\r\n\r\n        const shader = dilationShader;\r\n\r\n        this.uniforms = UniformsUtils.clone( shader.uniforms );\r\n        \r\n        this.material = new ShaderMaterial({\r\n\r\n            uniforms: this.uniforms,\r\n            vertexShader: shader.vertexShader,\r\n            fragmentShader: shader.fragmentShader\r\n        \r\n        });\r\n\r\n        if (dims !== undefined) this.uniforms.dims.value = dims;\r\n        if (tolerance !== undefined) this.uniforms.tolerance.value = tolerance;\r\n\r\n        this.fsQuad = new FullScreenQuad(this.material);\r\n    }\r\n\r\n    initHysteresisShader() {\r\n        const hysShader = hysteresisCombineShader;\r\n\r\n        this.hysUniforms = UniformsUtils.clone( hysShader.uniforms );\r\n\r\n        this.hysMaterial = new ShaderMaterial({\r\n\r\n            uniforms: this.hysUniforms,\r\n            vertexShader: hysShader.vertexShader,\r\n            fragmentShader: hysShader.fragmentShader\r\n            \r\n        })\r\n\r\n        this.hysFsQuad = new FullScreenQuad(this.hysMaterial);\r\n    }\r\n\r\n}\r\n\r\nexport default HysteresisPass;","import { ShaderMaterial, UniformsUtils } from 'three';\r\nimport { Pass, FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';\r\nimport { copyStrongShader } from './shaders';\r\n\r\n// Copy only pixels above a threshold.\r\n// Value is currently hard-coded into the shader, could add as a uniform and pass in as an arg here.\r\nclass CopyStrongPass extends Pass {\r\n\r\n    constructor ( dims ) {\r\n\r\n        super();\r\n\r\n        this.initCopyShader();\r\n\r\n        if (dims !== null) this.copyUniforms.dims.value = dims;\r\n\r\n    }\r\n\r\n    render( renderer, writeBuffer, readBuffer ) {\r\n\r\n        this.copyUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\r\n        if ( this.renderToScreen ) { \r\n            \r\n            renderer.setRenderTarget(null);\r\n            this.copyFsQuad.render(renderer);\r\n\r\n        } else {\r\n\r\n            renderer.setRenderTarget(writeBuffer);\r\n            if (this.clear) renderer.clear();\r\n            this.copyFsQuad.render(renderer);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    initCopyShader() {\r\n\r\n        const cpyShader = copyStrongShader;\r\n\r\n        this.copyUniforms = UniformsUtils.clone( cpyShader.uniforms );\r\n\r\n        this.copyMaterial = new ShaderMaterial({\r\n\r\n            uniforms: this.copyUniforms,\r\n            vertexShader: cpyShader.vertexShader,\r\n            fragmentShader: cpyShader.fragmentShader\r\n\r\n        })\r\n\r\n        this.copyFsQuad = new FullScreenQuad(this.copyMaterial);\r\n\r\n    }\r\n}\r\n\r\nexport default CopyStrongPass;","import { GPUComputationRenderer } from 'three/examples/jsm//misc/GPUComputationRenderer';\r\nimport { gradientMagnitudeFragShader, gradientArgumentFragShader, nmsFragShader} from \"./shaders\";\r\n\r\n// Helper func to init empty computation matrix as a texture.\r\nconst fillTextureWithZeros = (texture) => {\r\n    let arr = texture.image.data;\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        arr[i] = 0;\r\n    }\r\n}\r\n\r\nconst getSobelComputeRenderer = (gl, dims, kernel, doNMS) => {\r\n\r\n    let gpuCompute = new GPUComputationRenderer(dims[0], dims[1], gl);\r\n\r\n    let gradMagnitude = gpuCompute.createTexture();\r\n    fillTextureWithZeros( gradMagnitude );\r\n    let magnitudeVariable = gpuCompute.addVariable( 'textureMagnitude', gradientMagnitudeFragShader, gradMagnitude);\r\n\r\n    // Only compute arguments if we are doing NMS - otherwise only Mags are needed.\r\n    let argumentVariable;\r\n    let gradArgument;\r\n    if ( doNMS ) {\r\n\r\n        gradArgument = gpuCompute.createTexture();\r\n        fillTextureWithZeros( gradArgument );\r\n        argumentVariable = gpuCompute.addVariable( 'textureArgument', gradientArgumentFragShader, gradArgument);\r\n\r\n        gpuCompute.setVariableDependencies( magnitudeVariable, [ argumentVariable, magnitudeVariable ] );\r\n        gpuCompute.setVariableDependencies( argumentVariable, [ argumentVariable, magnitudeVariable ] );\r\n\r\n\r\n    } else {\r\n        \r\n        gpuCompute.setVariableDependencies( magnitudeVariable, [ magnitudeVariable ] );\r\n\r\n    }\r\n\r\n    let magnitudeUniforms = magnitudeVariable.material.uniforms;\r\n\r\n    magnitudeUniforms[ 'GX' ] = { value: kernel.gx }\r\n    magnitudeUniforms[ 'GY' ] = { value: kernel.gy }\r\n    magnitudeUniforms[ 'dim' ] = { value: dims }\r\n    magnitudeUniforms[ 'tDiffuse' ] = { value: null }\r\n\r\n\r\n    let argumentUniforms;\r\n    if ( doNMS ) {\r\n\r\n        argumentUniforms = argumentVariable.material.uniforms;\r\n\r\n        argumentUniforms[ 'GX' ] = { value: kernel.gx }\r\n        argumentUniforms[ 'GY' ] = { value: kernel.gy }\r\n        argumentUniforms[ 'dim' ] = { value: dims }\r\n        argumentUniforms[ 'tDiffuse' ] = { value: null }\r\n\r\n    }\r\n\r\n    const error = gpuCompute.init();\r\n\r\n    if (error !== null) {\r\n        console.error(error);\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        gpuCompute: gpuCompute,\r\n        magnitudeVariable: magnitudeVariable,\r\n        magnitudeUniforms, magnitudeUniforms,\r\n        argumentVariable: argumentVariable,\r\n        argumentUniforms: argumentUniforms,\r\n        texture: gradArgument,\r\n        texture_2: gradMagnitude\r\n    }\r\n}\r\n\r\nconst getNMSComputeRenderer = (gl, dims, doNMS) => {\r\n\r\n    // Don't necessarily want to init NMS renderer as sobel comes before NMS in canny steps. (Saves computation time).\r\n    if (!doNMS) return null;\r\n\r\n    let nmsGpuCompute = new GPUComputationRenderer(dims[0], dims[1], gl);\r\n\r\n    let nms = nmsGpuCompute.createTexture();\r\n    fillTextureWithZeros( nms );\r\n    let nmsVariable = nmsGpuCompute.addVariable( 'textureNms', nmsFragShader, nms );\r\n    \r\n    nmsGpuCompute.setVariableDependencies( nmsVariable, [nmsVariable] );\r\n\r\n    let nmsUniforms = nmsVariable.material.uniforms;\r\n    \r\n    nmsUniforms[ 'dim' ] = { value: dims }\r\n    nmsUniforms[ 'tMags' ] = { value: null }\r\n    nmsUniforms[ 'tArgs' ] = { value: null }\r\n\r\n    const error = nmsGpuCompute.init();\r\n\r\n    if (error !== null) { \r\n        console.error(error);\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        nmsGpuCompute: nmsGpuCompute,\r\n        nmsVariable: nmsVariable,\r\n        nmsUniforms: nmsUniforms,\r\n        textures: [nms]\r\n    }\r\n}\r\n\r\nconst getComputationRenderers = (gl, dims, kernel, doNMS) => {\r\n\r\n    let obj = {sobel: getSobelComputeRenderer(gl, dims, kernel, doNMS), nms: getNMSComputeRenderer(gl, dims, doNMS)};\r\n\r\n    return obj;\r\n}\r\n\r\n\r\nexport default getComputationRenderers;","// Truncate the kernel as it is symmetrical - half of this data is irrelevant.\r\nconst getSeparableKernel = (r, sigma) => {\r\n\r\n    // console.log(\"generated kernel\")\r\n\r\n    let sum = 0;\r\n    let arr = [];\r\n    let coefficient = 1/(Math.sqrt(2 * Math.PI) * sigma);\r\n    let exponent;\r\n    for (let i=0; i <= r; i++) {\r\n        exponent = Math.exp(-Math.pow(i, 2)/(2 * Math.pow(sigma, 2)))\r\n        arr[i] = coefficient * exponent;\r\n\r\n        // Kernel sum used in normalisation - account for the fact we only generate one half of the kernel:\r\n        sum += i === 0 ? arr[i] : 2 * arr[i];\r\n    }\r\n\r\n    // Normalise\r\n    for (let i = 0; i <= r; i++) {\r\n        arr[i] /= sum;\r\n    }\r\n\r\n    return arr;\r\n}\r\n\r\nexport {getSeparableKernel}","import { Canvas, extend, useFrame, useThree } from 'react-three-fiber';\r\nimport React, { useState, useRef, Suspense, useEffect } from 'react';\r\nimport FadeIn from 'react-fade-in';\r\nimport { Image, Slider, InputNumber, Button, Row, Col, Select, Spin } from 'antd';\r\nimport { ArrowLeftOutlined, LoadingOutlined } from '@ant-design/icons';\r\nimport ImageUploader from \"./imageUploader\";\r\nimport \"./main.scss\";\r\n\r\n// Shader-related imports\r\nimport ThreeImagePlane from \"./threeImagePlane\";\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';\r\nimport { GrayscalePass, HorizontalBlurPass, VerticalBlurPass, SobelPass, GpuComputePass, HysteresisPass, CopyStrongPass } from './shaders';\r\nimport getComputationRenderers from \"./shaders/getComputationRenderers\";\r\nimport { WebGLRenderTarget } from 'three';\r\n\r\nimport { getSeparableKernel } from \"./gaussianKernel\";\r\n\r\n// Make sure to extend shader components so they work with three-fiber\r\nextend({ EffectComposer, RenderPass, GrayscalePass, HorizontalBlurPass, VerticalBlurPass, SobelPass, GpuComputePass, HysteresisPass, CopyStrongPass });\r\n\r\nconst { Option } = Select;\r\n\r\n// Constants used for parameter selection:\r\n\r\n// Grayscale r, g, b channel weightings.\r\nconst grayScaleCoefficients = {\r\n    \"BT.601\" : [0.299, 0.587, 0.114],\r\n    \"BT.709\" : [0.2126, 0.7152, 0.0722],\r\n    \"BT.2100\" : [0.2627, 0.6780, 0.0593],\r\n    \"Mean\" : [0.3333, 0.3333, 0.3333]\r\n}\r\n\r\n// Edge detection kernels.\r\nconst edgefindingOperators = {\r\n\r\n    \"sobel\" : {\r\n        gx: [\r\n            1, 0, -1,\r\n            2, 0, -2,\r\n            1, 0, -1\r\n        ],\r\n\r\n        gy: [\r\n            1, 2, 1,\r\n            0, 0, 0,\r\n            -1,-2,-1\r\n        ]\r\n    },\r\n\r\n    \"prewitt\" : {\r\n        gx: [\r\n            1, 0, -1,\r\n            1, 0, -1,\r\n            1, 0, -1\r\n        ],\r\n\r\n        gy: [\r\n            1, 1, 1,\r\n            0, 0, 0,\r\n            -1,-1,-1\r\n        ]\r\n    }\r\n\r\n}\r\n\r\n\r\nconst Steps = () => {\r\n\r\n    // Store the step in the canny process that is currently shown.\r\n    const maxStep = 7;\r\n    const [step, setStep] = useState(0);\r\n\r\n    // Set a ref to the container of the processed image so it can be centered.\r\n    const ImgContainerRef = useRef();\r\n    const [shaderDisplayDim, setDisplayDim] = useState({width: 0, height: 0});\r\n\r\n    // Data about the uploaded image (dimensions and pixel content).\r\n    const [imgDims, setImgDims] = useState(null);\r\n    const [imgSource, setImgSourceVar] = useState(null);\r\n\r\n    // Whether or not to display the image uploader.\r\n    const [uploadVisibility, setUploadVisibility] = useState(true);\r\n\r\n    const [intermediateRT, setIntermediateRT] = useState(null);\r\n\r\n    // Canny algorithm parameters.\r\n    const [selectedGrayscaleTag, setSelectedGrayscaleTag] = useState(\"BT.601\")\r\n    const [selectedGrayscaleEncoding, setSelectedGrayscaleEncoding] = useState(grayScaleCoefficients[selectedGrayscaleTag]);\r\n\r\n    const [gaussRadius, setGaussRadius] = useState(3);\r\n    const [gaussSigma, setGaussSigma] = useState(1);\r\n\r\n    const [selectedEdgeTag, setSelectedEdgeTag] = useState(\"sobel\")\r\n    const [selectedEdgeOperator, setSelectedEdgeOperator] = useState(edgefindingOperators[selectedEdgeTag])\r\n\r\n    const [lowThreshold, setLowThreshold] = useState(0.3);\r\n    const [highThreshold, setHighThreshold] = useState(0.3);\r\n\r\n    const [hysteresisTolerance, setTolerance] = useState(1);\r\n    const [hysteresisIters, setHysteresisIters] = useState(1);\r\n\r\n    // Memoization\r\n\r\n    // Setting up make-shift compute shaders is quite time costly hence the memoization\r\n    const [memoRenderers, setMemoRenderers] = useState(null);\r\n    const [memoRendererParams, setMemoRendererParams] = useState(null);\r\n\r\n    // Calculating gaussian kernel is quite fast but for larger kernels this will improve the framerate.\r\n    const [memoGaussParams, setMemoGaussParams] = useState(null);\r\n    const [memoGauss, setMemoGauss] = useState(null);\r\n\r\n    // WebGL reference for saving image (cannot be done through Canvas obj itself).\r\n    const [rendererRef, setRendererRef] = useState(null);\r\n    const [savingState, setSavingState] = useState(false);\r\n\r\n    const _getDisplay = ({reverse = false, value = \"block\"} = {}) => {\r\n        if (reverse) return uploadVisibility ? \"none\" : value;\r\n        return uploadVisibility ? value : \"none\";\r\n    }\r\n\r\n    const setImgSource = (v) => {\r\n        // Revoke previous img URL if exists to prevent memory leaks.\r\n        if (imgSource) URL.revokeObjectURL(imgSource);\r\n        setImgSourceVar(v);\r\n    }\r\n\r\n    const onImageUpload = data => {\r\n        setImgSource(data.src);\r\n        setImgDims(data.dim);\r\n        setUploadVisibility(false);\r\n    }\r\n\r\n    // Return to upload screen.\r\n    const goBack = () => {\r\n        setImgSource(null);\r\n        setImgDims(null);\r\n        setUploadVisibility(true);\r\n    }\r\n\r\n    // Ensure step counter increments and decrements in range 0 -> {maxSteps}\r\n    const hasNextStep = (step) => {\r\n        return 0 <= step && step < maxStep;\r\n    }\r\n\r\n    const stepTitles = {\r\n        0: \"Grayscale Encoding\",\r\n        1: \"Gaussian Blur\",\r\n        2: \"Edgefinding Operation\",\r\n        3: \"Non-maximum suppression\",\r\n        4: \"Double Threshold\",\r\n        5: \"Edge-Tracking (Hysteresis)\",\r\n        6: \"Final Image\"\r\n    }\r\n\r\n    // Map for option UI (React components) per step No.\r\n    const stepOptions = {\r\n        \r\n        0: (\r\n            <>\r\n                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                    <Col flex=\"120px\">Encoding Type</Col>\r\n                    <Col flex=\"auto\">\r\n                        <Select defaultValue={selectedGrayscaleTag} onChange={v => {setSelectedGrayscaleTag(v); setSelectedGrayscaleEncoding(grayScaleCoefficients[v])}}>\r\n                            <Option value=\"BT.601\">BT.601</Option>\r\n                            <Option value=\"BT.709\">BT.709</Option>\r\n                            <Option value=\"BT.2100\">BT.2100</Option>\r\n                            <Option value=\"Mean\">Mean</Option>\r\n                        </Select>\r\n                    </Col>\r\n                </Row>\r\n            </>\r\n        ),\r\n\r\n        1: (\r\n            <>\r\n                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                    <Col flex=\"60px\">Radius</Col>\r\n                    <Col flex=\"auto\"><Slider value={gaussRadius} onChange={v => setGaussRadius(v)} min={0} max={20}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={gaussRadius} onChange={v => setGaussRadius(v) } min={0} max={20}/></Col>\r\n                </Row>\r\n                \r\n                <Row style={{display: \"flex\", alignItems: \"center\"}}>\r\n                    <Col flex=\"60px\">Sigma ()</Col>\r\n                    <Col flex=\"auto\"><Slider defaultValue={gaussSigma} onChange={v => setGaussSigma(v)} min={0.01} max={15} step={0.01}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={gaussSigma} onChange={v => setGaussSigma(v) } min={0} max={20} step={0.01}/></Col>\r\n                </Row>\r\n            </>\r\n        ),\r\n\r\n        2: (\r\n            <>\r\n                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                    <Col flex=\"70px\">Operator</Col>\r\n                    <Col flex=\"auto\">\r\n                        <Select defaultValue={selectedEdgeTag} onChange={v => {setSelectedEdgeTag(v); setSelectedEdgeOperator(edgefindingOperators[v])}}>\r\n                            <Option value=\"sobel\">Sobel</Option>\r\n                            <Option value=\"prewitt\">Prewitt</Option>\r\n                        </Select>\r\n                    </Col>\r\n                </Row>\r\n            </>\r\n        ),\r\n\r\n        3: (<p><i>(No options available)</i></p>),\r\n\r\n        4: (\r\n            <>\r\n                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                    <Col flex=\"60px\">High</Col>\r\n                    <Col flex=\"auto\"><Slider value={highThreshold} onChange={v => setHighThreshold(v)} min={0} max={1} step={0.01}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={highThreshold} onChange={v => setHighThreshold(v) } min={0} max={1} step={0.01}/></Col>\r\n                </Row>\r\n                \r\n                <Row style={{display: \"flex\", alignItems: \"center\"}}>\r\n                    <Col flex=\"60px\">Low</Col>\r\n                    <Col flex=\"auto\"><Slider value={lowThreshold} onChange={v => setLowThreshold(v)} min={0} max={1} step={0.01}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={lowThreshold} onChange={v => setLowThreshold(v) } min={0} max={1} step={0.01}/></Col>\r\n\r\n                </Row>\r\n            </>\r\n        ),\r\n\r\n        5: (\r\n            <>\r\n                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                    <Col flex=\"100px\">Tolerance (px)</Col>\r\n                    <Col flex=\"auto\"><Slider value={hysteresisTolerance} onChange={v => setTolerance(v)} min={0} max={5}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={hysteresisTolerance} onChange={v => setTolerance(v) } min={0} max={5}/></Col>\r\n                </Row>\r\n\r\n                <Row style={{display: \"flex\", alignItems: \"center\"}}>\r\n                    <Col flex=\"100px\">Iterations</Col>\r\n                    <Col flex=\"auto\"><Slider value={hysteresisIters} onChange={v => setHysteresisIters(v)} min={0} max={500}/></Col>\r\n                    <Col flex=\"100px\" align=\"right\"><InputNumber value={hysteresisIters} onChange={v => setHysteresisIters(v) } min={0} max={500}/></Col>\r\n                </Row>\r\n            </>\r\n        )\r\n    }\r\n\r\n    const downloadCanvas = async () => {\r\n        if (rendererRef) {\r\n\r\n            // Set a flag to indicate saving has begun.\r\n            setSavingState(true);\r\n\r\n            // Put img conversion in promise to make asynchronous.\r\n            new Promise(resolve => {\r\n\r\n                setTimeout(() => {\r\n\r\n                    let img = rendererRef.domElement.toDataURL();\r\n                    resolve(img);\r\n                    \r\n                }, 30);\r\n\r\n            }).then(img => {\r\n\r\n                // Automatically download image from created data URL.\r\n                let link = document.createElement(\"a\");\r\n                link.download = \"Canny_Step_\" + step;\r\n                link.href = img;\r\n                link.click();\r\n                // Set flag to indicate saving has finished.\r\n                setSavingState(false);\r\n            })\r\n\r\n        }\r\n    }\r\n\r\n    const disposeRenderers = currentRenderers => {\r\n\r\n        // Go through each attribute of the renderers and dispose of them manually if applicable. Three fiber does not automatically dispose these renderers.\r\n        if (currentRenderers) {\r\n            // Separation of sobel and nms renderers here as same obj structure is used for both i.e {sobel: ..., nms: none} for a sobel computation renderer.\r\n            if (currentRenderers.sobel) {\r\n                for (const [k, v] of Object.entries(currentRenderers.sobel)) {\r\n                    if (v) {\r\n                        if (v.dispose) v.dispose();\r\n                        delete currentRenderers.sobel[k];\r\n                    };\r\n                }\r\n                currentRenderers.sobel = null;\r\n            }\r\n\r\n            if (currentRenderers.nms) {\r\n                for (const [k, v] of Object.entries(currentRenderers.nms)) {\r\n                    if (v) {\r\n                        if (v.dispose) v.dispose();\r\n                        delete currentRenderers.nms[k];\r\n                    };\r\n                }\r\n                currentRenderers.nms = null;\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    const GetStepShaders = (step, gl) => {\r\n\r\n        // Do manual memoization here of kernel and renderers as useMemo() does not have expected performance\r\n        // (Unsure why as of now, though this works fine. Just a little more verbose).\r\n\r\n        let currentKernel = memoGauss;\r\n        let gaussParams = {r: gaussRadius, s: gaussSigma}\r\n        if (memoGaussParams == null) {\r\n            setMemoGaussParams(gaussParams);\r\n\r\n            currentKernel = getSeparableKernel(gaussParams.r, gaussParams.s);\r\n            setMemoGauss(currentKernel);\r\n        }\r\n\r\n        else if (gaussParams.r != memoGaussParams.r || gaussParams.s != memoGaussParams.s) {\r\n\r\n            setMemoGaussParams(gaussParams);\r\n\r\n            currentKernel = getSeparableKernel(gaussParams.r, gaussParams.s);\r\n            setMemoGauss(currentKernel);\r\n\r\n        }\r\n\r\n        // Use most recent kernel from after memoization.\r\n        const kernel = currentKernel;\r\n        const kernelSize = kernel.length;\r\n\r\n        // Memo renderers & their parameters in the same fashion as the kernel.\r\n        let currentRenderers = memoRenderers;\r\n        let renderParams = {gl: gl, dims: [ImgContainerRef.current.offsetWidth, ImgContainerRef.current.offsetHeight], kernel: selectedEdgeOperator, doNMS: (step > 2)}\r\n\r\n        if (memoRendererParams == null) {\r\n            setMemoRendererParams(renderParams);\r\n\r\n            currentRenderers = getComputationRenderers(renderParams.gl, renderParams.dims, renderParams.kernel, renderParams.doNMS);\r\n            setMemoRenderers(currentRenderers)\r\n            \r\n        }\r\n\r\n        // An intermediate Render Target is needed to transfer information from one computation renderer to the next; this is essentially a replacement for the render buffer.\r\n        if (intermediateRT == null) {\r\n            setIntermediateRT({tg: new WebGLRenderTarget(renderParams.dims.x, renderParams.dims.y)});\r\n        }\r\n        \r\n        // TODO: This is verbose, ensure obj comparison i.e. (renderParams != memoRendererParams) has expected behaviour to reduce this if statement.\r\n        else if (renderParams.gl != memoRendererParams.gl \r\n            || renderParams.dims[0] != memoRendererParams.dims[0]\r\n            || renderParams.dims[1] != memoRendererParams.dims[1]\r\n            || renderParams.kernel != memoRendererParams.kernel\r\n            || renderParams.doNMS != memoRendererParams.doNMS) {\r\n\r\n                // Update the current memoized parameters.\r\n                setMemoRendererParams(renderParams);\r\n\r\n                // Before updating the renderers ref, dispose of ALL objects from the custom renderer to avoid HUGE memory leaks (three-fiber doesn't auto-dispose these).\r\n                disposeRenderers(currentRenderers);\r\n\r\n                // Create new renderers (costly, hence memoization).\r\n                currentRenderers = getComputationRenderers(renderParams.gl, renderParams.dims, renderParams.kernel, renderParams.doNMS);\r\n                setMemoRenderers(currentRenderers)\r\n                \r\n                // If the image dimensions have changed (due to screen resize, etc.), the shape of the make-shift render buffer (render target) must be changed accordingly.\r\n                if (renderParams.dims[0] != memoRendererParams.dims[0] || renderParams.dims[1] != memoRendererParams.dims[1]) {\r\n                    \r\n                    // Manual dispose of previous render target.\r\n                    if (intermediateRT.tg) {\r\n                        if (intermediateRT.tg.dispose) intermediateRT.tg.dispose();\r\n                        delete intermediateRT.tg;\r\n                    }\r\n                    \r\n                    setIntermediateRT({tg: new WebGLRenderTarget(renderParams.dims.x, renderParams.dims.y)});\r\n                }\r\n        }\r\n\r\n        // Sequence of shaders to be put into the post-processing passes (Threejs EffectComposer).\r\n        // only include shaders up to the current step to enable each step of the process to be previewed.\r\n        return (\r\n            <>\r\n                {step >= 0 ? <grayscalePass attachArray=\"passes\" args={[selectedGrayscaleEncoding]} /> : null}\r\n                {step >= 1 ?  \r\n                <>\r\n                    <horizontalBlurPass attachArray=\"passes\" args={[kernel, kernelSize, ImgContainerRef.current.offsetWidth]} />\r\n                    <verticalBlurPass attachArray=\"passes\" args={[kernel, kernelSize, ImgContainerRef.current.offsetHeight]} />\r\n                </>\r\n                : null}\r\n                {step == 2 ? <gpuComputePass attachArray=\"passes\" args={[currentRenderers.sobel, currentRenderers.nms, renderParams.dims, false, null]} /> : null}\r\n                {step == 3 ? <gpuComputePass attachArray=\"passes\" args={[currentRenderers.sobel, currentRenderers.nms, renderParams.dims, true, null]} /> : null}\r\n                {step >= 4 ? <gpuComputePass attachArray=\"passes\" args={[currentRenderers.sobel, currentRenderers.nms, renderParams.dims, true, {high: highThreshold, low: lowThreshold}]} /> : null}\r\n                {step >= 5 ? <hysteresisPass attachArray=\"passes\" args={[hysteresisTolerance, hysteresisIters, intermediateRT.tg, renderParams.dims]}/> : null}\r\n                {step >= 6 ? <copyStrongPass attachArray=\"passes\" args={[renderParams.dims]}/> : null}\r\n            </>\r\n        )\r\n    }\r\n\r\n    // Wrap options in container for css styling.\r\n    const getOptions = (step) => {\r\n\r\n        return (\r\n            <div className=\"processor-options\">\r\n                {stepOptions[step]}\r\n            </div>\r\n        )\r\n    }\r\n\r\n    const Shaders = () => {\r\n        const composer = useRef();\r\n        const { scene, gl, size, camera } = useThree();\r\n\r\n        // Save GL environment to state to allow downloading of the canvas.\r\n        if (gl != rendererRef) {\r\n            setRendererRef(gl);\r\n        }\r\n\r\n        // Render post-processing once on mount.\r\n        useEffect(() => composer.current.render(), []);\r\n        // Render on each frame thereafter.\r\n        useFrame(() => composer.current.render(), 1);\r\n\r\n        return (\r\n            <effectComposer ref={composer} args={[gl]}>\r\n                <renderPass attachArray=\"passes\" scene={scene} camera={camera} />\r\n                {GetStepShaders(step, gl)}\r\n            </effectComposer>\r\n        )\r\n    }\r\n\r\n    return (\r\n\r\n        <div className=\"fill-container\">\r\n\r\n            <FadeIn visible={uploadVisibility}>\r\n                <ImageUploader onLoadCallback={onImageUpload} style={{display: _getDisplay()}}/>\r\n            </FadeIn>\r\n\r\n            {(imgSource != null && imgDims != null) ? (\r\n                <div className=\"fill-container\">\r\n                    <FadeIn className=\"fill-and-vertically-center\">\r\n\r\n                        <Row gutter={[16,16]} justify=\"center\" align=\"middle\" style={{display: \"flex\", alignItems: \"center\"}}>\r\n\r\n                            {/* Input image */}\r\n                            <Col className=\"process-preview-grid-col\" flex={1}>\r\n                                <div className=\"process-preview-container\" ><div ref={ImgContainerRef}><Image id=\"preview-before\" src={imgSource} onLoad={() => setDisplayDim({width: ImgContainerRef.current.offsetWidth, height: ImgContainerRef.current.offsetHeight})} /></div></div>\r\n                            </Col>\r\n\r\n                            {/* Processed Image */}\r\n                            <Col className=\"process-preview-grid-col\" flex={1}>\r\n                                <div className=\"process-preview-container\">\r\n                                    <Canvas \r\n                                        className=\"shader\"\r\n                                        camera={{fov: 50, position: [0, 0, 30]}}\r\n                                        gl={{preserveDrawingBuffer: true}}\r\n                                        style={{position: \"relative\", width: shaderDisplayDim.width, height: shaderDisplayDim.height}}\r\n                                    >\r\n                                        <Suspense fallback=\"Loading...\">\r\n                                            <ThreeImagePlane img={imgSource} dim={{width: imgDims.width, height: imgDims.height}}/>\r\n                                        </Suspense>\r\n                                        <Shaders />\r\n                                    </Canvas>\r\n                                </div>\r\n                            </Col>\r\n                            \r\n                            {/* Processing parameters */}\r\n                            <Col className=\"process-preview-grid-col\" flex={1} style={{alignSelf: \"stretch\"}}>\r\n                                <Row style={{display: \"flex\", alignItems: \"center\", paddingBottom: \"10px\"}}>\r\n                                    <Col ><Button onClick={() => setStep(prev => prev - 1)} disabled={!hasNextStep(step - 1)}>Previous</Button></Col>\r\n                                    <Col flex=\"auto\" align=\"center\"><h1 id=\"title\" style={{display: \"inline-block\", alignSelf: \"center\"}}><b>{stepTitles[step]}</b></h1></Col>\r\n                                    <Col align=\"right\" style={{paddingRight: \"5px\"}}><Button onClick={() => setStep(prev => prev + 1)} disabled={!hasNextStep(step + 1)} style={{float: \"right\"}}>Next</Button></Col>\r\n                                    <Col align=\"right\"><Button type=\"primary\" onClick={downloadCanvas} style={{float: \"right\"}}>{savingState ? <Spin size=\"middle\" indicator={<LoadingOutlined spin style={{color: \"white\"}}/>}/> : \"Save\"}</Button></Col>\r\n                                </Row>\r\n                                {getOptions(step)}\r\n                            </Col>\r\n\r\n                        </Row>\r\n                    </FadeIn>\r\n                    \r\n                    <FadeIn className=\"back-overlay\" visible={!uploadVisibility}>\r\n                        <Button id=\"button\"\r\n                            type=\"link\" \r\n                            style={{fontSize: \"15px\"}}\r\n                            onClick={() => {disposeRenderers(memoRenderers); goBack()}}\r\n                        >\r\n                            <ArrowLeftOutlined /> \r\n                            Change image\r\n                        </Button> \r\n                    </FadeIn>\r\n\r\n                </div>\r\n            ) : null}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport {Steps}; ","import React, { useState } from 'react'\r\nimport { notification } from 'antd';\r\nimport { WarningTwoTone } from '@ant-design/icons';\r\nimport { Steps } from './steps';\r\nimport \"./main.scss\";\r\n\r\n\r\nconst Main = () => {\r\n\r\n    // Only send notif once per acces to this route - not using state would make this notif appear on every re-render.\r\n    const [notifSent, setNotifSent] = useState(false);\r\n\r\n    const performanceNotification = () => {\r\n        if (notifSent === false) {\r\n            notification.open({\r\n                message: \"This project works best on a powerful machine!\",\r\n                description: <span>This page uses WebGL - a dedicated GPU is STRONGLY recommended.<br />Loading images which are too large or updating parameters too quickly <i>may</i> cause the browser to run out of memory.</span>,\r\n                icon: <WarningTwoTone twoToneColor=\"#FFA500\" />,\r\n                key: \"performance-notif\",\r\n                style: {width: 500}\r\n            });\r\n            setNotifSent(true);\r\n        }\r\n    }\r\n\r\n    performanceNotification();\r\n\r\n    return (\r\n        <div className=\"fill-container\">\r\n            {Steps()}\r\n        </div>\r\n    );\r\n}   \r\n\r\nexport default Main;"],"sourceRoot":""}